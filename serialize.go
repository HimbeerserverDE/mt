// Code generated by mkserialize.sh; DO NOT EDIT.

package mt

import (
	"bytes"
	"compress/zlib"
	"crypto/sha1"
	"errors"
	"fmt"
	"image/color"
	"io"
	"math"
	"sort"
	"unicode/utf16"

	"github.com/klauspost/compress/zstd"
)

func write8(w io.Writer, x uint8) {
	_, err := w.Write([]byte{x})
	chk(err)
}

func write16(w io.Writer, x uint16) {
	buf := make([]byte, 2)
	be.PutUint16(buf, x)
	_, err := w.Write(buf)
	chk(err)
}

func write32(w io.Writer, x uint32) {
	buf := make([]byte, 4)
	be.PutUint32(buf, x)
	_, err := w.Write(buf)
	chk(err)
}

func write64(w io.Writer, x uint64) {
	buf := make([]byte, 8)
	be.PutUint64(buf, x)
	_, err := w.Write(buf)
	chk(err)
}
func readBuf(r io.Reader, n int) []byte {
	buf := make([]byte, n)
	_, err := io.ReadFull(r, buf)
	chk(err)
	return buf
}

func read8(r io.Reader) uint8   { return readBuf(r, 1)[0] }
func read16(r io.Reader) uint16 { return be.Uint16(readBuf(r, 2)) }
func read32(r io.Reader) uint32 { return be.Uint32(readBuf(r, 4)) }
func read64(r io.Reader) uint64 { return be.Uint64(readBuf(r, 8)) }

func (obj *ToSrvNil) serialize(w io.Writer) {
}

func (obj *ToSrvNil) deserialize(r io.Reader) {
}

func (obj *ToSrvInit) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))[:])
		chk(err)
	}
	if err := pcall(func() {
		{
			x := (*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		*p = read16(r)
	}
	var local1 []uint8
	var local2 uint16
	{
		p := &local2
		*p = read16(r)
	}
	(local1) = make([]uint8, local2)
	{
		_, err := io.ReadFull(r, (local1)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName) = string(local1)
	if err := pcall(func() {
		{
			p := &(*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit2) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Lang string
	}))(obj)).Lang))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))[:])
		chk(err)
	}
}

func (obj *ToSrvInit2) deserialize(r io.Reader) {
	var local3 []uint8
	var local4 uint16
	{
		p := &local4
		*p = read16(r)
	}
	(local3) = make([]uint8, local4)
	{
		_, err := io.ReadFull(r, (local3)[:])
		chk(err)
	}
	((*(*(struct {
		Lang string
	}))(obj)).Lang) = string(local3)
}

func (obj *ToSrvJoinModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvJoinModChan) deserialize(r io.Reader) {
	var local5 []uint8
	var local6 uint16
	{
		p := &local6
		*p = read16(r)
	}
	(local5) = make([]uint8, local6)
	{
		_, err := io.ReadFull(r, (local5)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local5)
}

func (obj *ToSrvLeaveModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvLeaveModChan) deserialize(r io.Reader) {
	var local7 []uint8
	var local8 uint16
	{
		p := &local8
		*p = read16(r)
	}
	(local7) = make([]uint8, local8)
	{
		_, err := io.ReadFull(r, (local7)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local7)
}

func (obj *ToSrvMsgModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToSrvMsgModChan) deserialize(r io.Reader) {
	var local9 []uint8
	var local10 uint16
	{
		p := &local10
		*p = read16(r)
	}
	(local9) = make([]uint8, local10)
	{
		_, err := io.ReadFull(r, (local9)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel) = string(local9)
	var local11 []uint8
	var local12 uint16
	{
		p := &local12
		*p = read16(r)
	}
	(local11) = make([]uint8, local12)
	{
		_, err := io.ReadFull(r, (local11)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg) = string(local11)
}

func (obj *ToSrvPlayerPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvPlayerPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvGotBlks) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local13 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local14 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local13] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local13])[local14]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvGotBlks) deserialize(r io.Reader) {
	var local15 uint8
	{
		p := &local15
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local15)
	for local16 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local17 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local16] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local16])[local17]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local18 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local19 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local18] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local18])[local19]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) deserialize(r io.Reader) {
	var local20 uint8
	{
		p := &local20
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local20)
	for local21 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local22 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local21] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local21])[local22]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvInvAction) serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Action string
		}))(obj)).Action))[:])
		chk(err)
	}
}

func (obj *ToSrvInvAction) deserialize(r io.Reader) {
	var local23 []uint8
	{
		var err error
		(local23), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Action string
	}))(obj)).Action) = string(local23)
}

func (obj *ToSrvChatMsg) serialize(w io.Writer) {
	local24 := utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg))
	if len((local24)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local24)))
		write16(w, uint16(x))
	}
	for local25 := range local24 {
		{
			x := (local24)[local25]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToSrvChatMsg) deserialize(r io.Reader) {
	var local26 []uint16
	var local27 uint16
	{
		p := &local27
		*p = read16(r)
	}
	(local26) = make([]uint16, local27)
	for local28 := range local26 {
		{
			p := &(local26)[local28]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg = string(utf16.Decode(local26))
}

func (obj *ToSrvFallDmg) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount uint16
		}))(obj)).Amount
		write16(w, uint16(x))
	}
}

func (obj *ToSrvFallDmg) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount uint16
		}))(obj)).Amount
		*p = read16(r)
	}
}

func (obj *ToSrvSelectItem) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Slot uint16
		}))(obj)).Slot
		write16(w, uint16(x))
	}
}

func (obj *ToSrvSelectItem) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Slot uint16
		}))(obj)).Slot
		*p = read16(r)
	}
}

func (obj *ToSrvRespawn) serialize(w io.Writer) {
}

func (obj *ToSrvRespawn) deserialize(r io.Reader) {
}

func (obj *ToSrvInteract) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Interaction", err))
	}
	{
		x := (*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		write16(w, uint16(x))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			chk(writePointedThing(w, x))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvInteract) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Interaction", err))
	}
	{
		p := &(*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		*p = read16(r)
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			{
				var err error
				*p, err = readPointedThing(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvRemovedSounds) serialize(w io.Writer) {
	if len(((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			IDs []SoundID
		}))(obj)).IDs)))
		write16(w, uint16(x))
	}
	for local29 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local29]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvRemovedSounds) deserialize(r io.Reader) {
	var local30 uint16
	{
		p := &local30
		*p = read16(r)
	}
	((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs) = make([]SoundID, local30)
	for local31 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local31]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) serialize(w io.Writer) {
	for local32 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local32]
			write16(w, uint16(x))
		}
	}
	if len(([]byte((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local33 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local33]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) deserialize(r io.Reader) {
	for local34 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local34]
			*p = int16(read16(r))
		}
	}
	var local35 []uint8
	var local36 uint16
	{
		p := &local36
		*p = read16(r)
	}
	(local35) = make([]uint8, local36)
	{
		_, err := io.ReadFull(r, (local35)[:])
		chk(err)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local35)
	var local37 uint16
	{
		p := &local37
		*p = read16(r)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local37)
	for local38 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local38]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local39 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local39]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) deserialize(r io.Reader) {
	var local40 []uint8
	var local41 uint16
	{
		p := &local41
		*p = read16(r)
	}
	(local40) = make([]uint8, local41)
	{
		_, err := io.ReadFull(r, (local40)[:])
		chk(err)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local40)
	var local42 uint16
	{
		p := &local42
		*p = read16(r)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local42)
	for local43 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local43]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvReqMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		Filenames []string
	}))(obj)).Filenames)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)))
		write16(w, uint16(x))
	}
	for local44 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		if len(([]byte(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local44]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))[:])
			chk(err)
		}
	}
}

func (obj *ToSrvReqMedia) deserialize(r io.Reader) {
	var local45 uint16
	{
		p := &local45
		*p = read16(r)
	}
	((*(*(struct {
		Filenames []string
	}))(obj)).Filenames) = make([]string, local45)
	for local46 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		var local47 []uint8
		var local48 uint16
		{
			p := &local48
			*p = read16(r)
		}
		(local47) = make([]uint8, local48)
		{
			_, err := io.ReadFull(r, (local47)[:])
			chk(err)
		}
		(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local46]) = string(local47)
	}
}

func (obj *ToSrvHaveMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Tokens []uint32
		}))(obj)).Tokens)))
		write8(w, uint8(x))
	}
	for local49 := range (*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens {
		{
			x := ((*(*(struct {
				//mt:len8
				Tokens []uint32
			}))(obj)).Tokens)[local49]
			write32(w, uint32(x))
		}
	}
}

func (obj *ToSrvHaveMedia) deserialize(r io.Reader) {
	var local50 uint8
	{
		p := &local50
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens) = make([]uint32, local50)
	for local51 := range (*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens {
		{
			p := &((*(*(struct {
				//mt:len8
				Tokens []uint32
			}))(obj)).Tokens)[local51]
			*p = read32(r)
		}
	}
}

func (obj *ToSrvCltReady) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		write8(w, uint8(x))
	}
	if len(([]byte((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		write16(w, uint16(x))
	}
}

func (obj *ToSrvCltReady) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		*p = read8(r)
	}
	var local52 []uint8
	var local53 uint16
	{
		p := &local53
		*p = read16(r)
	}
	(local52) = make([]uint8, local53)
	{
		_, err := io.ReadFull(r, (local52)[:])
		chk(err)
	}
	((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version) = string(local52)
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		*p = read16(r)
	}
}

func (obj *ToSrvFirstSRP) serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvFirstSRP) deserialize(r io.Reader) {
	var local54 uint16
	{
		p := &local54
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt) = make([]byte, local54)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local55 uint16
	{
		p := &local55
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier) = make([]byte, local55)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesA) serialize(w io.Writer) {
	if len(((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvSRPBytesA) deserialize(r io.Reader) {
	var local56 uint16
	{
		p := &local56
		*p = read16(r)
	}
	((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A) = make([]byte, local56)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesM) serialize(w io.Writer) {
	if len(((*(*(struct {
		M []byte
	}))(obj)).M)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			M []byte
		}))(obj)).M)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToSrvSRPBytesM) deserialize(r io.Reader) {
	var local57 uint16
	{
		p := &local57
		*p = read16(r)
	}
	((*(*(struct {
		M []byte
	}))(obj)).M) = make([]byte, local57)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToCltHello) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	if len(([]byte((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))[:])
		chk(err)
	}
}

func (obj *ToCltHello) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	var local58 []uint8
	var local59 uint16
	{
		p := &local59
		*p = read16(r)
	}
	(local58) = make([]uint8, local59)
	{
		_, err := io.ReadFull(r, (local58)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username) = string(local58)
}

func (obj *ToCltAcceptAuth) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		write64(w, uint64(x))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptAuth) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		*p = read64(r)
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptSudoMode) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	{
		local60 := [15]byte{}
		{
			_, err := w.Write((local60)[:])
			chk(err)
		}
	}
}

func (obj *ToCltAcceptSudoMode) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	{
		var local61 [15]byte
		local62 := [15]byte{}
		{
			_, err := io.ReadFull(r, (local61)[:])
			chk(err)
		}
		if local61 != local62 {
			chk(fmt.Errorf("const %v: %v", "[15]byte{}", local61))
		}
	}
}

func (obj *ToCltDenySudoMode) serialize(w io.Writer) {
}

func (obj *ToCltDenySudoMode) deserialize(r io.Reader) {
}

func (obj *ToCltKick) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Reason).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.KickReason", err))
	}
	if !((*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason < maxKickReason) {
		chk(errors.New("assertion failed: %s.Reason < maxKickReason"))
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Custom || dr == Shutdown || dr == Crash {
		if len(([]byte((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Custom))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Custom))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Custom))[:])
			chk(err)
		}
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Shutdown || dr == Crash {
		{
			x := (*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Reconnect
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
}

func (obj *ToCltKick) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Reason).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.KickReason", err))
	}
	if !((*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason < maxKickReason) {
		chk(errors.New("assertion failed: %s.Reason < maxKickReason"))
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Custom || dr == Shutdown || dr == Crash {
		var local63 []uint8
		var local64 uint16
		{
			p := &local64
			*p = read16(r)
		}
		(local63) = make([]uint8, local64)
		{
			_, err := io.ReadFull(r, (local63)[:])
			chk(err)
		}
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Custom) = string(local63)
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Shutdown || dr == Crash {
		{
			p := &(*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Reconnect
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
}

func (obj *ToCltBlkData) serialize(w io.Writer) {
	for local65 := range (*(*(struct {
		Blkpos [3]int16
		//mt:zstd
		Blk MapBlk
	}))(obj)).Blkpos {
		{
			x := ((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blkpos)[local65]
			write16(w, uint16(x))
		}
	}
	{
		w, err := zstd.NewWriter(w)
		chk(err)
		if err := pcall(func() {
			((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blk).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlk", err))
		}
		chk(w.Close())
	}
}

func (obj *ToCltBlkData) deserialize(r io.Reader) {
	for local66 := range (*(*(struct {
		Blkpos [3]int16
		//mt:zstd
		Blk MapBlk
	}))(obj)).Blkpos {
		{
			p := &((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blkpos)[local66]
			*p = int16(read16(r))
		}
	}
	{
		r, err := zstd.NewReader(byteReader{r})
		chk(err)
		if err := pcall(func() {
			((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blk).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlk", err))
		}
		r.Close()
	}
}

func (obj *ToCltAddNode) serialize(w io.Writer) {
	for local67 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local67]
			write16(w, uint16(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Node", err))
	}
	{
		x := (*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltAddNode) deserialize(r io.Reader) {
	for local68 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local68]
			*p = int16(read16(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Node", err))
	}
	{
		p := &(*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltRemoveNode) serialize(w io.Writer) {
	for local69 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local69]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltRemoveNode) deserialize(r io.Reader) {
	for local70 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local70]
			*p = int16(read16(r))
		}
	}
}

func (obj *ToCltInv) serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltInv) deserialize(r io.Reader) {
	var local71 []uint8
	{
		var err error
		(local71), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local71)
}

func (obj *ToCltTimeOfDay) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltTimeOfDay) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltCSMRestrictionFlags) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CSMRestrictionFlags", err))
	}
	{
		x := (*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		write32(w, uint32(x))
	}
}

func (obj *ToCltCSMRestrictionFlags) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CSMRestrictionFlags", err))
	}
	{
		p := &(*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		*p = read32(r)
	}
}

func (obj *ToCltAddPlayerVel) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltAddPlayerVel) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltMediaPush) serialize(w io.Writer) {
	{
		local72 := uint16(sha1.Size)
		{
			x := local72
			write16(w, uint16(x))
		}
	}
	{
		_, err := w.Write(((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).SHA1)[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1          [sha1.Size]byte
		Filename      string
		CallbackToken uint32
		ShouldCache   bool
	}))(obj)).Filename))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).Filename))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).Filename))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).CallbackToken
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).ShouldCache
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltMediaPush) deserialize(r io.Reader) {
	{
		var local73 uint16
		local74 := uint16(sha1.Size)
		{
			p := &local73
			*p = read16(r)
		}
		if local73 != local74 {
			chk(fmt.Errorf("const %v: %v", "uint16(sha1.Size)", local73))
		}
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).SHA1)[:])
		chk(err)
	}
	var local75 []uint8
	var local76 uint16
	{
		p := &local76
		*p = read16(r)
	}
	(local75) = make([]uint8, local76)
	{
		_, err := io.ReadFull(r, (local75)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1          [sha1.Size]byte
		Filename      string
		CallbackToken uint32
		ShouldCache   bool
	}))(obj)).Filename) = string(local75)
	{
		p := &(*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).CallbackToken
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).ShouldCache
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltChatMsg) serialize(w io.Writer) {
	{
		local77 := uint8(1)
		{
			x := local77
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ChatMsgType", err))
	}
	local78 := utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender))
	if len((local78)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local78)))
		write16(w, uint16(x))
	}
	for local79 := range local78 {
		{
			x := (local78)[local79]
			write16(w, uint16(x))
		}
	}
	local80 := utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text))
	if len((local80)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local80)))
		write16(w, uint16(x))
	}
	for local81 := range local80 {
		{
			x := (local80)[local81]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		write64(w, uint64(x))
	}
}

func (obj *ToCltChatMsg) deserialize(r io.Reader) {
	{
		var local82 uint8
		local83 := uint8(1)
		{
			p := &local82
			*p = read8(r)
		}
		if local82 != local83 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local82))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ChatMsgType", err))
	}
	var local84 []uint16
	var local85 uint16
	{
		p := &local85
		*p = read16(r)
	}
	(local84) = make([]uint16, local85)
	for local86 := range local84 {
		{
			p := &(local84)[local86]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender = string(utf16.Decode(local84))
	var local87 []uint16
	var local88 uint16
	{
		p := &local88
		*p = read16(r)
	}
	(local87) = make([]uint16, local88)
	for local89 := range local87 {
		{
			p := &(local87)[local89]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text = string(utf16.Decode(local87))
	{
		p := &(*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		*p = int64(read64(r))
	}
}

func (obj *ToCltAORmAdd) serialize(w io.Writer) {
	if len(((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []AOAdd
		}))(obj)).Remove)))
		write16(w, uint16(x))
	}
	for local90 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Remove)[local90]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
		}
	}
	if len(((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []AOAdd
		}))(obj)).Add)))
		write16(w, uint16(x))
	}
	for local91 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Add)[local91]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAdd", err))
		}
	}
}

func (obj *ToCltAORmAdd) deserialize(r io.Reader) {
	var local92 uint16
	{
		p := &local92
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove) = make([]AOID, local92)
	for local93 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Remove)[local93]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
		}
	}
	var local94 uint16
	{
		p := &local94
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add) = make([]AOAdd, local94)
	for local95 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Add)[local95]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAdd", err))
		}
	}
}

func (obj *ToCltAOMsgs) serialize(w io.Writer) {
	for local96 := range (*(*(struct {
		//mt:raw
		Msgs []IDAOMsg
	}))(obj)).Msgs {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:raw
				Msgs []IDAOMsg
			}))(obj)).Msgs)[local96]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.IDAOMsg", err))
		}
	}
}

func (obj *ToCltAOMsgs) deserialize(r io.Reader) {
	for {
		var local97 IDAOMsg
		err := pcall(func() {
			if err := pcall(func() {
				(local97).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.IDAOMsg", err))
			}
		})
		if err == io.EOF {
			break
		}
		((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs) = append(((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs), local97)
		chk(err)
	}
}

func (obj *ToCltHP) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP uint16
		}))(obj)).HP
		write16(w, uint16(x))
	}
}

func (obj *ToCltHP) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP uint16
		}))(obj)).HP
		*p = read16(r)
	}
}

func (obj *ToCltMovePlayer) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovePlayer) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltLegacyKick) serialize(w io.Writer) {
	local98 := utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason))
	if len((local98)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local98)))
		write16(w, uint16(x))
	}
	for local99 := range local98 {
		{
			x := (local98)[local99]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltLegacyKick) deserialize(r io.Reader) {
	var local100 []uint16
	var local101 uint16
	{
		p := &local101
		*p = read16(r)
	}
	(local100) = make([]uint16, local101)
	for local102 := range local100 {
		{
			p := &(local100)[local102]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason = string(utf16.Decode(local100))
}

func (obj *ToCltFOV) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFOV) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltDeathScreen) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
}

func (obj *ToCltDeathScreen) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
}

func (obj *ToCltMedia) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).N
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).I
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)))
		write32(w, uint32(x))
	}
	for local103 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local103]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local103]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local103]).Name))[:])
			chk(err)
		}
		if len(((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local103]).Data)) > math.MaxUint32 {
			chk(ErrTooLong)
		}
		{
			x := uint32(len(((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local103]).Data)))
			write32(w, uint32(x))
		}
		{
			_, err := w.Write(((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local103]).Data)[:])
			chk(err)
		}
	}
}

func (obj *ToCltMedia) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).N
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).I
		*p = read16(r)
	}
	var local104 uint32
	{
		p := &local104
		*p = read32(r)
	}
	((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files) = make([]struct {
		Name string
		Data []byte
	}, local104)
	for local105 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files {
		var local106 []uint8
		var local107 uint16
		{
			p := &local107
			*p = read16(r)
		}
		(local106) = make([]uint8, local107)
		{
			_, err := io.ReadFull(r, (local106)[:])
			chk(err)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local105]).Name) = string(local106)
		var local108 uint32
		{
			p := &local108
			*p = read32(r)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local105]).Data) = make([]byte, local108)
		{
			_, err := io.ReadFull(r, ((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local105]).Data)[:])
			chk(err)
		}
	}
}

func (obj *ToCltNodeDefs) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w := zlib.NewWriter(w)
			{
				local109 := uint8(1)
				{
					x := local109
					write8(w, uint8(x))
				}
			}
			{
				x := (*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					var b bytes.Buffer
					for i := range x {
						x[i].serialize(&b)
					}
					if b.Len() > math.MaxUint32 {
						chk(ErrTooLong)
					}
					write32(w, uint32(b.Len()))
					_, err := b.WriteTo(w)
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeDefs) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			{
				var local110 uint8
				local111 := uint8(1)
				{
					p := &local110
					*p = read8(r)
				}
				if local110 != local111 {
					chk(fmt.Errorf("const %v: %v", "uint8(1)", local110))
				}
			}
			{
				p := &(*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					*p = make([]NodeDef, read16(r))
					r := &io.LimitedReader{R: r, N: int64(read32(r))}
					for i := range *p {
						(*p)[i].deserialize(r)
					}
					if r.N > 0 {
						chk(fmt.Errorf("%d bytes of trailing data", r.N))
					}
				}
			}
			chk(r.Close())
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltAnnounceMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)))
		write16(w, uint16(x))
	}
	for local112 := range (*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local112]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local112]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local112]).Name))[:])
			chk(err)
		}
		if len(([]byte((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local112]).Base64SHA1))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local112]).Base64SHA1))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local112]).Base64SHA1))[:])
			chk(err)
		}
	}
	if len(([]byte((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).URL))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).URL))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).URL))[:])
		chk(err)
	}
}

func (obj *ToCltAnnounceMedia) deserialize(r io.Reader) {
	var local113 uint16
	{
		p := &local113
		*p = read16(r)
	}
	((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files) = make([]struct {
		Name       string
		Base64SHA1 string
	}, local113)
	for local114 := range (*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files {
		var local115 []uint8
		var local116 uint16
		{
			p := &local116
			*p = read16(r)
		}
		(local115) = make([]uint8, local116)
		{
			_, err := io.ReadFull(r, (local115)[:])
			chk(err)
		}
		((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local114]).Name) = string(local115)
		var local117 []uint8
		var local118 uint16
		{
			p := &local118
			*p = read16(r)
		}
		(local117) = make([]uint8, local118)
		{
			_, err := io.ReadFull(r, (local117)[:])
			chk(err)
		}
		((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local114]).Base64SHA1) = string(local117)
	}
	var local119 []uint8
	var local120 uint16
	{
		p := &local120
		*p = read16(r)
	}
	(local119) = make([]uint8, local120)
	{
		_, err := io.ReadFull(r, (local119)[:])
		chk(err)
	}
	((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).URL) = string(local119)
}

func (obj *ToCltItemDefs) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w := zlib.NewWriter(w)
			{
				local121 := uint8(0)
				{
					x := local121
					write8(w, uint8(x))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Defs)))
				write16(w, uint16(x))
			}
			for local122 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local122]).serialize(w)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemDef", err))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)))
				write16(w, uint16(x))
			}
			for local123 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local123]).Alias))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local123]).Alias))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local123]).Alias))[:])
					chk(err)
				}
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local123]).Orig))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local123]).Orig))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local123]).Orig))[:])
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltItemDefs) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			{
				var local124 uint8
				local125 := uint8(0)
				{
					p := &local124
					*p = read8(r)
				}
				if local124 != local125 {
					chk(fmt.Errorf("const %v: %v", "uint8(0)", local124))
				}
			}
			var local126 uint16
			{
				p := &local126
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs) = make([]ItemDef, local126)
			for local127 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local127]).deserialize(r)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemDef", err))
				}
			}
			var local128 uint16
			{
				p := &local128
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases) = make([]struct {
				Alias string
				Orig  string
			}, local128)
			for local129 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				var local130 []uint8
				var local131 uint16
				{
					p := &local131
					*p = read16(r)
				}
				(local130) = make([]uint8, local131)
				{
					_, err := io.ReadFull(r, (local130)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local129]).Alias) = string(local130)
				var local132 []uint8
				var local133 uint16
				{
					p := &local133
					*p = read16(r)
				}
				(local132) = make([]uint8, local133)
				{
					_, err := io.ReadFull(r, (local132)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local129]).Orig) = string(local132)
			}
			chk(r.Close())
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltPlaySound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	if len(([]byte((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcType).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcAOID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Loop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Ephemeral
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltPlaySound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	var local134 []uint8
	var local135 uint16
	{
		p := &local135
		*p = read16(r)
	}
	(local134) = make([]uint8, local135)
	{
		_, err := io.ReadFull(r, (local134)[:])
		chk(err)
	}
	((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
	}))(obj)).Name) = string(local134)
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcType).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcAOID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Loop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Ephemeral
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltStopSound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
}

func (obj *ToCltStopSound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
}

func (obj *ToCltPrivs) serialize(w io.Writer) {
	if len(((*(*(struct {
		Privs []string
	}))(obj)).Privs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Privs []string
		}))(obj)).Privs)))
		write16(w, uint16(x))
	}
	for local136 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		if len(([]byte(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local136]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local136]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local136]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltPrivs) deserialize(r io.Reader) {
	var local137 uint16
	{
		p := &local137
		*p = read16(r)
	}
	((*(*(struct {
		Privs []string
	}))(obj)).Privs) = make([]string, local137)
	for local138 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		var local139 []uint8
		var local140 uint16
		{
			p := &local140
			*p = read16(r)
		}
		(local139) = make([]uint8, local140)
		{
			_, err := io.ReadFull(r, (local139)[:])
			chk(err)
		}
		(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local138]) = string(local139)
	}
}

func (obj *ToCltInvFormspec) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))[:])
		chk(err)
	}
}

func (obj *ToCltInvFormspec) deserialize(r io.Reader) {
	var local141 []uint8
	var local142 uint32
	{
		p := &local142
		*p = read32(r)
	}
	(local141) = make([]uint8, local142)
	{
		_, err := io.ReadFull(r, (local141)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec) = string(local141)
}

func (obj *ToCltDetachedInv) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltDetachedInv) deserialize(r io.Reader) {
	var local143 []uint8
	var local144 uint16
	{
		p := &local144
		*p = read16(r)
	}
	(local143) = make([]uint8, local144)
	{
		_, err := io.ReadFull(r, (local143)[:])
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name) = string(local143)
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		*p = read16(r)
	}
	var local145 []uint8
	{
		var err error
		(local145), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local145)
}

func (obj *ToCltShowFormspec) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))[:])
		chk(err)
	}
}

func (obj *ToCltShowFormspec) deserialize(r io.Reader) {
	var local146 []uint8
	var local147 uint32
	{
		p := &local147
		*p = read32(r)
	}
	(local146) = make([]uint8, local147)
	{
		_, err := io.ReadFull(r, (local146)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec) = string(local146)
	var local148 []uint8
	var local149 uint16
	{
		p := &local149
		*p = read16(r)
	}
	(local148) = make([]uint8, local149)
	{
		_, err := io.ReadFull(r, (local148)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname) = string(local148)
}

func (obj *ToCltMovement) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovement) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSpawnParticle) serialize(w io.Writer) {
	for local150 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Pos)[local150]
			write32(w, math.Float32bits(x))
		}
	}
	for local151 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Vel {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Vel)[local151]
			write32(w, math.Float32bits(x))
		}
	}
	for local152 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Acc {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Acc)[local152]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).ExpirationTime
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Texture))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Texture))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Texture))))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AnimParams).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
}

func (obj *ToCltSpawnParticle) deserialize(r io.Reader) {
	for local153 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Pos)[local153]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local154 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Vel {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Vel)[local154]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local155 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Acc {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Acc)[local155]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).ExpirationTime
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local156 []uint8
	var local157 uint32
	{
		p := &local157
		*p = read32(r)
	}
	(local156) = make([]uint8, local157)
	{
		_, err := io.ReadFull(r, (local156)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Texture))) = string(local156)
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AnimParams).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeTile
		*p = read8(r)
	}
}

func (obj *ToCltAddParticleSpawner) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Amount
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Duration
		write32(w, math.Float32bits(x))
	}
	for local158 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Pos {
		for local159 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Pos)[local158] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Pos)[local158])[local159]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local160 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Vel {
		for local161 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vel)[local160] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Vel)[local160])[local161]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local162 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Acc {
		for local163 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Acc)[local162] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Acc)[local162])[local163]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local164 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).ExpirationTime {
		{
			x := ((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).ExpirationTime)[local164]
			write32(w, math.Float32bits(x))
		}
	}
	for local165 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).Size)[local165]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Texture))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Texture))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Texture))))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AttachedAOID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AnimParams).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
}

func (obj *ToCltAddParticleSpawner) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Amount
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Duration
		*p = math.Float32frombits(read32(r))
	}
	for local166 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Pos {
		for local167 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Pos)[local166] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Pos)[local166])[local167]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local168 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Vel {
		for local169 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vel)[local168] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Vel)[local168])[local169]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local170 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Acc {
		for local171 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Acc)[local170] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool
					NodeParam0   Content
					NodeParam2   uint8
					NodeTile     uint8
				}))(obj)).Acc)[local170])[local171]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local172 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).ExpirationTime {
		{
			p := &((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).ExpirationTime)[local172]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local173 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool
				NodeParam0   Content
				NodeParam2   uint8
				NodeTile     uint8
			}))(obj)).Size)[local173]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local174 []uint8
	var local175 uint32
	{
		p := &local175
		*p = read32(r)
	}
	(local174) = make([]uint8, local175)
	{
		_, err := io.ReadFull(r, (local174)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool
		NodeParam0   Content
		NodeParam2   uint8
		NodeTile     uint8
	}))(obj)).Texture))) = string(local174)
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AttachedAOID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AnimParams).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool
			NodeParam0   Content
			NodeParam2   uint8
			NodeTile     uint8
		}))(obj)).NodeTile
		*p = read8(r)
	}
}

func (obj *ToCltAddHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).HUD).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUD", err))
	}
}

func (obj *ToCltAddHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).HUD).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUD", err))
	}
}

func (obj *ToCltRmHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
}

func (obj *ToCltRmHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
}

func (obj *ToCltChangeHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Field).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDPos {
		for local176 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Pos {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Pos)[local176]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDName {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Name))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDScale {
		for local177 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Scale {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Scale)[local177]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDNumber {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Number
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDItem {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Item
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDDir {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Dir
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDAlign {
		for local178 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Align {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Align)[local178]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDOffset {
		for local179 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Offset {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Offset)[local179]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).WorldPos).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDSize {
		for local180 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Size {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Size)[local180]
				write32(w, uint32(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDZIndex {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).ZIndex
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText2 {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text2))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text2))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text2))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDStyle {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Style).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
		}
	}
}

func (obj *ToCltChangeHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Field).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDPos {
		for local181 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Pos {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Pos)[local181]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDName {
		var local182 []uint8
		var local183 uint16
		{
			p := &local183
			*p = read16(r)
		}
		(local182) = make([]uint8, local183)
		{
			_, err := io.ReadFull(r, (local182)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Name) = string(local182)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDScale {
		for local184 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Scale {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Scale)[local184]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText {
		var local185 []uint8
		var local186 uint16
		{
			p := &local186
			*p = read16(r)
		}
		(local185) = make([]uint8, local186)
		{
			_, err := io.ReadFull(r, (local185)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text) = string(local185)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDNumber {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Number
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDItem {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Item
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDDir {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Dir
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDAlign {
		for local187 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Align {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Align)[local187]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDOffset {
		for local188 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Offset {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Offset)[local188]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).WorldPos).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDSize {
		for local189 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Size {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Size)[local189]
				*p = int32(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDZIndex {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).ZIndex
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText2 {
		var local190 []uint8
		var local191 uint16
		{
			p := &local191
			*p = read16(r)
		}
		(local190) = make([]uint8, local191)
		{
			_, err := io.ReadFull(r, (local190)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text2) = string(local190)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDStyle {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Style).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
		}
	}
}

func (obj *ToCltHUDFlags) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
}

func (obj *ToCltHUDFlags) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
}

func (obj *ToCltSetHotbarParam) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			local192 := uint16(4) // Size of Size field.
			{
				x := local192
				write16(w, uint16(x))
			}
		}
		{
			x := (*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
}

func (obj *ToCltSetHotbarParam) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			var local193 uint16
			local194 := uint16(4) // Size of Size field.
			{
				p := &local193
				*p = read16(r)
			}
			if local193 != local194 {
				chk(fmt.Errorf("const %v: %v", "uint16(4) // Size of Size field.", local193))
			}
		}
		{
			p := &(*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
}

func (obj *ToCltBreath) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Breath uint16
		}))(obj)).Breath
		write16(w, uint16(x))
	}
}

func (obj *ToCltBreath) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Breath uint16
		}))(obj)).Breath
		*p = read16(r)
	}
}

func (obj *ToCltSkyParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).BgColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Type))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Type))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Clouds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).SunFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).MoonFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).FogTintType))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).FogTintType))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).FogTintType))[:])
		chk(err)
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "skybox" {
		if len(((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Textures)))
			write16(w, uint16(x))
		}
		for local195 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA
				}))(obj)).Textures)[local195]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "regular" {
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DaySky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DayHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Indoor
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
}

func (obj *ToCltSkyParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).BgColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local196 []uint8
	var local197 uint16
	{
		p := &local197
		*p = read16(r)
	}
	(local196) = make([]uint8, local197)
	{
		_, err := io.ReadFull(r, (local196)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type) = string(local196)
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Clouds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).SunFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).MoonFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local198 []uint8
	var local199 uint16
	{
		p := &local199
		*p = read16(r)
	}
	(local198) = make([]uint8, local199)
	{
		_, err := io.ReadFull(r, (local198)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).FogTintType) = string(local198)
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "skybox" {
		var local200 uint16
		{
			p := &local200
			*p = read16(r)
		}
		((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures) = make([]Texture, local200)
		for local201 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA
				}))(obj)).Textures)[local201]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA
	}))(obj)).Type == "regular" {
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DaySky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DayHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).DawnHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).NightHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA
			}))(obj)).Indoor
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
}

func (obj *ToCltOverrideDayNightRatio) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		write16(w, uint16(x))
	}
}

func (obj *ToCltOverrideDayNightRatio) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		*p = read16(r)
	}
}

func (obj *ToCltLocalPlayerAnim) serialize(w io.Writer) {
	for local202 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local202]
			write32(w, uint32(x))
		}
	}
	for local203 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local203]
			write32(w, uint32(x))
		}
	}
	for local204 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local204]
			write32(w, uint32(x))
		}
	}
	for local205 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local205]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltLocalPlayerAnim) deserialize(r io.Reader) {
	for local206 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local206]
			*p = int32(read32(r))
		}
	}
	for local207 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local207]
			*p = int32(read32(r))
		}
	}
	for local208 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local208]
			*p = int32(read32(r))
		}
	}
	for local209 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local209]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltEyeOffset) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).First).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).Third).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltEyeOffset) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).First).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).Third).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltDelParticleSpawner) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltDelParticleSpawner) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltCloudParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		write32(w, math.Float32bits(x))
	}
	for local210 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			x := ((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local210]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *ToCltCloudParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		*p = math.Float32frombits(read32(r))
	}
	for local211 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			p := &((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local211]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ToCltFadeSound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFadeSound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltUpdatePlayerList) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerListUpdateType", err))
	}
	if len(((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)))
		write16(w, uint16(x))
	}
	for local212 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		if len(([]byte(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local212]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local212]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local212]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltUpdatePlayerList) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerListUpdateType", err))
	}
	var local213 uint16
	{
		p := &local213
		*p = read16(r)
	}
	((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players) = make([]string, local213)
	for local214 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		var local215 []uint8
		var local216 uint16
		{
			p := &local216
			*p = read16(r)
		}
		(local215) = make([]uint8, local216)
		{
			_, err := io.ReadFull(r, (local215)[:])
			chk(err)
		}
		(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local214]) = string(local215)
	}
}

func (obj *ToCltModChanMsg) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToCltModChanMsg) deserialize(r io.Reader) {
	var local217 []uint8
	var local218 uint16
	{
		p := &local218
		*p = read16(r)
	}
	(local217) = make([]uint8, local218)
	{
		_, err := io.ReadFull(r, (local217)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel) = string(local217)
	var local219 []uint8
	var local220 uint16
	{
		p := &local220
		*p = read16(r)
	}
	(local219) = make([]uint8, local220)
	{
		_, err := io.ReadFull(r, (local219)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender) = string(local219)
	var local221 []uint8
	var local222 uint16
	{
		p := &local222
		*p = read16(r)
	}
	(local221) = make([]uint8, local222)
	{
		_, err := io.ReadFull(r, (local221)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg) = string(local221)
}

func (obj *ToCltModChanSig) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ModChanSig", err))
	}
	if len(([]byte((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToCltModChanSig) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ModChanSig", err))
	}
	var local223 []uint8
	var local224 uint16
	{
		p := &local224
		*p = read16(r)
	}
	(local223) = make([]uint8, local224)
	{
		_, err := io.ReadFull(r, (local223)[:])
		chk(err)
	}
	((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel) = string(local223)
}

func (obj *ToCltNodeMetasChanged) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				r, err := zlib.NewReader(byteReader{r})
				chk(err)
				if x == nil {
					write8(w, 0)
				} else {
					write8(w, 2)
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					keys := make([][3]int16, 0, len(x))
					for key := range x {
						keys = append(keys, key)
					}
					sort.Slice(keys, func(i, j int) bool {
						p, q := keys[i], keys[j]
						for i := range p {
							switch {
							case p[i] < q[i]:
								return true
							case p[i] > q[i]:
								return false
							}
						}
						return false
					})
					for _, key := range keys {
						for _, n := range key {
							write16(w, uint16(n))
						}
						chk(serialize(w, x[key]))
					}
				}
				chk(r.Close())
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeMetasChanged) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				r, err := zlib.NewReader(byteReader{r})
				chk(err)
				switch ver := read8(r); ver {
				case 0:
					*p = nil
				case 2:
					n := read16(r)
					*p = make(map[[3]int16]*NodeMeta, n)
					for ; n > 0; n-- {
						var pos [3]int16
						for i := range pos {
							pos[i] = int16(read16(r))
						}
						nm := new(NodeMeta)
						chk(deserialize(r, nm))
						(*p)[pos] = nm
					}
				default:
					chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
				}
				chk(r.Close())
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltSunParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltSunParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltMoonParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMoonParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltStarParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Count
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Color
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltStarParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Count
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Color
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Count   uint32
			Color   color.NRGBA
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSRPBytesSaltB) serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).B)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltSRPBytesSaltB) deserialize(r io.Reader) {
	var local225 uint16
	{
		p := &local225
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt) = make([]byte, local225)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local226 uint16
	{
		p := &local226
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).B) = make([]byte, local226)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Prepend string
	}))(obj)).Prepend))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) deserialize(r io.Reader) {
	var local227 []uint8
	var local228 uint16
	{
		p := &local228
		*p = read16(r)
	}
	(local227) = make([]uint8, local228)
	{
		_, err := io.ReadFull(r, (local227)[:])
		chk(err)
	}
	((*(*(struct {
		Prepend string
	}))(obj)).Prepend) = string(local227)
}

func (obj *AOCmdProps) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOProps", err))
	}
}

func (obj *AOCmdProps) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOProps", err))
	}
}

func (obj *AOCmdPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPos", err))
	}
}

func (obj *AOCmdPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPos", err))
	}
}

func (obj *AOCmdTextureMod) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
}

func (obj *AOCmdTextureMod) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
}

func (obj *AOCmdSprite) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOSprite", err))
	}
}

func (obj *AOCmdSprite) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOSprite", err))
	}
}

func (obj *AOCmdHP) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP uint16
		}))(obj)).HP
		write16(w, uint16(x))
	}
}

func (obj *AOCmdHP) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP uint16
		}))(obj)).HP
		*p = read16(r)
	}
}

func (obj *AOCmdArmorGroups) serialize(w io.Writer) {
	if len(((*(*(struct {
		Armor []Group
	}))(obj)).Armor)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Armor []Group
		}))(obj)).Armor)))
		write16(w, uint16(x))
	}
	for local229 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local229]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
		}
	}
}

func (obj *AOCmdArmorGroups) deserialize(r io.Reader) {
	var local230 uint16
	{
		p := &local230
		*p = read16(r)
	}
	((*(*(struct {
		Armor []Group
	}))(obj)).Armor) = make([]Group, local230)
	for local231 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local231]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
		}
	}
}

func (obj *AOCmdAnim) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAnim", err))
	}
}

func (obj *AOCmdAnim) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAnim", err))
	}
}

func (obj *AOCmdBonePos) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Bone string
		Pos  AOBonePos
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOBonePos", err))
	}
}

func (obj *AOCmdBonePos) deserialize(r io.Reader) {
	var local232 []uint8
	var local233 uint16
	{
		p := &local233
		*p = read16(r)
	}
	(local232) = make([]uint8, local233)
	{
		_, err := io.ReadFull(r, (local232)[:])
		chk(err)
	}
	((*(*(struct {
		Bone string
		Pos  AOBonePos
	}))(obj)).Bone) = string(local232)
	if err := pcall(func() {
		((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOBonePos", err))
	}
}

func (obj *AOCmdAttach) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAttach", err))
	}
}

func (obj *AOCmdAttach) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAttach", err))
	}
}

func (obj *AOCmdPhysOverride) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdPhysOverride) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdSpawnInfant) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		local234 := genericCAO
		if err := pcall(func() {
			(local234).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
	}
}

func (obj *AOCmdSpawnInfant) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var local235 aoType
		local236 := genericCAO
		if err := pcall(func() {
			(local235).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
		if local235 != local236 {
			chk(fmt.Errorf("const %v: %v", "genericCAO", local235))
		}
	}
}

func (obj *AOCmdAnimSpeed) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Speed float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOCmdAnimSpeed) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Speed float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *NodeMeta) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			//mt:len32
			Fields []NodeMetaField

			Inv Inv
		}))(obj)).Fields)))
		write32(w, uint32(x))
	}
	for local237 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local237]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Serialize(w))
}

func (obj *NodeMeta) deserialize(r io.Reader) {
	var local238 uint32
	{
		p := &local238
		*p = read32(r)
	}
	((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields) = make([]NodeMetaField, local238)
	for local239 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local239]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Deserialize(r))
}

func (obj *MinimapMode) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MinimapType", err))
	}
	if len(([]byte((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		write16(w, uint16(x))
	}
}

func (obj *MinimapMode) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MinimapType", err))
	}
	var local240 []uint8
	var local241 uint16
	{
		p := &local241
		*p = read16(r)
	}
	(local240) = make([]uint8, local241)
	{
		_, err := io.ReadFull(r, (local240)[:])
		chk(err)
	}
	((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label) = string(local240)
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		*p = read16(r)
	}
}

func (obj *NodeDef) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Param0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local242 := uint8(13)
			{
				x := local242
				write8(w, uint8(x))
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local243 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).Groups)[local243]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).P1Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).P2Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrawType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DrawType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Mesh))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Mesh))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Mesh))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Scale
			write32(w, math.Float32bits(x))
		}
		{
			local244 := uint8(6)
			{
				x := local244
				write8(w, uint8(x))
			}
		}
		for local245 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).Tiles)[local245]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		for local246 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).OverlayTiles)[local246]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			local247 := uint8(6)
			{
				x := local247
				write8(w, uint8(x))
			}
		}
		for local248 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).SpecialTiles)[local248]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Palette).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Waving).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.WaveType", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ConnectSides
			write8(w, uint8(x))
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).ConnectTo)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ConnectTo)))
			write16(w, uint16(x))
		}
		for local249 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).ConnectTo)[local249]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).InsideTint
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Level
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Translucent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Transparent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LightSrc
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).GndContent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Collides
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Pointable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Diggable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Climbable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Replaceable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).OnRightClick
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DmgPerSec
			write32(w, uint32(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiquidType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LiquidType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).FlowingAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FlowingAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FlowingAlt))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).SrcAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).SrcAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).SrcAlt))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Viscosity
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiqRenewable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FlowRange
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrownDmg
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Floodable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrawBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ColBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).SelBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FootstepSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DiggingSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DugSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LegacyFaceDir
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LegacyMounted
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).DigPredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DigPredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DigPredict))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).MaxLvl
			write8(w, uint8(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).AlphaUse).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlphaUse", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).MoveResistance
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiquidMovePhysics
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *NodeDef) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Param0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			var local250 uint8
			local251 := uint8(13)
			{
				p := &local250
				*p = read8(r)
			}
			if local250 != local251 {
				chk(fmt.Errorf("const %v: %v", "uint8(13)", local250))
			}
		}
		var local252 []uint8
		var local253 uint16
		{
			p := &local253
			*p = read16(r)
		}
		(local252) = make([]uint8, local253)
		{
			_, err := io.ReadFull(r, (local252)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Name) = string(local252)
		var local254 uint16
		{
			p := &local254
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Groups) = make([]Group, local254)
		for local255 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).Groups)[local255]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).P1Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).P2Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrawType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DrawType", err))
		}
		var local256 []uint8
		var local257 uint16
		{
			p := &local257
			*p = read16(r)
		}
		(local256) = make([]uint8, local257)
		{
			_, err := io.ReadFull(r, (local256)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Mesh) = string(local256)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Scale
			*p = math.Float32frombits(read32(r))
		}
		{
			var local258 uint8
			local259 := uint8(6)
			{
				p := &local258
				*p = read8(r)
			}
			if local258 != local259 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local258))
			}
		}
		for local260 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).Tiles)[local260]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		for local261 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).OverlayTiles)[local261]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			var local262 uint8
			local263 := uint8(6)
			{
				p := &local262
				*p = read8(r)
			}
			if local262 != local263 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local262))
			}
		}
		for local264 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).SpecialTiles)[local264]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Palette).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Waving).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.WaveType", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ConnectSides
			*p = read8(r)
		}
		var local265 uint16
		{
			p := &local265
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).ConnectTo) = make([]Content, local265)
		for local266 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).ConnectTo)[local266]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).InsideTint
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Level
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Translucent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Transparent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LightSrc
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).GndContent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Collides
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Pointable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Diggable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Climbable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Replaceable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).OnRightClick
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DmgPerSec
			*p = int32(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiquidType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LiquidType", err))
		}
		var local267 []uint8
		var local268 uint16
		{
			p := &local268
			*p = read16(r)
		}
		(local267) = make([]uint8, local268)
		{
			_, err := io.ReadFull(r, (local267)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).FlowingAlt) = string(local267)
		var local269 []uint8
		var local270 uint16
		{
			p := &local270
			*p = read16(r)
		}
		(local269) = make([]uint8, local270)
		{
			_, err := io.ReadFull(r, (local269)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).SrcAlt) = string(local269)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Viscosity
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiqRenewable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FlowRange
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrownDmg
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Floodable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrawBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ColBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).SelBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FootstepSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DiggingSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DugSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LegacyFaceDir
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LegacyMounted
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		var local271 []uint8
		var local272 uint16
		{
			p := &local272
			*p = read16(r)
		}
		(local271) = make([]uint8, local272)
		{
			_, err := io.ReadFull(r, (local271)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).DigPredict) = string(local271)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).MaxLvl
			*p = read8(r)
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).AlphaUse).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlphaUse", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).MoveResistance
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiquidMovePhysics
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *PointedNode) serialize(w io.Writer) {
	for local273 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local273]
			write16(w, uint16(x))
		}
	}
	for local274 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local274]
			write16(w, uint16(x))
		}
	}
}

func (obj *PointedNode) deserialize(r io.Reader) {
	for local275 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local275]
			*p = int16(read16(r))
		}
	}
	for local276 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local276]
			*p = int16(read16(r))
		}
	}
}

func (obj *PointedAO) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
}

func (obj *PointedAO) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
}

func (obj *CompressionModes) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *CompressionModes) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *PlayerPos) serialize(w io.Writer) {
	for local277 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Pos100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Pos100)[local277]
			write32(w, uint32(x))
		}
	}
	for local278 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Vel100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Vel100)[local278]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Pitch100
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Yaw100
		write32(w, uint32(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Keys).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Keys", err))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).FOV80
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).WantedRange
		write8(w, uint8(x))
	}
}

func (obj *PlayerPos) deserialize(r io.Reader) {
	for local279 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Pos100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Pos100)[local279]
			*p = int32(read32(r))
		}
	}
	for local280 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Vel100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Vel100)[local280]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Pitch100
		*p = int32(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Yaw100
		*p = int32(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Keys).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Keys", err))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).FOV80
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).WantedRange
		*p = read8(r)
	}
}

func (obj *Interaction) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Interaction) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *SoundID) serialize(w io.Writer) {
	{
		x := *(*(int32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *SoundID) deserialize(r io.Reader) {
	{
		p := &*(*(int32))(obj)
		*p = int32(read32(r))
	}
}

func (obj *Field) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))[:])
		chk(err)
	}
}

func (obj *Field) deserialize(r io.Reader) {
	var local281 []uint8
	var local282 uint16
	{
		p := &local282
		*p = read16(r)
	}
	(local281) = make([]uint8, local282)
	{
		_, err := io.ReadFull(r, (local281)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name) = string(local281)
	var local283 []uint8
	var local284 uint32
	{
		p := &local284
		*p = read32(r)
	}
	(local283) = make([]uint8, local284)
	{
		_, err := io.ReadFull(r, (local283)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value) = string(local283)
}

func (obj *AuthMethods) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *AuthMethods) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *Pos) serialize(w io.Writer) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *Pos) deserialize(r io.Reader) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *KickReason) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *KickReason) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *MapBlk) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LitFromBlks", err))
	}
	{
		local285 := uint8(2) // Size of param0 in bytes.
		{
			x := local285
			write8(w, uint8(x))
		}
	}
	{
		local286 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			x := local286
			write8(w, uint8(x))
		}
	}
	for local287 := range (*(*(struct {
		Flags   MapBlkFlags
		LitFrom LitFromBlks

		Param0 [4096]Content
		Param1 [4096]uint8
		Param2 [4096]uint8

		NodeMetas map[uint16]*NodeMeta
	}))(obj)).Param0 {
		if err := pcall(func() {
			(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param0)[local287]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
		}
	}
	{
		_, err := w.Write(((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param1)[:])
		chk(err)
	}
	{
		_, err := w.Write(((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param2)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			if x == nil {
				write8(w, 0)
			} else {
				write8(w, 2)
				// len(map[uint16]...) always < math.MaxUint16
				write16(w, uint16(len(x)))
				keys := make([]uint16, 0, len(x))
				for key := range x {
					keys = append(keys, key)
				}
				sort.Slice(keys, func(i, j int) bool {
					i2pos := func(i int) [3]int16 {
						return Blkpos2Pos([3]int16{}, keys[i])
					}
					p, q := i2pos(i), i2pos(j)
					for i := range p {
						switch {
						case p[i] < q[i]:
							return true
						case p[i] > q[i]:
							return false
						}
					}
					return false
				})
				for _, key := range keys {
					write16(w, key)
					chk(serialize(w, x[key]))
				}
			}
		}
	}
}

func (obj *MapBlk) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LitFromBlks", err))
	}
	{
		var local288 uint8
		local289 := uint8(2) // Size of param0 in bytes.
		{
			p := &local288
			*p = read8(r)
		}
		if local288 != local289 {
			chk(fmt.Errorf("const %v: %v", "uint8(2)     // Size of param0 in bytes.", local288))
		}
	}
	{
		var local290 uint8
		local291 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			p := &local290
			*p = read8(r)
		}
		if local290 != local291 {
			chk(fmt.Errorf("const %v: %v", "uint8(1 + 1) // Size of param1 and param2 combined, in bytes.", local290))
		}
	}
	for local292 := range (*(*(struct {
		Flags   MapBlkFlags
		LitFrom LitFromBlks

		Param0 [4096]Content
		Param1 [4096]uint8
		Param2 [4096]uint8

		NodeMetas map[uint16]*NodeMeta
	}))(obj)).Param0 {
		if err := pcall(func() {
			(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param0)[local292]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
		}
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param1)[:])
		chk(err)
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param2)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			switch ver := read8(r); ver {
			case 0:
				*p = nil
			case 2:
				n := read16(r)
				*p = make(map[uint16]*NodeMeta, n)
				for ; n > 0; n-- {
					pos := read16(r)
					nm := new(NodeMeta)
					chk(deserialize(r, nm))
					(*p)[pos] = nm
				}
			default:
				chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
			}
		}
	}
}

func (obj *Node) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		write8(w, uint8(x))
	}
}

func (obj *Node) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		*p = read8(r)
	}
}

func (obj *CSMRestrictionFlags) serialize(w io.Writer) {
	{
		x := *(*(uint64))(obj)
		write64(w, uint64(x))
	}
}

func (obj *CSMRestrictionFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint64))(obj)
		*p = read64(r)
	}
}

func (obj *Vec) serialize(w io.Writer) {
	for local293 := range *(*([3]float32))(obj) {
		{
			x := (*(*([3]float32))(obj))[local293]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *Vec) deserialize(r io.Reader) {
	for local294 := range *(*([3]float32))(obj) {
		{
			p := &(*(*([3]float32))(obj))[local294]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ChatMsgType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ChatMsgType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOID) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *AOID) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AOAdd) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		local295 := genericCAO
		if err := pcall(func() {
			(local295).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		if err := pcall(func() {
			((*(*(struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}))(obj)).InitData).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOInitData", err))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *AOAdd) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var local296 aoType
		local297 := genericCAO
		if err := pcall(func() {
			(local296).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
		if local296 != local297 {
			chk(fmt.Errorf("const %v: %v", "genericCAO", local296))
		}
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		if err := pcall(func() {
			((*(*(struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}))(obj)).InitData).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOInitData", err))
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *IDAOMsg) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			writeAOMsg(w, x)
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *IDAOMsg) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			{
				var err error
				*p, err = readAOMsg(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ItemDef) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local298 := uint8(6)
			{
				x := local298
				write8(w, uint8(x))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemType", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Desc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Desc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Desc))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).InvImg).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).WieldImg).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		for local299 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).WieldScale {
			{
				x := ((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8
				}))(obj)).WieldScale)[local299]
				write32(w, math.Float32bits(x))
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).StackMax
			write16(w, uint16(x))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Usable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).CanPointLiquids
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).ToolCaps).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolCaps", err))
		}
		if len(((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local300 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8
				}))(obj)).Groups)[local300]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).PlacePredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlacePredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlacePredict))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceFailSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PointRange
			write32(w, math.Float32bits(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Palette).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).InvOverlay).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).WieldOverlay).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).ShortDesc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).ShortDesc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).ShortDesc))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceParam2
			write8(w, uint8(x))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ItemDef) deserialize(r io.Reader) {
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			var local301 uint8
			local302 := uint8(6)
			{
				p := &local301
				*p = read8(r)
			}
			if local301 != local302 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local301))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemType", err))
		}
		var local303 []uint8
		var local304 uint16
		{
			p := &local304
			*p = read16(r)
		}
		(local303) = make([]uint8, local304)
		{
			_, err := io.ReadFull(r, (local303)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Name) = string(local303)
		var local305 []uint8
		var local306 uint16
		{
			p := &local306
			*p = read16(r)
		}
		(local305) = make([]uint8, local306)
		{
			_, err := io.ReadFull(r, (local305)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Desc) = string(local305)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).InvImg).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).WieldImg).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		for local307 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).WieldScale {
			{
				p := &((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8
				}))(obj)).WieldScale)[local307]
				*p = math.Float32frombits(read32(r))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).StackMax
			*p = read16(r)
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Usable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).CanPointLiquids
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).ToolCaps).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolCaps", err))
		}
		var local308 uint16
		{
			p := &local308
			*p = read16(r)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Groups) = make([]Group, local308)
		for local309 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8
				}))(obj)).Groups)[local309]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		var local310 []uint8
		var local311 uint16
		{
			p := &local311
			*p = read16(r)
		}
		(local310) = make([]uint8, local311)
		{
			_, err := io.ReadFull(r, (local310)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).PlacePredict) = string(local310)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceFailSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PointRange
			*p = math.Float32frombits(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Palette).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).InvOverlay).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).WieldOverlay).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		var local312 []uint8
		var local313 uint16
		{
			p := &local313
			*p = read16(r)
		}
		(local312) = make([]uint8, local313)
		{
			_, err := io.ReadFull(r, (local312)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8
		}))(obj)).ShortDesc) = string(local312)
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8
			}))(obj)).PlaceParam2
			*p = read8(r)
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *SoundSrcType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *SoundSrcType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileAnim) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := w.Write(((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local314 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				x := ((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local314]
				write16(w, uint16(x))
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			x := (*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TileAnim) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := io.ReadFull(r, ((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local315 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				p := &((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local315]
				*p = read16(r)
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			p := &(*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *Content) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *Content) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *ParticleSpawnerID) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *ParticleSpawnerID) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUDID) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDID) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDType", err))
	}
	for local316 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Pos)[local316]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Name))[:])
		chk(err)
	}
	for local317 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Scale {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Scale)[local317]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Number
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Item
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Dir
		write32(w, uint32(x))
	}
	for local318 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Align {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Align)[local318]
			write32(w, math.Float32bits(x))
		}
	}
	for local319 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Offset {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Offset)[local319]
			write32(w, math.Float32bits(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).WorldPos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local320 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Size)[local320]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).ZIndex
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text2))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text2))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text2))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Style).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
	}
}

func (obj *HUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDType", err))
	}
	for local321 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Pos)[local321]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local322 []uint8
	var local323 uint16
	{
		p := &local323
		*p = read16(r)
	}
	(local322) = make([]uint8, local323)
	{
		_, err := io.ReadFull(r, (local322)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Name) = string(local322)
	for local324 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Scale {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Scale)[local324]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local325 []uint8
	var local326 uint16
	{
		p := &local326
		*p = read16(r)
	}
	(local325) = make([]uint8, local326)
	{
		_, err := io.ReadFull(r, (local325)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text) = string(local325)
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Number
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Item
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Dir
		*p = read32(r)
	}
	for local327 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Align {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Align)[local327]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local328 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Offset {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Offset)[local328]
			*p = math.Float32frombits(read32(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).WorldPos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local329 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Size)[local329]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).ZIndex
		*p = int16(read16(r))
	}
	var local330 []uint8
	var local331 uint16
	{
		p := &local331
		*p = read16(r)
	}
	(local330) = make([]uint8, local331)
	{
		_, err := io.ReadFull(r, (local330)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text2) = string(local330)
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Style).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
	}
}

func (obj *HUDField) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDField) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDStyleFlags) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDStyleFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUDFlags) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HotbarParam) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *HotbarParam) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Texture) serialize(w io.Writer) {
	if len(([]byte(*(*(string))(obj)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte(*(*(string))(obj)))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte(*(*(string))(obj)))[:])
		chk(err)
	}
}

func (obj *Texture) deserialize(r io.Reader) {
	var local332 []uint8
	var local333 uint16
	{
		p := &local333
		*p = read16(r)
	}
	(local332) = make([]uint8, local333)
	{
		_, err := io.ReadFull(r, (local332)[:])
		chk(err)
	}
	(*(*(string))(obj)) = string(local332)
}

func (obj *PlayerListUpdateType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *PlayerListUpdateType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ModChanSig) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ModChanSig) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOProps) serialize(w io.Writer) {
	{
		local334 := uint8(4)
		{
			x := local334
			write8(w, uint8(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxHP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithNodes
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Weight
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ColBox).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).SelBox).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Pointable
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Visual))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visual))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visual))[:])
		chk(err)
	}
	for local335 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).VisualSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).VisualSize)[local335]
			write32(w, math.Float32bits(x))
		}
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Textures)))
		write16(w, uint16(x))
	}
	for local336 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Textures)[local336]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
	for local337 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpriteSheetSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpriteSheetSize)[local337]
			write16(w, uint16(x))
		}
	}
	for local338 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpritePos {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpritePos)[local338]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MakeFootstepSnds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).RotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Mesh))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Mesh))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Mesh))[:])
		chk(err)
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Colors)))
		write16(w, uint16(x))
	}
	for local339 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Colors)[local339]
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithAOs
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).StepHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDir
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDirOff
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).BackfaceCull
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Nametag))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Nametag))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Nametag))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Infotext))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Infotext))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Infotext))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Itemstring))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Itemstring))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Itemstring))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxBreath
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).EyeHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ZoomFOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).UseTextureAlpha
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).DmgTextureMod).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Shaded
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ShowOnMinimap
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagBG
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
}

func (obj *AOProps) deserialize(r io.Reader) {
	{
		var local340 uint8
		local341 := uint8(4)
		{
			p := &local340
			*p = read8(r)
		}
		if local340 != local341 {
			chk(fmt.Errorf("const %v: %v", "uint8(4)", local340))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxHP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithNodes
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Weight
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ColBox).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).SelBox).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Pointable
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local342 []uint8
	var local343 uint16
	{
		p := &local343
		*p = read16(r)
	}
	(local342) = make([]uint8, local343)
	{
		_, err := io.ReadFull(r, (local342)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Visual) = string(local342)
	for local344 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).VisualSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).VisualSize)[local344]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local345 uint16
	{
		p := &local345
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures) = make([]Texture, local345)
	for local346 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Textures)[local346]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
	for local347 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpriteSheetSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpriteSheetSize)[local347]
			*p = int16(read16(r))
		}
	}
	for local348 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).SpritePos {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).SpritePos)[local348]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MakeFootstepSnds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).RotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local349 []uint8
	var local350 uint16
	{
		p := &local350
		*p = read16(r)
	}
	(local349) = make([]uint8, local350)
	{
		_, err := io.ReadFull(r, (local349)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Mesh) = string(local349)
	var local351 uint16
	{
		p := &local351
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors) = make([]color.NRGBA, local351)
	for local352 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Colors {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
			}))(obj)).Colors)[local352]
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).CollideWithAOs
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).StepHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDir
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateDirOff
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).BackfaceCull
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local353 []uint8
	var local354 uint16
	{
		p := &local354
		*p = read16(r)
	}
	(local353) = make([]uint8, local354)
	{
		_, err := io.ReadFull(r, (local353)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Nametag) = string(local353)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).FaceRotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local355 []uint8
	var local356 uint16
	{
		p := &local356
		*p = read16(r)
	}
	(local355) = make([]uint8, local356)
	{
		_, err := io.ReadFull(r, (local355)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Infotext) = string(local355)
	var local357 []uint8
	var local358 uint16
	{
		p := &local358
		*p = read16(r)
	}
	(local357) = make([]uint8, local358)
	{
		_, err := io.ReadFull(r, (local357)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
	}))(obj)).Itemstring) = string(local357)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Glow
		*p = int8(read8(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).MaxBreath
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).EyeHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ZoomFOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).UseTextureAlpha
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).DmgTextureMod).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).Shaded
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).ShowOnMinimap
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
		}))(obj)).NametagBG
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
}

func (obj *AOPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local359 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local359]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local360 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local360]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AOSprite) serialize(w io.Writer) {
	for local361 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			x := ((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local361]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOSprite) deserialize(r io.Reader) {
	for local362 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			p := &((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local362]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *Group) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		write16(w, uint16(x))
	}
}

func (obj *Group) deserialize(r io.Reader) {
	var local363 []uint8
	var local364 uint16
	{
		p := &local364
		*p = read16(r)
	}
	(local363) = make([]uint8, local364)
	{
		_, err := io.ReadFull(r, (local363)[:])
		chk(err)
	}
	((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name) = string(local363)
	{
		p := &(*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		*p = int16(read16(r))
	}
}

func (obj *AOAnim) serialize(w io.Writer) {
	for local365 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			x := ((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local365]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAnim) deserialize(r io.Reader) {
	for local366 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			p := &((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local366]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOBonePos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos Vec
			Rot [3]float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local367 := range (*(*(struct {
		Pos Vec
		Rot [3]float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos Vec
				Rot [3]float32
			}))(obj)).Rot)[local367]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *AOBonePos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos Vec
			Rot [3]float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local368 := range (*(*(struct {
		Pos Vec
		Rot [3]float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos Vec
				Rot [3]float32
			}))(obj)).Rot)[local368]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *AOAttach) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if len(([]byte((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local369 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local369]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAttach) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	var local370 []uint8
	var local371 uint16
	{
		p := &local371
		*p = read16(r)
	}
	(local370) = make([]uint8, local371)
	{
		_, err := io.ReadFull(r, (local370)[:])
		chk(err)
	}
	((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone) = string(local370)
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local372 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local372]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOPhysOverride) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Walk
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Jump
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneakGlitch
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).OldSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOPhysOverride) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Walk
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Jump
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneakGlitch
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).OldSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *aoType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *aoType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeMetaField) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
	}
	{
		x := (*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *NodeMetaField) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
	}
	{
		p := &(*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *MinimapType) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *MinimapType) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Param1Type) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param1Type) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Param2Type) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param2Type) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DrawType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *DrawType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileDef) serialize(w io.Writer) {
	{
		local373 := uint8(6)
		{
			x := local373
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlignType", err))
		}
	}
}

func (obj *TileDef) deserialize(r io.Reader) {
	{
		var local374 uint8
		local375 := uint8(6)
		{
			p := &local374
			*p = read8(r)
		}
		if local374 != local375 {
			chk(fmt.Errorf("const %v: %v", "uint8(6)", local374))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlignType", err))
		}
	}
}

func (obj *WaveType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *WaveType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LiquidType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *LiquidType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBox) serialize(w io.Writer) {
	{
		local376 := uint8(6)
		{
			x := local376
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).Fixed)))
			write16(w, uint16(x))
		}
		for local377 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local377]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoAll)))
			write16(w, uint16(x))
		}
		for local378 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local378]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoSides)))
			write16(w, uint16(x))
		}
		for local379 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local379]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
}

func (obj *NodeBox) deserialize(r io.Reader) {
	{
		var local380 uint8
		local381 := uint8(6)
		{
			p := &local380
			*p = read8(r)
		}
		if local380 != local381 {
			chk(fmt.Errorf("const %v: %v", "uint8(6)", local380))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		var local382 uint16
		{
			p := &local382
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed) = make([]Box, local382)
		for local383 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local383]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		var local384 uint16
		{
			p := &local384
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll) = make([]Box, local384)
		for local385 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local385]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
		var local386 uint16
		{
			p := &local386
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides) = make([]Box, local386)
		for local387 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local387]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
}

func (obj *SoundDef) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
}

func (obj *SoundDef) deserialize(r io.Reader) {
	var local388 []uint8
	var local389 uint16
	{
		p := &local389
		*p = read16(r)
	}
	(local388) = make([]uint8, local389)
	{
		_, err := io.ReadFull(r, (local388)[:])
		chk(err)
	}
	((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name) = string(local388)
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AlphaUse) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlphaUse) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Keys) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *Keys) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *MapBlkFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *MapBlkFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LitFromBlks) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *LitFromBlks) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AOInitData) serialize(w io.Writer) {
	{
		local390 := uint8(1)
		{
			x := local390
			write8(w, uint8(x))
		}
	}
	if len(([]byte((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local391 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			x := ((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local391]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			if len(x) > math.MaxUint8 {
				chk(ErrTooLong)
			}
			write8(w, uint8(len(x)))
			for _, msg := range x {
				var b bytes.Buffer
				chk(writeAOMsg(&b, msg))
				if b.Len() > math.MaxUint32 {
					chk(ErrTooLong)
				}
				write32(w, uint32(b.Len()))
				_, err := b.WriteTo(w)
				chk(err)
			}
		}
	}
}

func (obj *AOInitData) deserialize(r io.Reader) {
	{
		var local392 uint8
		local393 := uint8(1)
		{
			p := &local392
			*p = read8(r)
		}
		if local392 != local393 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local392))
		}
	}
	var local394 []uint8
	var local395 uint16
	{
		p := &local395
		*p = read16(r)
	}
	(local394) = make([]uint8, local395)
	{
		_, err := io.ReadFull(r, (local394)[:])
		chk(err)
	}
	((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name) = string(local394)
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local396 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			p := &((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local396]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			*p = make([]AOMsg, read8(r))
			for i := range *p {
				r := &io.LimitedReader{R: r, N: int64(read32(r))}
				msg, err := readAOMsg(r)
				chk(err)
				(*p)[i] = msg
				if r.N > 0 {
					chk(fmt.Errorf("%d bytes of trailing data", r.N))
				}
			}
		}
	}
}

func (obj *ItemType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ItemType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ToolCaps) serialize(w io.Writer) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCap

		//mt:len32
		DmgGroups []Group

		//mt:32tou16
		PunchUses int32
	}))(obj)); false {
		{
			x := (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		/*
			if r.N > 0 { (*(*(struct {
				//mt:if _ = %s; false
				NonNil	bool

				AttackCooldown	float32
				MaxDropLvl	int16

				//mt:len32
				GroupCaps	[]ToolGroupCap

				//mt:len32
				DmgGroups	[]Group

				//mt:32tou16
				PunchUses	int32
			}))(obj)).NonNil = true}; /*
		*/{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil {
				{
					local397 := uint8(5)
					{
						x := local397
						write8(w, uint8(x))
					}
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).AttackCooldown
					write32(w, math.Float32bits(x))
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).MaxDropLvl
					write16(w, uint16(x))
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).GroupCaps)))
					write32(w, uint32(x))
				}
				for local398 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).GroupCaps)[local398]).serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolGroupCap", err))
					}
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).DmgGroups)))
					write32(w, uint32(x))
				}
				for local399 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).DmgGroups)[local399]).serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
					}
				}
				{
					x := uint16((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).PunchUses)
					write16(w, uint16(x))
				}
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToolCaps) deserialize(r io.Reader) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCap

		//mt:len32
		DmgGroups []Group

		//mt:32tou16
		PunchUses int32
	}))(obj)); false {
		{
			p := &(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		if r.N > 0 {
			(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil = true
		} /**/
		{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil {
				{
					var local400 uint8
					local401 := uint8(5)
					{
						p := &local400
						*p = read8(r)
					}
					if local400 != local401 {
						chk(fmt.Errorf("const %v: %v", "uint8(5)", local400))
					}
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).AttackCooldown
					*p = math.Float32frombits(read32(r))
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).MaxDropLvl
					*p = int16(read16(r))
				}
				var local402 uint32
				{
					p := &local402
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps) = make([]ToolGroupCap, local402)
				for local403 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).GroupCaps)[local403]).deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolGroupCap", err))
					}
				}
				var local404 uint32
				{
					p := &local404
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups) = make([]Group, local404)
				for local405 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).DmgGroups)[local405]).deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
					}
				}
				var local406 uint16
				{
					p := &local406
					*p = read16(r)
				}
				(*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).PunchUses = int32(local406)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *AnimType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AnimType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Box) serialize(w io.Writer) {
	for local407 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local407]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
		}
	}
}

func (obj *Box) deserialize(r io.Reader) {
	for local408 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local408]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
		}
	}
}

func (obj *TileFlags) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *TileFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AlignType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlignType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBoxType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *NodeBoxType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DirBoxes) serialize(w io.Writer) {
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Top)))
		write16(w, uint16(x))
	}
	for local409 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local409]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Bot)))
		write16(w, uint16(x))
	}
	for local410 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local410]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Front)))
		write16(w, uint16(x))
	}
	for local411 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local411]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Left)))
		write16(w, uint16(x))
	}
	for local412 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local412]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Back)))
		write16(w, uint16(x))
	}
	for local413 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local413]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Right)))
		write16(w, uint16(x))
	}
	for local414 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local414]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
}

func (obj *DirBoxes) deserialize(r io.Reader) {
	var local415 uint16
	{
		p := &local415
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top) = make([]Box, local415)
	for local416 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local416]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local417 uint16
	{
		p := &local417
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot) = make([]Box, local417)
	for local418 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local418]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local419 uint16
	{
		p := &local419
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front) = make([]Box, local419)
	for local420 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local420]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local421 uint16
	{
		p := &local421
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left) = make([]Box, local421)
	for local422 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local422]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local423 uint16
	{
		p := &local423
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back) = make([]Box, local423)
	for local424 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local424]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local425 uint16
	{
		p := &local425
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right) = make([]Box, local425)
	for local426 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local426]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
}

func (obj *ToolGroupCap) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := int16((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Uses)
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Times)))
		write32(w, uint32(x))
	}
	for local427 := range (*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name string

				//mt:32to16
				Uses int32

				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local427]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DigTime", err))
		}
	}
}

func (obj *ToolGroupCap) deserialize(r io.Reader) {
	var local428 []uint8
	var local429 uint16
	{
		p := &local429
		*p = read16(r)
	}
	(local428) = make([]uint8, local429)
	{
		_, err := io.ReadFull(r, (local428)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name) = string(local428)
	var local430 int16
	{
		p := &local430
		*p = int16(read16(r))
	}
	(*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Uses = int32(local430)
	{
		p := &(*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		*p = int16(read16(r))
	}
	var local431 uint32
	{
		p := &local431
		*p = read32(r)
	}
	((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times) = make([]DigTime, local431)
	for local432 := range (*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name string

				//mt:32to16
				Uses int32

				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local432]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DigTime", err))
		}
	}
}

func (obj *DigTime) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		write32(w, math.Float32bits(x))
	}
}

func (obj *DigTime) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		*p = int16(read16(r))
	}
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		*p = math.Float32frombits(read32(r))
	}
}

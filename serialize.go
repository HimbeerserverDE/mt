// Code generated by mkserialize.sh; DO NOT EDIT.

package mt

import (
	"bytes"
	"compress/zlib"
	"crypto/sha1"
	"errors"
	"fmt"
	"image/color"
	"io"
	"math"
	"sort"
	"unicode/utf16"

	"github.com/klauspost/compress/zstd"
)

func write8(w io.Writer, x uint8) {
	_, err := w.Write([]byte{x})
	chk(err)
}

func write16(w io.Writer, x uint16) {
	buf := make([]byte, 2)
	be.PutUint16(buf, x)
	_, err := w.Write(buf)
	chk(err)
}

func write32(w io.Writer, x uint32) {
	buf := make([]byte, 4)
	be.PutUint32(buf, x)
	_, err := w.Write(buf)
	chk(err)
}

func write64(w io.Writer, x uint64) {
	buf := make([]byte, 8)
	be.PutUint64(buf, x)
	_, err := w.Write(buf)
	chk(err)
}
func readBuf(r io.Reader, n int) []byte {
	buf := make([]byte, n)
	_, err := io.ReadFull(r, buf)
	chk(err)
	return buf
}

func read8(r io.Reader) uint8   { return readBuf(r, 1)[0] }
func read16(r io.Reader) uint16 { return be.Uint16(readBuf(r, 2)) }
func read32(r io.Reader) uint32 { return be.Uint32(readBuf(r, 4)) }
func read64(r io.Reader) uint64 { return be.Uint64(readBuf(r, 8)) }

func (obj *ToSrvNil) serialize(w io.Writer) {
}

func (obj *ToSrvNil) deserialize(r io.Reader) {
}

func (obj *ToSrvInit) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))[:])
		chk(err)
	}
	if err := pcall(func() {
		{
			x := (*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		*p = read16(r)
	}
	var local1 []uint8
	var local2 uint16
	{
		p := &local2
		*p = read16(r)
	}
	(local1) = make([]uint8, local2)
	{
		_, err := io.ReadFull(r, (local1)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName) = string(local1)
	if err := pcall(func() {
		{
			p := &(*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit2) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Lang string
	}))(obj)).Lang))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))[:])
		chk(err)
	}
}

func (obj *ToSrvInit2) deserialize(r io.Reader) {
	var local3 []uint8
	var local4 uint16
	{
		p := &local4
		*p = read16(r)
	}
	(local3) = make([]uint8, local4)
	{
		_, err := io.ReadFull(r, (local3)[:])
		chk(err)
	}
	((*(*(struct {
		Lang string
	}))(obj)).Lang) = string(local3)
}

func (obj *ToSrvJoinModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvJoinModChan) deserialize(r io.Reader) {
	var local5 []uint8
	var local6 uint16
	{
		p := &local6
		*p = read16(r)
	}
	(local5) = make([]uint8, local6)
	{
		_, err := io.ReadFull(r, (local5)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local5)
}

func (obj *ToSrvLeaveModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvLeaveModChan) deserialize(r io.Reader) {
	var local7 []uint8
	var local8 uint16
	{
		p := &local8
		*p = read16(r)
	}
	(local7) = make([]uint8, local8)
	{
		_, err := io.ReadFull(r, (local7)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local7)
}

func (obj *ToSrvMsgModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToSrvMsgModChan) deserialize(r io.Reader) {
	var local9 []uint8
	var local10 uint16
	{
		p := &local10
		*p = read16(r)
	}
	(local9) = make([]uint8, local10)
	{
		_, err := io.ReadFull(r, (local9)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel) = string(local9)
	var local11 []uint8
	var local12 uint16
	{
		p := &local12
		*p = read16(r)
	}
	(local11) = make([]uint8, local12)
	{
		_, err := io.ReadFull(r, (local11)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg) = string(local11)
}

func (obj *ToSrvPlayerPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvPlayerPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvGotBlks) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local13 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local14 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local13] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local13])[local14]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvGotBlks) deserialize(r io.Reader) {
	var local15 uint8
	{
		p := &local15
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local15)
	for local16 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local17 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local16] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local16])[local17]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local18 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local19 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local18] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local18])[local19]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) deserialize(r io.Reader) {
	var local20 uint8
	{
		p := &local20
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local20)
	for local21 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local22 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local21] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local21])[local22]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvInvAction) serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Action string
		}))(obj)).Action))[:])
		chk(err)
	}
}

func (obj *ToSrvInvAction) deserialize(r io.Reader) {
	var local23 []uint8
	{
		var err error
		(local23), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Action string
	}))(obj)).Action) = string(local23)
}

func (obj *ToSrvChatMsg) serialize(w io.Writer) {
	local24 := utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg))
	if len((local24)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local24)))
		write16(w, uint16(x))
	}
	for local25 := range local24 {
		{
			x := (local24)[local25]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToSrvChatMsg) deserialize(r io.Reader) {
	var local26 []uint16
	var local27 uint16
	{
		p := &local27
		*p = read16(r)
	}
	(local26) = make([]uint16, local27)
	for local28 := range local26 {
		{
			p := &(local26)[local28]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg = string(utf16.Decode(local26))
}

func (obj *ToSrvFallDmg) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount uint16
		}))(obj)).Amount
		write16(w, uint16(x))
	}
}

func (obj *ToSrvFallDmg) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount uint16
		}))(obj)).Amount
		*p = read16(r)
	}
}

func (obj *ToSrvSelectItem) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Slot uint16
		}))(obj)).Slot
		write16(w, uint16(x))
	}
}

func (obj *ToSrvSelectItem) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Slot uint16
		}))(obj)).Slot
		*p = read16(r)
	}
}

func (obj *ToSrvRespawn) serialize(w io.Writer) {
}

func (obj *ToSrvRespawn) deserialize(r io.Reader) {
}

func (obj *ToSrvInteract) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Interaction", err))
	}
	{
		x := (*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		write16(w, uint16(x))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			chk(writePointedThing(w, x))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvInteract) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Interaction", err))
	}
	{
		p := &(*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		*p = read16(r)
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			{
				var err error
				*p, err = readPointedThing(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvRemovedSounds) serialize(w io.Writer) {
	if len(((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			IDs []SoundID
		}))(obj)).IDs)))
		write16(w, uint16(x))
	}
	for local29 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local29]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvRemovedSounds) deserialize(r io.Reader) {
	var local30 uint16
	{
		p := &local30
		*p = read16(r)
	}
	((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs) = make([]SoundID, local30)
	for local31 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local31]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) serialize(w io.Writer) {
	for local32 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local32]
			write16(w, uint16(x))
		}
	}
	if len(([]byte((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local33 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local33]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) deserialize(r io.Reader) {
	for local34 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local34]
			*p = int16(read16(r))
		}
	}
	var local35 []uint8
	var local36 uint16
	{
		p := &local36
		*p = read16(r)
	}
	(local35) = make([]uint8, local36)
	{
		_, err := io.ReadFull(r, (local35)[:])
		chk(err)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local35)
	var local37 uint16
	{
		p := &local37
		*p = read16(r)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local37)
	for local38 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local38]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local39 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local39]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) deserialize(r io.Reader) {
	var local40 []uint8
	var local41 uint16
	{
		p := &local41
		*p = read16(r)
	}
	(local40) = make([]uint8, local41)
	{
		_, err := io.ReadFull(r, (local40)[:])
		chk(err)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local40)
	var local42 uint16
	{
		p := &local42
		*p = read16(r)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local42)
	for local43 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local43]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvReqMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		Filenames []string
	}))(obj)).Filenames)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)))
		write16(w, uint16(x))
	}
	for local44 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		if len(([]byte(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local44]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))[:])
			chk(err)
		}
	}
}

func (obj *ToSrvReqMedia) deserialize(r io.Reader) {
	var local45 uint16
	{
		p := &local45
		*p = read16(r)
	}
	((*(*(struct {
		Filenames []string
	}))(obj)).Filenames) = make([]string, local45)
	for local46 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		var local47 []uint8
		var local48 uint16
		{
			p := &local48
			*p = read16(r)
		}
		(local47) = make([]uint8, local48)
		{
			_, err := io.ReadFull(r, (local47)[:])
			chk(err)
		}
		(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local46]) = string(local47)
	}
}

func (obj *ToSrvHaveMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Tokens []uint32
		}))(obj)).Tokens)))
		write8(w, uint8(x))
	}
	for local49 := range (*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens {
		{
			x := ((*(*(struct {
				//mt:len8
				Tokens []uint32
			}))(obj)).Tokens)[local49]
			write32(w, uint32(x))
		}
	}
}

func (obj *ToSrvHaveMedia) deserialize(r io.Reader) {
	var local50 uint8
	{
		p := &local50
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens) = make([]uint32, local50)
	for local51 := range (*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens {
		{
			p := &((*(*(struct {
				//mt:len8
				Tokens []uint32
			}))(obj)).Tokens)[local51]
			*p = read32(r)
		}
	}
}

func (obj *ToSrvCltReady) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		write8(w, uint8(x))
	}
	if len(([]byte((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		write16(w, uint16(x))
	}
}

func (obj *ToSrvCltReady) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		*p = read8(r)
	}
	var local52 []uint8
	var local53 uint16
	{
		p := &local53
		*p = read16(r)
	}
	(local52) = make([]uint8, local53)
	{
		_, err := io.ReadFull(r, (local52)[:])
		chk(err)
	}
	((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version) = string(local52)
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		*p = read16(r)
	}
}

func (obj *ToSrvFirstSRP) serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvFirstSRP) deserialize(r io.Reader) {
	var local54 uint16
	{
		p := &local54
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt) = make([]byte, local54)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local55 uint16
	{
		p := &local55
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier) = make([]byte, local55)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesA) serialize(w io.Writer) {
	if len(((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvSRPBytesA) deserialize(r io.Reader) {
	var local56 uint16
	{
		p := &local56
		*p = read16(r)
	}
	((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A) = make([]byte, local56)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesM) serialize(w io.Writer) {
	if len(((*(*(struct {
		M []byte
	}))(obj)).M)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			M []byte
		}))(obj)).M)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToSrvSRPBytesM) deserialize(r io.Reader) {
	var local57 uint16
	{
		p := &local57
		*p = read16(r)
	}
	((*(*(struct {
		M []byte
	}))(obj)).M) = make([]byte, local57)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToSrvCltInfo) serialize(w io.Writer) {
	for local58 := range (*(*(struct {
		RenderTargetSize [2]uint32
		GUIScaling       float32
		HUDScaling       float32
		MaxFormspecInfo  [2]float32
	}))(obj)).RenderTargetSize {
		{
			x := ((*(*(struct {
				RenderTargetSize [2]uint32
				GUIScaling       float32
				HUDScaling       float32
				MaxFormspecInfo  [2]float32
			}))(obj)).RenderTargetSize)[local58]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
		}))(obj)).GUIScaling
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
		}))(obj)).HUDScaling
		write32(w, math.Float32bits(x))
	}
	for local59 := range (*(*(struct {
		RenderTargetSize [2]uint32
		GUIScaling       float32
		HUDScaling       float32
		MaxFormspecInfo  [2]float32
	}))(obj)).MaxFormspecInfo {
		{
			x := ((*(*(struct {
				RenderTargetSize [2]uint32
				GUIScaling       float32
				HUDScaling       float32
				MaxFormspecInfo  [2]float32
			}))(obj)).MaxFormspecInfo)[local59]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *ToSrvCltInfo) deserialize(r io.Reader) {
	for local60 := range (*(*(struct {
		RenderTargetSize [2]uint32
		GUIScaling       float32
		HUDScaling       float32
		MaxFormspecInfo  [2]float32
	}))(obj)).RenderTargetSize {
		{
			p := &((*(*(struct {
				RenderTargetSize [2]uint32
				GUIScaling       float32
				HUDScaling       float32
				MaxFormspecInfo  [2]float32
			}))(obj)).RenderTargetSize)[local60]
			*p = read32(r)
		}
	}
	{
		p := &(*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
		}))(obj)).GUIScaling
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
		}))(obj)).HUDScaling
		*p = math.Float32frombits(read32(r))
	}
	for local61 := range (*(*(struct {
		RenderTargetSize [2]uint32
		GUIScaling       float32
		HUDScaling       float32
		MaxFormspecInfo  [2]float32
	}))(obj)).MaxFormspecInfo {
		{
			p := &((*(*(struct {
				RenderTargetSize [2]uint32
				GUIScaling       float32
				HUDScaling       float32
				MaxFormspecInfo  [2]float32
			}))(obj)).MaxFormspecInfo)[local61]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ToCltHello) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	if len(([]byte((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))[:])
		chk(err)
	}
}

func (obj *ToCltHello) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	var local62 []uint8
	var local63 uint16
	{
		p := &local63
		*p = read16(r)
	}
	(local62) = make([]uint8, local63)
	{
		_, err := io.ReadFull(r, (local62)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username) = string(local62)
}

func (obj *ToCltAcceptAuth) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		write64(w, uint64(x))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptAuth) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		*p = read64(r)
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptSudoMode) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	{
		local64 := [15]byte{}
		{
			_, err := w.Write((local64)[:])
			chk(err)
		}
	}
}

func (obj *ToCltAcceptSudoMode) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	{
		var local65 [15]byte
		local66 := [15]byte{}
		{
			_, err := io.ReadFull(r, (local65)[:])
			chk(err)
		}
		if local65 != local66 {
			chk(fmt.Errorf("const %v: %v", "[15]byte{}", local65))
		}
	}
}

func (obj *ToCltDenySudoMode) serialize(w io.Writer) {
}

func (obj *ToCltDenySudoMode) deserialize(r io.Reader) {
}

func (obj *ToCltKick) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Reason).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.KickReason", err))
	}
	if !((*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason < maxKickReason) {
		chk(errors.New("assertion failed: %s.Reason < maxKickReason"))
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Custom || dr == Shutdown || dr == Crash {
		if len(([]byte((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Custom))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Custom))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Custom))[:])
			chk(err)
		}
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Shutdown || dr == Crash {
		{
			x := (*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Reconnect
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
}

func (obj *ToCltKick) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Reason).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.KickReason", err))
	}
	if !((*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason < maxKickReason) {
		chk(errors.New("assertion failed: %s.Reason < maxKickReason"))
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Custom || dr == Shutdown || dr == Crash {
		var local67 []uint8
		var local68 uint16
		{
			p := &local68
			*p = read16(r)
		}
		(local67) = make([]uint8, local68)
		{
			_, err := io.ReadFull(r, (local67)[:])
			chk(err)
		}
		((*(*(struct {
			Reason KickReason

			//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
			Custom string

			//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
			Reconnect bool
		}))(obj)).Custom) = string(local67)
	}
	if dr := (*(*(struct {
		Reason KickReason

		//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
		Custom string

		//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
		Reconnect bool
	}))(obj)).Reason; dr == Shutdown || dr == Crash {
		{
			p := &(*(*(struct {
				Reason KickReason

				//mt:if dr := %s.Reason; dr == Custom || dr == Shutdown || dr == Crash
				Custom string

				//mt:if dr := %s.Reason; dr == Shutdown || dr == Crash
				Reconnect bool
			}))(obj)).Reconnect
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
}

func (obj *ToCltBlkData) serialize(w io.Writer) {
	for local69 := range (*(*(struct {
		Blkpos [3]int16
		//mt:zstd
		Blk MapBlk
	}))(obj)).Blkpos {
		{
			x := ((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blkpos)[local69]
			write16(w, uint16(x))
		}
	}
	{
		w, err := zstd.NewWriter(w)
		chk(err)
		if err := pcall(func() {
			((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blk).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlk", err))
		}
		chk(w.Close())
	}
}

func (obj *ToCltBlkData) deserialize(r io.Reader) {
	for local70 := range (*(*(struct {
		Blkpos [3]int16
		//mt:zstd
		Blk MapBlk
	}))(obj)).Blkpos {
		{
			p := &((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blkpos)[local70]
			*p = int16(read16(r))
		}
	}
	{
		r, err := zstd.NewReader(byteReader{r})
		chk(err)
		if err := pcall(func() {
			((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blk).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlk", err))
		}
		r.Close()
	}
}

func (obj *ToCltAddNode) serialize(w io.Writer) {
	for local71 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local71]
			write16(w, uint16(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Node", err))
	}
	{
		x := (*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltAddNode) deserialize(r io.Reader) {
	for local72 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local72]
			*p = int16(read16(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Node", err))
	}
	{
		p := &(*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltRemoveNode) serialize(w io.Writer) {
	for local73 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local73]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltRemoveNode) deserialize(r io.Reader) {
	for local74 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local74]
			*p = int16(read16(r))
		}
	}
}

func (obj *ToCltInv) serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltInv) deserialize(r io.Reader) {
	var local75 []uint8
	{
		var err error
		(local75), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local75)
}

func (obj *ToCltTimeOfDay) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltTimeOfDay) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltCSMRestrictionFlags) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CSMRestrictionFlags", err))
	}
	{
		x := (*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		write32(w, uint32(x))
	}
}

func (obj *ToCltCSMRestrictionFlags) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CSMRestrictionFlags", err))
	}
	{
		p := &(*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		*p = read32(r)
	}
}

func (obj *ToCltAddPlayerVel) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltAddPlayerVel) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltMediaPush) serialize(w io.Writer) {
	{
		local76 := uint16(sha1.Size)
		{
			x := local76
			write16(w, uint16(x))
		}
	}
	{
		_, err := w.Write(((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).SHA1)[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1          [sha1.Size]byte
		Filename      string
		CallbackToken uint32
		ShouldCache   bool
	}))(obj)).Filename))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).Filename))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).Filename))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).CallbackToken
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).ShouldCache
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltMediaPush) deserialize(r io.Reader) {
	{
		var local77 uint16
		local78 := uint16(sha1.Size)
		{
			p := &local77
			*p = read16(r)
		}
		if local77 != local78 {
			chk(fmt.Errorf("const %v: %v", "uint16(sha1.Size)", local77))
		}
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).SHA1)[:])
		chk(err)
	}
	var local79 []uint8
	var local80 uint16
	{
		p := &local80
		*p = read16(r)
	}
	(local79) = make([]uint8, local80)
	{
		_, err := io.ReadFull(r, (local79)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1          [sha1.Size]byte
		Filename      string
		CallbackToken uint32
		ShouldCache   bool
	}))(obj)).Filename) = string(local79)
	{
		p := &(*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).CallbackToken
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			CallbackToken uint32
			ShouldCache   bool
		}))(obj)).ShouldCache
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltChatMsg) serialize(w io.Writer) {
	{
		local81 := uint8(1)
		{
			x := local81
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ChatMsgType", err))
	}
	local82 := utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender))
	if len((local82)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local82)))
		write16(w, uint16(x))
	}
	for local83 := range local82 {
		{
			x := (local82)[local83]
			write16(w, uint16(x))
		}
	}
	local84 := utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text))
	if len((local84)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local84)))
		write16(w, uint16(x))
	}
	for local85 := range local84 {
		{
			x := (local84)[local85]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		write64(w, uint64(x))
	}
}

func (obj *ToCltChatMsg) deserialize(r io.Reader) {
	{
		var local86 uint8
		local87 := uint8(1)
		{
			p := &local86
			*p = read8(r)
		}
		if local86 != local87 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local86))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ChatMsgType", err))
	}
	var local88 []uint16
	var local89 uint16
	{
		p := &local89
		*p = read16(r)
	}
	(local88) = make([]uint16, local89)
	for local90 := range local88 {
		{
			p := &(local88)[local90]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender = string(utf16.Decode(local88))
	var local91 []uint16
	var local92 uint16
	{
		p := &local92
		*p = read16(r)
	}
	(local91) = make([]uint16, local92)
	for local93 := range local91 {
		{
			p := &(local91)[local93]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text = string(utf16.Decode(local91))
	{
		p := &(*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		*p = int64(read64(r))
	}
}

func (obj *ToCltAORmAdd) serialize(w io.Writer) {
	if len(((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []AOAdd
		}))(obj)).Remove)))
		write16(w, uint16(x))
	}
	for local94 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Remove)[local94]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
		}
	}
	if len(((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []AOAdd
		}))(obj)).Add)))
		write16(w, uint16(x))
	}
	for local95 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Add)[local95]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAdd", err))
		}
	}
}

func (obj *ToCltAORmAdd) deserialize(r io.Reader) {
	var local96 uint16
	{
		p := &local96
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove) = make([]AOID, local96)
	for local97 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Remove)[local97]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
		}
	}
	var local98 uint16
	{
		p := &local98
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add) = make([]AOAdd, local98)
	for local99 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Add)[local99]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAdd", err))
		}
	}
}

func (obj *ToCltAOMsgs) serialize(w io.Writer) {
	for local100 := range (*(*(struct {
		//mt:raw
		Msgs []IDAOMsg
	}))(obj)).Msgs {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:raw
				Msgs []IDAOMsg
			}))(obj)).Msgs)[local100]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.IDAOMsg", err))
		}
	}
}

func (obj *ToCltAOMsgs) deserialize(r io.Reader) {
	for {
		var local101 IDAOMsg
		err := pcall(func() {
			if err := pcall(func() {
				(local101).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.IDAOMsg", err))
			}
		})
		if err == io.EOF {
			break
		}
		((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs) = append(((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs), local101)
		chk(err)
	}
}

func (obj *ToCltHP) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP           uint16
			DamageEffect bool
		}))(obj)).HP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			HP           uint16
			DamageEffect bool
		}))(obj)).DamageEffect
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltHP) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP           uint16
			DamageEffect bool
		}))(obj)).HP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			HP           uint16
			DamageEffect bool
		}))(obj)).DamageEffect
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltMovePlayer) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovePlayer) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltLegacyKick) serialize(w io.Writer) {
	local102 := utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason))
	if len((local102)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local102)))
		write16(w, uint16(x))
	}
	for local103 := range local102 {
		{
			x := (local102)[local103]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltLegacyKick) deserialize(r io.Reader) {
	var local104 []uint16
	var local105 uint16
	{
		p := &local105
		*p = read16(r)
	}
	(local104) = make([]uint16, local105)
	for local106 := range local104 {
		{
			p := &(local104)[local106]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason = string(utf16.Decode(local104))
}

func (obj *ToCltFOV) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFOV) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltDeathScreen) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
}

func (obj *ToCltDeathScreen) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
}

func (obj *ToCltMedia) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).N
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).I
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)))
		write32(w, uint32(x))
	}
	for local107 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local107]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local107]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local107]).Name))[:])
			chk(err)
		}
		if len(((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local107]).Data)) > math.MaxUint32 {
			chk(ErrTooLong)
		}
		{
			x := uint32(len(((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local107]).Data)))
			write32(w, uint32(x))
		}
		{
			_, err := w.Write(((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local107]).Data)[:])
			chk(err)
		}
	}
}

func (obj *ToCltMedia) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).N
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).I
		*p = read16(r)
	}
	var local108 uint32
	{
		p := &local108
		*p = read32(r)
	}
	((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files) = make([]struct {
		Name string
		Data []byte
	}, local108)
	for local109 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:len32
			Data []byte
		}
	}))(obj)).Files {
		var local110 []uint8
		var local111 uint16
		{
			p := &local111
			*p = read16(r)
		}
		(local110) = make([]uint8, local111)
		{
			_, err := io.ReadFull(r, (local110)[:])
			chk(err)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local109]).Name) = string(local110)
		var local112 uint32
		{
			p := &local112
			*p = read32(r)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:len32
				Data []byte
			}
		}))(obj)).Files)[local109]).Data) = make([]byte, local112)
		{
			_, err := io.ReadFull(r, ((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:len32
					Data []byte
				}
			}))(obj)).Files)[local109]).Data)[:])
			chk(err)
		}
	}
}

func (obj *ToCltNodeDefs) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w := zlib.NewWriter(w)
			{
				local113 := uint8(1)
				{
					x := local113
					write8(w, uint8(x))
				}
			}
			{
				x := (*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					var b bytes.Buffer
					for i := range x {
						x[i].serialize(&b)
					}
					if b.Len() > math.MaxUint32 {
						chk(ErrTooLong)
					}
					write32(w, uint32(b.Len()))
					_, err := b.WriteTo(w)
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeDefs) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			{
				var local114 uint8
				local115 := uint8(1)
				{
					p := &local114
					*p = read8(r)
				}
				if local114 != local115 {
					chk(fmt.Errorf("const %v: %v", "uint8(1)", local114))
				}
			}
			{
				p := &(*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					*p = make([]NodeDef, read16(r))
					r := &io.LimitedReader{R: r, N: int64(read32(r))}
					for i := range *p {
						(*p)[i].deserialize(r)
					}
					if r.N > 0 {
						chk(fmt.Errorf("%d bytes of trailing data", r.N))
					}
				}
			}
			chk(r.Close())
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltAnnounceMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)))
		write16(w, uint16(x))
	}
	for local116 := range (*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local116]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local116]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local116]).Name))[:])
			chk(err)
		}
		if len(([]byte((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local116]).Base64SHA1))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local116]).Base64SHA1))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				Files []struct {
					Name       string
					Base64SHA1 string
				}
				URL string
			}))(obj)).Files)[local116]).Base64SHA1))[:])
			chk(err)
		}
	}
	if len(([]byte((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).URL))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).URL))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).URL))[:])
		chk(err)
	}
}

func (obj *ToCltAnnounceMedia) deserialize(r io.Reader) {
	var local117 uint16
	{
		p := &local117
		*p = read16(r)
	}
	((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files) = make([]struct {
		Name       string
		Base64SHA1 string
	}, local117)
	for local118 := range (*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).Files {
		var local119 []uint8
		var local120 uint16
		{
			p := &local120
			*p = read16(r)
		}
		(local119) = make([]uint8, local120)
		{
			_, err := io.ReadFull(r, (local119)[:])
			chk(err)
		}
		((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local118]).Name) = string(local119)
		var local121 []uint8
		var local122 uint16
		{
			p := &local122
			*p = read16(r)
		}
		(local121) = make([]uint8, local122)
		{
			_, err := io.ReadFull(r, (local121)[:])
			chk(err)
		}
		((((*(*(struct {
			Files []struct {
				Name       string
				Base64SHA1 string
			}
			URL string
		}))(obj)).Files)[local118]).Base64SHA1) = string(local121)
	}
	var local123 []uint8
	var local124 uint16
	{
		p := &local124
		*p = read16(r)
	}
	(local123) = make([]uint8, local124)
	{
		_, err := io.ReadFull(r, (local123)[:])
		chk(err)
	}
	((*(*(struct {
		Files []struct {
			Name       string
			Base64SHA1 string
		}
		URL string
	}))(obj)).URL) = string(local123)
}

func (obj *ToCltItemDefs) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w := zlib.NewWriter(w)
			{
				local125 := uint8(0)
				{
					x := local125
					write8(w, uint8(x))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Defs)))
				write16(w, uint16(x))
			}
			for local126 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local126]).serialize(w)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemDef", err))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)))
				write16(w, uint16(x))
			}
			for local127 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local127]).Alias))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local127]).Alias))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local127]).Alias))[:])
					chk(err)
				}
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local127]).Orig))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local127]).Orig))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local127]).Orig))[:])
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltItemDefs) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zlib.NewReader(byteReader{r})
			chk(err)
			{
				var local128 uint8
				local129 := uint8(0)
				{
					p := &local128
					*p = read8(r)
				}
				if local128 != local129 {
					chk(fmt.Errorf("const %v: %v", "uint8(0)", local128))
				}
			}
			var local130 uint16
			{
				p := &local130
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs) = make([]ItemDef, local130)
			for local131 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local131]).deserialize(r)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemDef", err))
				}
			}
			var local132 uint16
			{
				p := &local132
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases) = make([]struct {
				Alias string
				Orig  string
			}, local132)
			for local133 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				var local134 []uint8
				var local135 uint16
				{
					p := &local135
					*p = read16(r)
				}
				(local134) = make([]uint8, local135)
				{
					_, err := io.ReadFull(r, (local134)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local133]).Alias) = string(local134)
				var local136 []uint8
				var local137 uint16
				{
					p := &local137
					*p = read16(r)
				}
				(local136) = make([]uint8, local137)
				{
					_, err := io.ReadFull(r, (local136)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local133]).Orig) = string(local136)
			}
			chk(r.Close())
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltPlaySound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	if len(([]byte((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcType).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcAOID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Loop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Ephemeral
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltPlaySound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	var local138 []uint8
	var local139 uint16
	{
		p := &local139
		*p = read16(r)
	}
	(local138) = make([]uint8, local139)
	{
		_, err := io.ReadFull(r, (local138)[:])
		chk(err)
	}
	((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
	}))(obj)).Name) = string(local138)
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcType).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).SrcAOID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Loop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
		}))(obj)).Ephemeral
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltStopSound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
}

func (obj *ToCltStopSound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
}

func (obj *ToCltPrivs) serialize(w io.Writer) {
	if len(((*(*(struct {
		Privs []string
	}))(obj)).Privs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Privs []string
		}))(obj)).Privs)))
		write16(w, uint16(x))
	}
	for local140 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		if len(([]byte(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local140]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local140]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local140]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltPrivs) deserialize(r io.Reader) {
	var local141 uint16
	{
		p := &local141
		*p = read16(r)
	}
	((*(*(struct {
		Privs []string
	}))(obj)).Privs) = make([]string, local141)
	for local142 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		var local143 []uint8
		var local144 uint16
		{
			p := &local144
			*p = read16(r)
		}
		(local143) = make([]uint8, local144)
		{
			_, err := io.ReadFull(r, (local143)[:])
			chk(err)
		}
		(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local142]) = string(local143)
	}
}

func (obj *ToCltInvFormspec) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))[:])
		chk(err)
	}
}

func (obj *ToCltInvFormspec) deserialize(r io.Reader) {
	var local145 []uint8
	var local146 uint32
	{
		p := &local146
		*p = read32(r)
	}
	(local145) = make([]uint8, local146)
	{
		_, err := io.ReadFull(r, (local145)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec) = string(local145)
}

func (obj *ToCltDetachedInv) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltDetachedInv) deserialize(r io.Reader) {
	var local147 []uint8
	var local148 uint16
	{
		p := &local148
		*p = read16(r)
	}
	(local147) = make([]uint8, local148)
	{
		_, err := io.ReadFull(r, (local147)[:])
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name) = string(local147)
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		*p = read16(r)
	}
	var local149 []uint8
	{
		var err error
		(local149), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local149)
}

func (obj *ToCltShowFormspec) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))[:])
		chk(err)
	}
}

func (obj *ToCltShowFormspec) deserialize(r io.Reader) {
	var local150 []uint8
	var local151 uint32
	{
		p := &local151
		*p = read32(r)
	}
	(local150) = make([]uint8, local151)
	{
		_, err := io.ReadFull(r, (local150)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec) = string(local150)
	var local152 []uint8
	var local153 uint16
	{
		p := &local153
		*p = read16(r)
	}
	(local152) = make([]uint8, local153)
	{
		_, err := io.ReadFull(r, (local152)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname) = string(local152)
}

func (obj *ToCltMovement) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovement) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSpawnParticle) serialize(w io.Writer) {
	for local154 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				Drag        [3]float32
				Bounce      RangeV3F32
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Pos)[local154]
			write32(w, math.Float32bits(x))
		}
	}
	for local155 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Vel {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				Drag        [3]float32
				Bounce      RangeV3F32
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Vel)[local155]
			write32(w, math.Float32bits(x))
		}
	}
	for local156 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Acc {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				Drag        [3]float32
				Bounce      RangeV3F32
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Acc)[local156]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).ExpirationTime
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Texture))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Texture))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Texture))))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AnimParams).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	for local157 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Drag {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				Drag        [3]float32
				Bounce      RangeV3F32
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Drag)[local157]
			write32(w, math.Float32bits(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Bounce).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
}

func (obj *ToCltSpawnParticle) deserialize(r io.Reader) {
	for local158 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				Drag        [3]float32
				Bounce      RangeV3F32
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Pos)[local158]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local159 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Vel {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				Drag        [3]float32
				Bounce      RangeV3F32
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Vel)[local159]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local160 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Acc {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				Drag        [3]float32
				Bounce      RangeV3F32
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Acc)[local160]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).ExpirationTime
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local161 []uint8
	var local162 uint32
	{
		p := &local162
		*p = read32(r)
	}
	(local161) = make([]uint8, local162)
	{
		_, err := io.ReadFull(r, (local161)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Texture))) = string(local161)
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AnimParams).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	for local163 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		Drag        [3]float32
		Bounce      RangeV3F32
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
	}))(obj)).Drag {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				Drag        [3]float32
				Bounce      RangeV3F32
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
			}))(obj)).Drag)[local163]
			*p = math.Float32frombits(read32(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).Bounce).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			Drag        [3]float32
			Bounce      RangeV3F32
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
		}))(obj)).NodeTile
		*p = read8(r)
	}
}

func (obj *ToCltAddParticleSpawner) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Amount
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Duration
		write32(w, math.Float32bits(x))
	}
	for local164 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Pos {
		for local165 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Pos)[local164] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).Pos)[local164])[local165]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local166 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Vel {
		for local167 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Vel)[local166] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).Vel)[local166])[local167]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local168 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Acc {
		for local169 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Acc)[local168] {
			{
				x := (((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).Acc)[local168])[local169]
				write32(w, math.Float32bits(x))
			}
		}
	}
	for local170 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).ExpirationTime {
		{
			x := ((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).ExpirationTime)[local170]
			write32(w, math.Float32bits(x))
		}
	}
	for local171 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).Size)[local171]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Texture))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Texture))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Texture))))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AttachedAOID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AnimParams).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).PosStartBias
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).VelStartBias
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AccStartBias
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).ExpTimeStartBias
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).SizeStartBias
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).PosEnd).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).VelEnd).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AccEnd).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Drag).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Jitter).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Bounce).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Attraction).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AttractionKind", err))
	}
	if (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Attraction > NoAttraction {
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).AttractStrength).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).AttractorOrigin).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV3F32", err))
		}
		{
			x := (*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).AttractorOriginAttachedAO
			write16(w, uint16(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).Flags).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerFlags", err))
		}
		if (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Attraction > PointAttraction {
			if err := pcall(func() {
				((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).AttractorAngle).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV3F32", err))
			}
			{
				x := (*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).AttractorAngleAttachedAO
				write16(w, uint16(x))
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Radius).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if len(((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Textures)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Textures)))
		write16(w, uint16(x))
	}
	for local172 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).Textures)[local172]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTexture", err))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
}

func (obj *ToCltAddParticleSpawner) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Amount
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Duration
		*p = math.Float32frombits(read32(r))
	}
	for local173 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Pos {
		for local174 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Pos)[local173] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).Pos)[local173])[local174]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local175 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Vel {
		for local176 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Vel)[local175] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).Vel)[local175])[local176]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local177 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Acc {
		for local178 := range ((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Acc)[local177] {
			{
				p := &(((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).Acc)[local177])[local178]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	for local179 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).ExpirationTime {
		{
			p := &((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).ExpirationTime)[local179]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local180 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).Size)[local180]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local181 []uint8
	var local182 uint32
	{
		p := &local182
		*p = read32(r)
	}
	(local181) = make([]uint8, local182)
	{
		_, err := io.ReadFull(r, (local181)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Texture))) = string(local181)
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AttachedAOID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AnimParams).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).PosStartBias
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).VelStartBias
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AccStartBias
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).ExpTimeStartBias
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).SizeStartBias
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).PosEnd).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).VelEnd).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).AccEnd).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Drag).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Jitter).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Bounce).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Attraction).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AttractionKind", err))
	}
	if (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Attraction > NoAttraction {
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).AttractStrength).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).AttractorOrigin).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV3F32", err))
		}
		{
			p := &(*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).AttractorOriginAttachedAO
			*p = read16(r)
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).Flags).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerFlags", err))
		}
		if (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Attraction > PointAttraction {
			if err := pcall(func() {
				((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).AttractorAngle).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV3F32", err))
			}
			{
				p := &(*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  [2][3]float32
					ExpirationTime [2]float32 // in seconds.
					Size           [2]float32
					Collide        bool

					//mt:len32
					Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					PosStartBias     float32
					VelStartBias     float32
					AccStartBias     float32
					ExpTimeStartBias float32
					SizeStartBias    float32

					PosEnd RangeV3F32
					VelEnd RangeV3F32
					AccEnd RangeV3F32

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction > NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO uint16
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction > PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO uint16

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8
				}))(obj)).AttractorAngleAttachedAO
				*p = read16(r)
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).Radius).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	var local183 uint16
	{
		p := &local183
		*p = read16(r)
	}
	((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Textures) = make([]ParticleTexture, local183)
	for local184 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  [2][3]float32
		ExpirationTime [2]float32 // in seconds.
		Size           [2]float32
		Collide        bool

		//mt:len32
		Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		PosStartBias     float32
		VelStartBias     float32
		AccStartBias     float32
		ExpTimeStartBias float32
		SizeStartBias    float32

		PosEnd RangeV3F32
		VelEnd RangeV3F32
		AccEnd RangeV3F32

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction > NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO uint16
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction > PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO uint16

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  [2][3]float32
				ExpirationTime [2]float32 // in seconds.
				Size           [2]float32
				Collide        bool

				//mt:len32
				Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				PosStartBias     float32
				VelStartBias     float32
				AccStartBias     float32
				ExpTimeStartBias float32
				SizeStartBias    float32

				PosEnd RangeV3F32
				VelEnd RangeV3F32
				AccEnd RangeV3F32

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction > NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO uint16
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction > PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO uint16

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8
			}))(obj)).Textures)[local184]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTexture", err))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  [2][3]float32
			ExpirationTime [2]float32 // in seconds.
			Size           [2]float32
			Collide        bool

			//mt:len32
			Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			PosStartBias     float32
			VelStartBias     float32
			AccStartBias     float32
			ExpTimeStartBias float32
			SizeStartBias    float32

			PosEnd RangeV3F32
			VelEnd RangeV3F32
			AccEnd RangeV3F32

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction > NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO uint16
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction > PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO uint16

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8
		}))(obj)).NodeTile
		*p = read8(r)
	}
}

func (obj *ToCltAddHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).HUD).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUD", err))
	}
}

func (obj *ToCltAddHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).HUD).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUD", err))
	}
}

func (obj *ToCltRmHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
}

func (obj *ToCltRmHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
}

func (obj *ToCltChangeHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Field).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDPos {
		for local185 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Pos {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Pos)[local185]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDName {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Name))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDScale {
		for local186 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Scale {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Scale)[local186]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDNumber {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Number
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDItem {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Item
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDDir {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Dir
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDAlign {
		for local187 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Align {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Align)[local187]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDOffset {
		for local188 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Offset {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Offset)[local188]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).WorldPos).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDSize {
		for local189 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Size {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Size)[local189]
				write32(w, uint32(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDZIndex {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).ZIndex
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText2 {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text2))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text2))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text2))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDStyle {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Style).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
		}
	}
}

func (obj *ToCltChangeHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Field).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDPos {
		for local190 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Pos {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Pos)[local190]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDName {
		var local191 []uint8
		var local192 uint16
		{
			p := &local192
			*p = read16(r)
		}
		(local191) = make([]uint8, local192)
		{
			_, err := io.ReadFull(r, (local191)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Name) = string(local191)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDScale {
		for local193 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Scale {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Scale)[local193]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText {
		var local194 []uint8
		var local195 uint16
		{
			p := &local195
			*p = read16(r)
		}
		(local194) = make([]uint8, local195)
		{
			_, err := io.ReadFull(r, (local194)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text) = string(local194)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDNumber {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Number
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDItem {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Item
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDDir {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Dir
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDAlign {
		for local196 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Align {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Align)[local196]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDOffset {
		for local197 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Offset {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Offset)[local197]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).WorldPos).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDSize {
		for local198 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Size {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Size)[local198]
				*p = int32(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDZIndex {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).ZIndex
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText2 {
		var local199 []uint8
		var local200 uint16
		{
			p := &local200
			*p = read16(r)
		}
		(local199) = make([]uint8, local200)
		{
			_, err := io.ReadFull(r, (local199)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text2) = string(local199)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDStyle {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Style).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
		}
	}
}

func (obj *ToCltHUDFlags) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
}

func (obj *ToCltHUDFlags) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
}

func (obj *ToCltSetHotbarParam) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			local201 := uint16(4) // Size of Size field.
			{
				x := local201
				write16(w, uint16(x))
			}
		}
		{
			x := (*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
}

func (obj *ToCltSetHotbarParam) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			var local202 uint16
			local203 := uint16(4) // Size of Size field.
			{
				p := &local202
				*p = read16(r)
			}
			if local202 != local203 {
				chk(fmt.Errorf("const %v: %v", "uint16(4) // Size of Size field.", local202))
			}
		}
		{
			p := &(*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
}

func (obj *ToCltBreath) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Breath uint16
		}))(obj)).Breath
		write16(w, uint16(x))
	}
}

func (obj *ToCltBreath) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Breath uint16
		}))(obj)).Breath
		*p = read16(r)
	}
}

func (obj *ToCltSkyParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).BgColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32
	}))(obj)).Type))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).Type))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).Type))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).Clouds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).SunFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).MoonFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32
	}))(obj)).FogTintType))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).FogTintType))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).FogTintType))[:])
		chk(err)
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32
	}))(obj)).Type == "skybox" {
		if len(((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).Textures)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).Textures)))
			write16(w, uint16(x))
		}
		for local204 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA

					BodyOrbitTilt float32
				}))(obj)).Textures)[local204]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32
	}))(obj)).Type == "regular" {
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).DaySky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).DayHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).DawnSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).DawnHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).NightSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).NightHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).Indoor
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).BodyOrbitTilt
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltSkyParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).BgColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local205 []uint8
	var local206 uint16
	{
		p := &local206
		*p = read16(r)
	}
	(local205) = make([]uint8, local206)
	{
		_, err := io.ReadFull(r, (local205)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32
	}))(obj)).Type) = string(local205)
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).Clouds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).SunFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).MoonFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local207 []uint8
	var local208 uint16
	{
		p := &local208
		*p = read16(r)
	}
	(local207) = make([]uint8, local208)
	{
		_, err := io.ReadFull(r, (local207)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32
	}))(obj)).FogTintType) = string(local207)
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32
	}))(obj)).Type == "skybox" {
		var local209 uint16
		{
			p := &local209
			*p = read16(r)
		}
		((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).Textures) = make([]Texture, local209)
		for local210 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA

					BodyOrbitTilt float32
				}))(obj)).Textures)[local210]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32
	}))(obj)).Type == "regular" {
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).DaySky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).DayHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).DawnSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).DawnHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).NightSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).NightHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32
			}))(obj)).Indoor
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32
		}))(obj)).BodyOrbitTilt
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltOverrideDayNightRatio) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		write16(w, uint16(x))
	}
}

func (obj *ToCltOverrideDayNightRatio) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		*p = read16(r)
	}
}

func (obj *ToCltLocalPlayerAnim) serialize(w io.Writer) {
	for local211 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local211]
			write32(w, uint32(x))
		}
	}
	for local212 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local212]
			write32(w, uint32(x))
		}
	}
	for local213 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local213]
			write32(w, uint32(x))
		}
	}
	for local214 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local214]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltLocalPlayerAnim) deserialize(r io.Reader) {
	for local215 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local215]
			*p = int32(read32(r))
		}
	}
	for local216 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local216]
			*p = int32(read32(r))
		}
	}
	for local217 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local217]
			*p = int32(read32(r))
		}
	}
	for local218 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local218]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltEyeOffset) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).First).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).Third).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltEyeOffset) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).First).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third Vec
		}))(obj)).Third).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltDelParticleSpawner) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltDelParticleSpawner) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltCloudParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		write32(w, math.Float32bits(x))
	}
	for local219 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			x := ((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local219]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *ToCltCloudParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		*p = math.Float32frombits(read32(r))
	}
	for local220 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			p := &((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local220]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ToCltFadeSound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFadeSound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltUpdatePlayerList) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerListUpdateType", err))
	}
	if len(((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)))
		write16(w, uint16(x))
	}
	for local221 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		if len(([]byte(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local221]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local221]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local221]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltUpdatePlayerList) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerListUpdateType", err))
	}
	var local222 uint16
	{
		p := &local222
		*p = read16(r)
	}
	((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players) = make([]string, local222)
	for local223 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		var local224 []uint8
		var local225 uint16
		{
			p := &local225
			*p = read16(r)
		}
		(local224) = make([]uint8, local225)
		{
			_, err := io.ReadFull(r, (local224)[:])
			chk(err)
		}
		(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local223]) = string(local224)
	}
}

func (obj *ToCltModChanMsg) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToCltModChanMsg) deserialize(r io.Reader) {
	var local226 []uint8
	var local227 uint16
	{
		p := &local227
		*p = read16(r)
	}
	(local226) = make([]uint8, local227)
	{
		_, err := io.ReadFull(r, (local226)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel) = string(local226)
	var local228 []uint8
	var local229 uint16
	{
		p := &local229
		*p = read16(r)
	}
	(local228) = make([]uint8, local229)
	{
		_, err := io.ReadFull(r, (local228)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender) = string(local228)
	var local230 []uint8
	var local231 uint16
	{
		p := &local231
		*p = read16(r)
	}
	(local230) = make([]uint8, local231)
	{
		_, err := io.ReadFull(r, (local230)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg) = string(local230)
}

func (obj *ToCltModChanSig) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ModChanSig", err))
	}
	if len(([]byte((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToCltModChanSig) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ModChanSig", err))
	}
	var local232 []uint8
	var local233 uint16
	{
		p := &local233
		*p = read16(r)
	}
	(local232) = make([]uint8, local233)
	{
		_, err := io.ReadFull(r, (local232)[:])
		chk(err)
	}
	((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel) = string(local232)
}

func (obj *ToCltNodeMetasChanged) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				w := zlib.NewWriter(w)
				if x == nil {
					write8(w, 0)
				} else {
					write8(w, 2)
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					keys := make([][3]int16, 0, len(x))
					for key := range x {
						keys = append(keys, key)
					}
					sort.Slice(keys, func(i, j int) bool {
						p, q := keys[i], keys[j]
						for i := range p {
							switch {
							case p[i] < q[i]:
								return true
							case p[i] > q[i]:
								return false
							}
						}
						return false
					})
					for _, key := range keys {
						for _, n := range key {
							write16(w, uint16(n))
						}
						chk(serialize(w, x[key]))
					}
				}
				chk(w.Close())
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeMetasChanged) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				r, err := zlib.NewReader(byteReader{r})
				chk(err)
				switch ver := read8(r); ver {
				case 0:
					*p = nil
				case 2:
					n := read16(r)
					*p = make(map[[3]int16]*NodeMeta, n)
					for ; n > 0; n-- {
						var pos [3]int16
						for i := range pos {
							pos[i] = int16(read16(r))
						}
						nm := new(NodeMeta)
						chk(deserialize(r, nm))
						(*p)[pos] = nm
					}
				default:
					chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
				}
				chk(r.Close())
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltSunParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltSunParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltMoonParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMoonParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltStarParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Count
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Color
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).DayOpacity
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltStarParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Count
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Color
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).DayOpacity
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSRPBytesSaltB) serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).B)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltSRPBytesSaltB) deserialize(r io.Reader) {
	var local234 uint16
	{
		p := &local234
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt) = make([]byte, local234)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local235 uint16
	{
		p := &local235
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).B) = make([]byte, local235)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Prepend string
	}))(obj)).Prepend))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) deserialize(r io.Reader) {
	var local236 []uint8
	var local237 uint16
	{
		p := &local237
		*p = read16(r)
	}
	(local236) = make([]uint8, local237)
	{
		_, err := io.ReadFull(r, (local236)[:])
		chk(err)
	}
	((*(*(struct {
		Prepend string
	}))(obj)).Prepend) = string(local236)
}

func (obj *ToCltLighting) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).ShadowIntensity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).Saturation
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).LuminanceMin
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).LuminanceMax
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).ExposureCorrection
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).SpeedDarkBright
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).SpeedBrightDark
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).CenterWeightPower
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltLighting) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).ShadowIntensity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).Saturation
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).LuminanceMin
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).LuminanceMax
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).ExposureCorrection
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).SpeedDarkBright
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).SpeedBrightDark
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
		}))(obj)).CenterWeightPower
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AOCmdProps) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOProps", err))
	}
}

func (obj *AOCmdProps) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOProps", err))
	}
}

func (obj *AOCmdPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPos", err))
	}
}

func (obj *AOCmdPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPos", err))
	}
}

func (obj *AOCmdTextureMod) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
}

func (obj *AOCmdTextureMod) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
}

func (obj *AOCmdSprite) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOSprite", err))
	}
}

func (obj *AOCmdSprite) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOSprite", err))
	}
}

func (obj *AOCmdHP) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP uint16
		}))(obj)).HP
		write16(w, uint16(x))
	}
}

func (obj *AOCmdHP) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP uint16
		}))(obj)).HP
		*p = read16(r)
	}
}

func (obj *AOCmdArmorGroups) serialize(w io.Writer) {
	if len(((*(*(struct {
		Armor []Group
	}))(obj)).Armor)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Armor []Group
		}))(obj)).Armor)))
		write16(w, uint16(x))
	}
	for local238 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local238]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
		}
	}
}

func (obj *AOCmdArmorGroups) deserialize(r io.Reader) {
	var local239 uint16
	{
		p := &local239
		*p = read16(r)
	}
	((*(*(struct {
		Armor []Group
	}))(obj)).Armor) = make([]Group, local239)
	for local240 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local240]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
		}
	}
}

func (obj *AOCmdAnim) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAnim", err))
	}
}

func (obj *AOCmdAnim) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAnim", err))
	}
}

func (obj *AOCmdBonePos) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Bone string
		Pos  AOBonePos
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOBonePos", err))
	}
}

func (obj *AOCmdBonePos) deserialize(r io.Reader) {
	var local241 []uint8
	var local242 uint16
	{
		p := &local242
		*p = read16(r)
	}
	(local241) = make([]uint8, local242)
	{
		_, err := io.ReadFull(r, (local241)[:])
		chk(err)
	}
	((*(*(struct {
		Bone string
		Pos  AOBonePos
	}))(obj)).Bone) = string(local241)
	if err := pcall(func() {
		((*(*(struct {
			Bone string
			Pos  AOBonePos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOBonePos", err))
	}
}

func (obj *AOCmdAttach) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAttach", err))
	}
}

func (obj *AOCmdAttach) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAttach", err))
	}
}

func (obj *AOCmdPhysOverride) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdPhysOverride) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdSpawnInfant) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		local243 := genericCAO
		if err := pcall(func() {
			(local243).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
	}
}

func (obj *AOCmdSpawnInfant) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var local244 aoType
		local245 := genericCAO
		if err := pcall(func() {
			(local244).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
		if local244 != local245 {
			chk(fmt.Errorf("const %v: %v", "genericCAO", local244))
		}
	}
}

func (obj *AOCmdAnimSpeed) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Speed float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOCmdAnimSpeed) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Speed float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *NodeMeta) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			//mt:len32
			Fields []NodeMetaField

			Inv Inv
		}))(obj)).Fields)))
		write32(w, uint32(x))
	}
	for local246 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local246]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Serialize(w))
}

func (obj *NodeMeta) deserialize(r io.Reader) {
	var local247 uint32
	{
		p := &local247
		*p = read32(r)
	}
	((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields) = make([]NodeMetaField, local247)
	for local248 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local248]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Deserialize(r))
}

func (obj *MinimapMode) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MinimapType", err))
	}
	if len(([]byte((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		write16(w, uint16(x))
	}
}

func (obj *MinimapMode) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MinimapType", err))
	}
	var local249 []uint8
	var local250 uint16
	{
		p := &local250
		*p = read16(r)
	}
	(local249) = make([]uint8, local250)
	{
		_, err := io.ReadFull(r, (local249)[:])
		chk(err)
	}
	((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label) = string(local249)
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		*p = read16(r)
	}
}

func (obj *NodeDef) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Param0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local251 := uint8(13)
			{
				x := local251
				write8(w, uint8(x))
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local252 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).Groups)[local252]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).P1Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).P2Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrawType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DrawType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Mesh))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Mesh))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Mesh))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Scale
			write32(w, math.Float32bits(x))
		}
		{
			local253 := uint8(6)
			{
				x := local253
				write8(w, uint8(x))
			}
		}
		for local254 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).Tiles)[local254]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		for local255 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).OverlayTiles)[local255]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			local256 := uint8(6)
			{
				x := local256
				write8(w, uint8(x))
			}
		}
		for local257 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).SpecialTiles)[local257]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Palette).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Waving).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.WaveType", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ConnectSides
			write8(w, uint8(x))
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).ConnectTo)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ConnectTo)))
			write16(w, uint16(x))
		}
		for local258 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).ConnectTo)[local258]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).InsideTint
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Level
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Translucent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Transparent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LightSrc
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).GndContent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Collides
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Pointable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Diggable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Climbable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Replaceable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).OnRightClick
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DmgPerSec
			write32(w, uint32(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiquidType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LiquidType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).FlowingAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FlowingAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FlowingAlt))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).SrcAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).SrcAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).SrcAlt))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Viscosity
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiqRenewable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FlowRange
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrownDmg
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Floodable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrawBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ColBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).SelBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FootstepSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DiggingSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DugSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LegacyFaceDir
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LegacyMounted
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).DigPredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DigPredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DigPredict))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).MaxLvl
			write8(w, uint8(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).AlphaUse).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlphaUse", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).MoveResistance
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiquidMovePhysics
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *NodeDef) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Param0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			var local259 uint8
			local260 := uint8(13)
			{
				p := &local259
				*p = read8(r)
			}
			if local259 != local260 {
				chk(fmt.Errorf("const %v: %v", "uint8(13)", local259))
			}
		}
		var local261 []uint8
		var local262 uint16
		{
			p := &local262
			*p = read16(r)
		}
		(local261) = make([]uint8, local262)
		{
			_, err := io.ReadFull(r, (local261)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Name) = string(local261)
		var local263 uint16
		{
			p := &local263
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Groups) = make([]Group, local263)
		for local264 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).Groups)[local264]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).P1Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).P2Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrawType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DrawType", err))
		}
		var local265 []uint8
		var local266 uint16
		{
			p := &local266
			*p = read16(r)
		}
		(local265) = make([]uint8, local266)
		{
			_, err := io.ReadFull(r, (local265)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Mesh) = string(local265)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Scale
			*p = math.Float32frombits(read32(r))
		}
		{
			var local267 uint8
			local268 := uint8(6)
			{
				p := &local267
				*p = read8(r)
			}
			if local267 != local268 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local267))
			}
		}
		for local269 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).Tiles)[local269]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		for local270 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).OverlayTiles)[local270]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			var local271 uint8
			local272 := uint8(6)
			{
				p := &local271
				*p = read8(r)
			}
			if local271 != local272 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local271))
			}
		}
		for local273 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).SpecialTiles)[local273]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Palette).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Waving).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.WaveType", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ConnectSides
			*p = read8(r)
		}
		var local274 uint16
		{
			p := &local274
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).ConnectTo) = make([]Content, local274)
		for local275 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					Pointable    bool
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
				}))(obj)).ConnectTo)[local275]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).InsideTint
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Level
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Translucent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Transparent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LightSrc
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).GndContent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Collides
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Pointable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Diggable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Climbable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Replaceable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).OnRightClick
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DmgPerSec
			*p = int32(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiquidType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LiquidType", err))
		}
		var local276 []uint8
		var local277 uint16
		{
			p := &local277
			*p = read16(r)
		}
		(local276) = make([]uint8, local277)
		{
			_, err := io.ReadFull(r, (local276)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).FlowingAlt) = string(local276)
		var local278 []uint8
		var local279 uint16
		{
			p := &local279
			*p = read16(r)
		}
		(local278) = make([]uint8, local279)
		{
			_, err := io.ReadFull(r, (local278)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).SrcAlt) = string(local278)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Viscosity
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiqRenewable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FlowRange
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrownDmg
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).Floodable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DrawBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).ColBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).SelBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).FootstepSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DiggingSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).DugSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LegacyFaceDir
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LegacyMounted
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		var local280 []uint8
		var local281 uint16
		{
			p := &local281
			*p = read16(r)
		}
		(local280) = make([]uint8, local281)
		{
			_, err := io.ReadFull(r, (local280)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			Pointable    bool
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
		}))(obj)).DigPredict) = string(local280)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).MaxLvl
			*p = read8(r)
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).AlphaUse).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlphaUse", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).MoveResistance
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				Pointable    bool
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
			}))(obj)).LiquidMovePhysics
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *PointedNode) serialize(w io.Writer) {
	for local282 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local282]
			write16(w, uint16(x))
		}
	}
	for local283 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local283]
			write16(w, uint16(x))
		}
	}
}

func (obj *PointedNode) deserialize(r io.Reader) {
	for local284 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local284]
			*p = int16(read16(r))
		}
	}
	for local285 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local285]
			*p = int16(read16(r))
		}
	}
}

func (obj *PointedAO) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
}

func (obj *PointedAO) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
}

func (obj *CompressionModes) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *CompressionModes) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *PlayerPos) serialize(w io.Writer) {
	for local286 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Pos100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Pos100)[local286]
			write32(w, uint32(x))
		}
	}
	for local287 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Vel100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Vel100)[local287]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Pitch100
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Yaw100
		write32(w, uint32(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Keys).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Keys", err))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).FOV80
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).WantedRange
		write8(w, uint8(x))
	}
}

func (obj *PlayerPos) deserialize(r io.Reader) {
	for local288 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Pos100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Pos100)[local288]
			*p = int32(read32(r))
		}
	}
	for local289 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
	}))(obj)).Vel100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
			}))(obj)).Vel100)[local289]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Pitch100
		*p = int32(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Yaw100
		*p = int32(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).Keys).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Keys", err))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).FOV80
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
		}))(obj)).WantedRange
		*p = read8(r)
	}
}

func (obj *Interaction) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Interaction) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *SoundID) serialize(w io.Writer) {
	{
		x := *(*(int32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *SoundID) deserialize(r io.Reader) {
	{
		p := &*(*(int32))(obj)
		*p = int32(read32(r))
	}
}

func (obj *Field) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))[:])
		chk(err)
	}
}

func (obj *Field) deserialize(r io.Reader) {
	var local290 []uint8
	var local291 uint16
	{
		p := &local291
		*p = read16(r)
	}
	(local290) = make([]uint8, local291)
	{
		_, err := io.ReadFull(r, (local290)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name) = string(local290)
	var local292 []uint8
	var local293 uint32
	{
		p := &local293
		*p = read32(r)
	}
	(local292) = make([]uint8, local293)
	{
		_, err := io.ReadFull(r, (local292)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value) = string(local292)
}

func (obj *AuthMethods) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *AuthMethods) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *Pos) serialize(w io.Writer) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *Pos) deserialize(r io.Reader) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *KickReason) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *KickReason) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *MapBlk) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LitFromBlks", err))
	}
	{
		local294 := uint8(2) // Size of param0 in bytes.
		{
			x := local294
			write8(w, uint8(x))
		}
	}
	{
		local295 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			x := local295
			write8(w, uint8(x))
		}
	}
	for local296 := range (*(*(struct {
		Flags   MapBlkFlags
		LitFrom LitFromBlks

		Param0 [4096]Content
		Param1 [4096]uint8
		Param2 [4096]uint8

		NodeMetas map[uint16]*NodeMeta
	}))(obj)).Param0 {
		if err := pcall(func() {
			(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param0)[local296]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
		}
	}
	{
		_, err := w.Write(((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param1)[:])
		chk(err)
	}
	{
		_, err := w.Write(((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param2)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			if x == nil {
				write8(w, 0)
			} else {
				write8(w, 2)
				// len(map[uint16]...) always < math.MaxUint16
				write16(w, uint16(len(x)))
				keys := make([]uint16, 0, len(x))
				for key := range x {
					keys = append(keys, key)
				}
				sort.Slice(keys, func(i, j int) bool {
					i2pos := func(i int) [3]int16 {
						return Blkpos2Pos([3]int16{}, keys[i])
					}
					p, q := i2pos(i), i2pos(j)
					for i := range p {
						switch {
						case p[i] < q[i]:
							return true
						case p[i] > q[i]:
							return false
						}
					}
					return false
				})
				for _, key := range keys {
					write16(w, key)
					chk(serialize(w, x[key]))
				}
			}
		}
	}
}

func (obj *MapBlk) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LitFromBlks", err))
	}
	{
		var local297 uint8
		local298 := uint8(2) // Size of param0 in bytes.
		{
			p := &local297
			*p = read8(r)
		}
		if local297 != local298 {
			chk(fmt.Errorf("const %v: %v", "uint8(2)     // Size of param0 in bytes.", local297))
		}
	}
	{
		var local299 uint8
		local300 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			p := &local299
			*p = read8(r)
		}
		if local299 != local300 {
			chk(fmt.Errorf("const %v: %v", "uint8(1 + 1) // Size of param1 and param2 combined, in bytes.", local299))
		}
	}
	for local301 := range (*(*(struct {
		Flags   MapBlkFlags
		LitFrom LitFromBlks

		Param0 [4096]Content
		Param1 [4096]uint8
		Param2 [4096]uint8

		NodeMetas map[uint16]*NodeMeta
	}))(obj)).Param0 {
		if err := pcall(func() {
			(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param0)[local301]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
		}
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param1)[:])
		chk(err)
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param2)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			switch ver := read8(r); ver {
			case 0:
				*p = nil
			case 2:
				n := read16(r)
				*p = make(map[uint16]*NodeMeta, n)
				for ; n > 0; n-- {
					pos := read16(r)
					nm := new(NodeMeta)
					chk(deserialize(r, nm))
					(*p)[pos] = nm
				}
			default:
				chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
			}
		}
	}
}

func (obj *Node) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		write8(w, uint8(x))
	}
}

func (obj *Node) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		*p = read8(r)
	}
}

func (obj *CSMRestrictionFlags) serialize(w io.Writer) {
	{
		x := *(*(uint64))(obj)
		write64(w, uint64(x))
	}
}

func (obj *CSMRestrictionFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint64))(obj)
		*p = read64(r)
	}
}

func (obj *Vec) serialize(w io.Writer) {
	for local302 := range *(*([3]float32))(obj) {
		{
			x := (*(*([3]float32))(obj))[local302]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *Vec) deserialize(r io.Reader) {
	for local303 := range *(*([3]float32))(obj) {
		{
			p := &(*(*([3]float32))(obj))[local303]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ChatMsgType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ChatMsgType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOID) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *AOID) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AOAdd) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		local304 := genericCAO
		if err := pcall(func() {
			(local304).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		if err := pcall(func() {
			((*(*(struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}))(obj)).InitData).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOInitData", err))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *AOAdd) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var local305 aoType
		local306 := genericCAO
		if err := pcall(func() {
			(local305).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
		if local305 != local306 {
			chk(fmt.Errorf("const %v: %v", "genericCAO", local305))
		}
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		if err := pcall(func() {
			((*(*(struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}))(obj)).InitData).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOInitData", err))
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *IDAOMsg) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			writeAOMsg(w, x)
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *IDAOMsg) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			{
				var err error
				*p, err = readAOMsg(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ItemDef) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local307 := uint8(6)
			{
				x := local307
				write8(w, uint8(x))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemType", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).Desc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Desc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Desc))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).InvImg).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).WieldImg).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		for local308 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).WieldScale {
			{
				x := ((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8

					SoundUse    SoundDef
					SoundUseAir SoundDef
				}))(obj)).WieldScale)[local308]
				write32(w, math.Float32bits(x))
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).StackMax
			write16(w, uint16(x))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Usable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).CanPointLiquids
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).ToolCaps).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolCaps", err))
		}
		if len(((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local309 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8

					SoundUse    SoundDef
					SoundUseAir SoundDef
				}))(obj)).Groups)[local309]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).PlacePredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PlacePredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PlacePredict))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PlaceSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PlaceFailSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PointRange
			write32(w, math.Float32bits(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Palette).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).InvOverlay).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).WieldOverlay).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).ShortDesc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).ShortDesc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).ShortDesc))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PlaceParam2
			write8(w, uint8(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).SoundUse).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).SoundUseAir).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ItemDef) deserialize(r io.Reader) {
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			var local310 uint8
			local311 := uint8(6)
			{
				p := &local310
				*p = read8(r)
			}
			if local310 != local311 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local310))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemType", err))
		}
		var local312 []uint8
		var local313 uint16
		{
			p := &local313
			*p = read16(r)
		}
		(local312) = make([]uint8, local313)
		{
			_, err := io.ReadFull(r, (local312)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).Name) = string(local312)
		var local314 []uint8
		var local315 uint16
		{
			p := &local315
			*p = read16(r)
		}
		(local314) = make([]uint8, local315)
		{
			_, err := io.ReadFull(r, (local314)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).Desc) = string(local314)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).InvImg).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).WieldImg).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		for local316 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).WieldScale {
			{
				p := &((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8

					SoundUse    SoundDef
					SoundUseAir SoundDef
				}))(obj)).WieldScale)[local316]
				*p = math.Float32frombits(read32(r))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).StackMax
			*p = read16(r)
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Usable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).CanPointLiquids
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).ToolCaps).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolCaps", err))
		}
		var local317 uint16
		{
			p := &local317
			*p = read16(r)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).Groups) = make([]Group, local317)
		for local318 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					PlaceParam2 uint8

					SoundUse    SoundDef
					SoundUseAir SoundDef
				}))(obj)).Groups)[local318]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		var local319 []uint8
		var local320 uint16
		{
			p := &local320
			*p = read16(r)
		}
		(local319) = make([]uint8, local320)
		{
			_, err := io.ReadFull(r, (local319)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).PlacePredict) = string(local319)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PlaceSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PlaceFailSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PointRange
			*p = math.Float32frombits(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Palette).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).InvOverlay).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).WieldOverlay).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		var local321 []uint8
		var local322 uint16
		{
			p := &local322
			*p = read16(r)
		}
		(local321) = make([]uint8, local322)
		{
			_, err := io.ReadFull(r, (local321)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			PlaceParam2 uint8

			SoundUse    SoundDef
			SoundUseAir SoundDef
		}))(obj)).ShortDesc) = string(local321)
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).PlaceParam2
			*p = read8(r)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).SoundUse).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				PlaceParam2 uint8

				SoundUse    SoundDef
				SoundUseAir SoundDef
			}))(obj)).SoundUseAir).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *SoundSrcType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *SoundSrcType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileAnim) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := w.Write(((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local323 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				x := ((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local323]
				write16(w, uint16(x))
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			x := (*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TileAnim) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := io.ReadFull(r, ((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local324 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				p := &((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local324]
				*p = read16(r)
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			p := &(*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *RangeV3F32) serialize(w io.Writer) {
	for local325 := range (*(*(struct {
		Min, Max [3]float32
		Bias     float32
	}))(obj)).Min {
		{
			x := ((*(*(struct {
				Min, Max [3]float32
				Bias     float32
			}))(obj)).Min)[local325]
			write32(w, math.Float32bits(x))
		}
	}
	for local326 := range (*(*(struct {
		Min, Max [3]float32
		Bias     float32
	}))(obj)).Max {
		{
			x := ((*(*(struct {
				Min, Max [3]float32
				Bias     float32
			}))(obj)).Max)[local326]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Min, Max [3]float32
			Bias     float32
		}))(obj)).Bias
		write32(w, math.Float32bits(x))
	}
}

func (obj *RangeV3F32) deserialize(r io.Reader) {
	for local327 := range (*(*(struct {
		Min, Max [3]float32
		Bias     float32
	}))(obj)).Min {
		{
			p := &((*(*(struct {
				Min, Max [3]float32
				Bias     float32
			}))(obj)).Min)[local327]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local328 := range (*(*(struct {
		Min, Max [3]float32
		Bias     float32
	}))(obj)).Max {
		{
			p := &((*(*(struct {
				Min, Max [3]float32
				Bias     float32
			}))(obj)).Max)[local328]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Min, Max [3]float32
			Bias     float32
		}))(obj)).Bias
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *Content) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *Content) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *ParticleSpawnerID) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *ParticleSpawnerID) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *TweenRangeV3F32) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Start, End RangeV3F32
		}))(obj)).Start).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Start, End RangeV3F32
		}))(obj)).End).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
}

func (obj *TweenRangeV3F32) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Start, End RangeV3F32
		}))(obj)).Start).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Start, End RangeV3F32
		}))(obj)).End).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
}

func (obj *TweenRangeF32) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Start, End RangeF32
		}))(obj)).Start).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Start, End RangeF32
		}))(obj)).End).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
}

func (obj *TweenRangeF32) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Start, End RangeF32
		}))(obj)).Start).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Start, End RangeF32
		}))(obj)).End).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
}

func (obj *AttractionKind) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AttractionKind) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TweenV3F32) serialize(w io.Writer) {
	for local329 := range (*(*(struct {
		Start, End [3]float32
	}))(obj)).Start {
		{
			x := ((*(*(struct {
				Start, End [3]float32
			}))(obj)).Start)[local329]
			write32(w, math.Float32bits(x))
		}
	}
	for local330 := range (*(*(struct {
		Start, End [3]float32
	}))(obj)).End {
		{
			x := ((*(*(struct {
				Start, End [3]float32
			}))(obj)).End)[local330]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TweenV3F32) deserialize(r io.Reader) {
	for local331 := range (*(*(struct {
		Start, End [3]float32
	}))(obj)).Start {
		{
			p := &((*(*(struct {
				Start, End [3]float32
			}))(obj)).Start)[local331]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local332 := range (*(*(struct {
		Start, End [3]float32
	}))(obj)).End {
		{
			p := &((*(*(struct {
				Start, End [3]float32
			}))(obj)).End)[local332]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ParticleSpawnerFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ParticleSpawnerFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ParticleTexture) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTextureFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Alpha).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Scale).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV2F32", err))
	}
	if (*(*(struct {
		Flags ParticleTextureFlags
		Alpha TweenF32
		Scale TweenV2F32

		//mt:if %s.Flags & Animated == Animated
		Animation TileAnim
	}))(obj)).Flags&Animated == Animated {
		if err := pcall(func() {
			((*(*(struct {
				Flags ParticleTextureFlags
				Alpha TweenF32
				Scale TweenV2F32

				//mt:if %s.Flags & Animated == Animated
				Animation TileAnim
			}))(obj)).Animation).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
		}
	}
}

func (obj *ParticleTexture) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTextureFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Alpha).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Scale).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV2F32", err))
	}
	if (*(*(struct {
		Flags ParticleTextureFlags
		Alpha TweenF32
		Scale TweenV2F32

		//mt:if %s.Flags & Animated == Animated
		Animation TileAnim
	}))(obj)).Flags&Animated == Animated {
		if err := pcall(func() {
			((*(*(struct {
				Flags ParticleTextureFlags
				Alpha TweenF32
				Scale TweenV2F32

				//mt:if %s.Flags & Animated == Animated
				Animation TileAnim
			}))(obj)).Animation).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
		}
	}
}

func (obj *HUDID) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDID) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDType", err))
	}
	for local333 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Pos)[local333]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Name))[:])
		chk(err)
	}
	for local334 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Scale {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Scale)[local334]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Number
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Item
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Dir
		write32(w, uint32(x))
	}
	for local335 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Align {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Align)[local335]
			write32(w, math.Float32bits(x))
		}
	}
	for local336 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Offset {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Offset)[local336]
			write32(w, math.Float32bits(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).WorldPos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local337 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Size)[local337]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).ZIndex
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text2))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text2))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text2))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Style).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
	}
}

func (obj *HUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDType", err))
	}
	for local338 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Pos)[local338]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local339 []uint8
	var local340 uint16
	{
		p := &local340
		*p = read16(r)
	}
	(local339) = make([]uint8, local340)
	{
		_, err := io.ReadFull(r, (local339)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Name) = string(local339)
	for local341 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Scale {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Scale)[local341]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local342 []uint8
	var local343 uint16
	{
		p := &local343
		*p = read16(r)
	}
	(local342) = make([]uint8, local343)
	{
		_, err := io.ReadFull(r, (local342)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text) = string(local342)
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Number
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Item
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Dir
		*p = read32(r)
	}
	for local344 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Align {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Align)[local344]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local345 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Offset {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Offset)[local345]
			*p = math.Float32frombits(read32(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).WorldPos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local346 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Size)[local346]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).ZIndex
		*p = int16(read16(r))
	}
	var local347 []uint8
	var local348 uint16
	{
		p := &local348
		*p = read16(r)
	}
	(local347) = make([]uint8, local348)
	{
		_, err := io.ReadFull(r, (local347)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text2) = string(local347)
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Style).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
	}
}

func (obj *HUDField) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDField) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDStyleFlags) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDStyleFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUDFlags) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HotbarParam) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *HotbarParam) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Texture) serialize(w io.Writer) {
	if len(([]byte(*(*(string))(obj)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte(*(*(string))(obj)))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte(*(*(string))(obj)))[:])
		chk(err)
	}
}

func (obj *Texture) deserialize(r io.Reader) {
	var local349 []uint8
	var local350 uint16
	{
		p := &local350
		*p = read16(r)
	}
	(local349) = make([]uint8, local350)
	{
		_, err := io.ReadFull(r, (local349)[:])
		chk(err)
	}
	(*(*(string))(obj)) = string(local349)
}

func (obj *PlayerListUpdateType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *PlayerListUpdateType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ModChanSig) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ModChanSig) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOProps) serialize(w io.Writer) {
	{
		local351 := uint8(4)
		{
			x := local351
			write8(w, uint8(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).MaxHP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).CollideWithNodes
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Weight
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).ColBox).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).SelBox).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Pointable
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Visual))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Visual))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Visual))[:])
		chk(err)
	}
	for local352 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).VisualSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).VisualSize)[local352]
			write32(w, math.Float32bits(x))
		}
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Textures)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Textures)))
		write16(w, uint16(x))
	}
	for local353 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).Textures)[local353]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
	for local354 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).SpriteSheetSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).SpriteSheetSize)[local354]
			write16(w, uint16(x))
		}
	}
	for local355 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).SpritePos {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).SpritePos)[local355]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).MakeFootstepSnds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).RotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Mesh))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Mesh))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Mesh))[:])
		chk(err)
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Colors)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Colors)))
		write16(w, uint16(x))
	}
	for local356 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Colors {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).Colors)[local356]
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).CollideWithAOs
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).StepHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).FaceRotateDir
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).FaceRotateDirOff
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).BackfaceCull
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Nametag))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Nametag))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Nametag))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).NametagColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).FaceRotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Infotext))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Infotext))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Infotext))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Itemstring))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Itemstring))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Itemstring))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).MaxBreath
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).EyeHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).ZoomFOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).UseTextureAlpha
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).DmgTextureMod).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Shaded
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).ShowOnMinimap
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).NametagBG
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).RotateSelBox
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOProps) deserialize(r io.Reader) {
	{
		var local357 uint8
		local358 := uint8(4)
		{
			p := &local357
			*p = read8(r)
		}
		if local357 != local358 {
			chk(fmt.Errorf("const %v: %v", "uint8(4)", local357))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).MaxHP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).CollideWithNodes
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Weight
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).ColBox).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).SelBox).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Pointable
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local359 []uint8
	var local360 uint16
	{
		p := &local360
		*p = read16(r)
	}
	(local359) = make([]uint8, local360)
	{
		_, err := io.ReadFull(r, (local359)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Visual) = string(local359)
	for local361 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).VisualSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).VisualSize)[local361]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local362 uint16
	{
		p := &local362
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Textures) = make([]Texture, local362)
	for local363 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).Textures)[local363]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
	for local364 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).SpriteSheetSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).SpriteSheetSize)[local364]
			*p = int16(read16(r))
		}
	}
	for local365 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).SpritePos {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).SpritePos)[local365]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).MakeFootstepSnds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).RotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local366 []uint8
	var local367 uint16
	{
		p := &local367
		*p = read16(r)
	}
	(local366) = make([]uint8, local367)
	{
		_, err := io.ReadFull(r, (local366)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Mesh) = string(local366)
	var local368 uint16
	{
		p := &local368
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Colors) = make([]color.NRGBA, local368)
	for local369 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Colors {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        bool
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
			}))(obj)).Colors)[local369]
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).CollideWithAOs
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).StepHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).FaceRotateDir
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).FaceRotateDirOff
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).BackfaceCull
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local370 []uint8
	var local371 uint16
	{
		p := &local371
		*p = read16(r)
	}
	(local370) = make([]uint8, local371)
	{
		_, err := io.ReadFull(r, (local370)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Nametag) = string(local370)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).NametagColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).FaceRotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local372 []uint8
	var local373 uint16
	{
		p := &local373
		*p = read16(r)
	}
	(local372) = make([]uint8, local373)
	{
		_, err := io.ReadFull(r, (local372)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Infotext) = string(local372)
	var local374 []uint8
	var local375 uint16
	{
		p := &local375
		*p = read16(r)
	}
	(local374) = make([]uint8, local375)
	{
		_, err := io.ReadFull(r, (local374)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        bool
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
	}))(obj)).Itemstring) = string(local374)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Glow
		*p = int8(read8(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).MaxBreath
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).EyeHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).ZoomFOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).UseTextureAlpha
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).DmgTextureMod).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).Shaded
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).ShowOnMinimap
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).NametagBG
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        bool
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
		}))(obj)).RotateSelBox
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local376 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local376]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local377 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local377]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AOSprite) serialize(w io.Writer) {
	for local378 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			x := ((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local378]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOSprite) deserialize(r io.Reader) {
	for local379 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			p := &((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local379]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *Group) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		write16(w, uint16(x))
	}
}

func (obj *Group) deserialize(r io.Reader) {
	var local380 []uint8
	var local381 uint16
	{
		p := &local381
		*p = read16(r)
	}
	(local380) = make([]uint8, local381)
	{
		_, err := io.ReadFull(r, (local380)[:])
		chk(err)
	}
	((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name) = string(local380)
	{
		p := &(*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		*p = int16(read16(r))
	}
}

func (obj *AOAnim) serialize(w io.Writer) {
	for local382 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			x := ((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local382]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAnim) deserialize(r io.Reader) {
	for local383 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			p := &((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local383]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOBonePos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos Vec
			Rot [3]float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local384 := range (*(*(struct {
		Pos Vec
		Rot [3]float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos Vec
				Rot [3]float32
			}))(obj)).Rot)[local384]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *AOBonePos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos Vec
			Rot [3]float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local385 := range (*(*(struct {
		Pos Vec
		Rot [3]float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos Vec
				Rot [3]float32
			}))(obj)).Rot)[local385]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *AOAttach) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if len(([]byte((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local386 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local386]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAttach) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	var local387 []uint8
	var local388 uint16
	{
		p := &local388
		*p = read16(r)
	}
	(local387) = make([]uint8, local388)
	{
		_, err := io.ReadFull(r, (local387)[:])
		chk(err)
	}
	((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone) = string(local387)
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local389 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local389]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOPhysOverride) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Walk
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Jump
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneakGlitch
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).OldSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOPhysOverride) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Walk
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Jump
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).NoSneakGlitch
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Walk, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
		}))(obj)).OldSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *aoType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *aoType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeMetaField) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
	}
	{
		x := (*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *NodeMetaField) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
	}
	{
		p := &(*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *MinimapType) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *MinimapType) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Param1Type) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param1Type) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Param2Type) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param2Type) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DrawType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *DrawType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileDef) serialize(w io.Writer) {
	{
		local390 := uint8(6)
		{
			x := local390
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlignType", err))
		}
	}
}

func (obj *TileDef) deserialize(r io.Reader) {
	{
		var local391 uint8
		local392 := uint8(6)
		{
			p := &local391
			*p = read8(r)
		}
		if local391 != local392 {
			chk(fmt.Errorf("const %v: %v", "uint8(6)", local391))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlignType", err))
		}
	}
}

func (obj *WaveType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *WaveType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LiquidType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *LiquidType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBox) serialize(w io.Writer) {
	{
		local393 := uint8(6)
		{
			x := local393
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).Fixed)))
			write16(w, uint16(x))
		}
		for local394 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local394]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoAll)))
			write16(w, uint16(x))
		}
		for local395 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local395]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoSides)))
			write16(w, uint16(x))
		}
		for local396 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local396]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
}

func (obj *NodeBox) deserialize(r io.Reader) {
	{
		var local397 uint8
		local398 := uint8(6)
		{
			p := &local397
			*p = read8(r)
		}
		if local397 != local398 {
			chk(fmt.Errorf("const %v: %v", "uint8(6)", local397))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		var local399 uint16
		{
			p := &local399
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed) = make([]Box, local399)
		for local400 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local400]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		var local401 uint16
		{
			p := &local401
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll) = make([]Box, local401)
		for local402 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local402]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
		var local403 uint16
		{
			p := &local403
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides) = make([]Box, local403)
		for local404 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local404]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
}

func (obj *SoundDef) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
}

func (obj *SoundDef) deserialize(r io.Reader) {
	var local405 []uint8
	var local406 uint16
	{
		p := &local406
		*p = read16(r)
	}
	(local405) = make([]uint8, local406)
	{
		_, err := io.ReadFull(r, (local405)[:])
		chk(err)
	}
	((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name) = string(local405)
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AlphaUse) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlphaUse) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Keys) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *Keys) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *MapBlkFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *MapBlkFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LitFromBlks) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *LitFromBlks) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AOInitData) serialize(w io.Writer) {
	{
		local407 := uint8(1)
		{
			x := local407
			write8(w, uint8(x))
		}
	}
	if len(([]byte((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local408 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			x := ((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local408]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			if len(x) > math.MaxUint8 {
				chk(ErrTooLong)
			}
			write8(w, uint8(len(x)))
			for _, msg := range x {
				var b bytes.Buffer
				chk(writeAOMsg(&b, msg))
				if b.Len() > math.MaxUint32 {
					chk(ErrTooLong)
				}
				write32(w, uint32(b.Len()))
				_, err := b.WriteTo(w)
				chk(err)
			}
		}
	}
}

func (obj *AOInitData) deserialize(r io.Reader) {
	{
		var local409 uint8
		local410 := uint8(1)
		{
			p := &local409
			*p = read8(r)
		}
		if local409 != local410 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local409))
		}
	}
	var local411 []uint8
	var local412 uint16
	{
		p := &local412
		*p = read16(r)
	}
	(local411) = make([]uint8, local412)
	{
		_, err := io.ReadFull(r, (local411)[:])
		chk(err)
	}
	((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name) = string(local411)
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local413 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			p := &((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local413]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			*p = make([]AOMsg, read8(r))
			for i := range *p {
				r := &io.LimitedReader{R: r, N: int64(read32(r))}
				msg, err := readAOMsg(r)
				chk(err)
				(*p)[i] = msg
				if r.N > 0 {
					chk(fmt.Errorf("%d bytes of trailing data", r.N))
				}
			}
		}
	}
}

func (obj *ItemType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ItemType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ToolCaps) serialize(w io.Writer) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCap

		//mt:len32
		DmgGroups []Group

		//mt:32tou16
		PunchUses int32
	}))(obj)); false {
		{
			x := (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		/*
			if r.N > 0 { (*(*(struct {
				//mt:if _ = %s; false
				NonNil	bool

				AttackCooldown	float32
				MaxDropLvl	int16

				//mt:len32
				GroupCaps	[]ToolGroupCap

				//mt:len32
				DmgGroups	[]Group

				//mt:32tou16
				PunchUses	int32
			}))(obj)).NonNil = true}; /*
		*/{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil {
				{
					local414 := uint8(5)
					{
						x := local414
						write8(w, uint8(x))
					}
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).AttackCooldown
					write32(w, math.Float32bits(x))
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).MaxDropLvl
					write16(w, uint16(x))
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).GroupCaps)))
					write32(w, uint32(x))
				}
				for local415 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).GroupCaps)[local415]).serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolGroupCap", err))
					}
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).DmgGroups)))
					write32(w, uint32(x))
				}
				for local416 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).DmgGroups)[local416]).serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
					}
				}
				{
					x := uint16((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).PunchUses)
					write16(w, uint16(x))
				}
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToolCaps) deserialize(r io.Reader) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCap

		//mt:len32
		DmgGroups []Group

		//mt:32tou16
		PunchUses int32
	}))(obj)); false {
		{
			p := &(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		if r.N > 0 {
			(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil = true
		} /**/
		{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil {
				{
					var local417 uint8
					local418 := uint8(5)
					{
						p := &local417
						*p = read8(r)
					}
					if local417 != local418 {
						chk(fmt.Errorf("const %v: %v", "uint8(5)", local417))
					}
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).AttackCooldown
					*p = math.Float32frombits(read32(r))
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).MaxDropLvl
					*p = int16(read16(r))
				}
				var local419 uint32
				{
					p := &local419
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps) = make([]ToolGroupCap, local419)
				for local420 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).GroupCaps)[local420]).deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolGroupCap", err))
					}
				}
				var local421 uint32
				{
					p := &local421
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups) = make([]Group, local421)
				for local422 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).DmgGroups)[local422]).deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
					}
				}
				var local423 uint16
				{
					p := &local423
					*p = read16(r)
				}
				(*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).PunchUses = int32(local423)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *AnimType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AnimType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *RangeF32) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Min
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Max
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Bias
		write32(w, math.Float32bits(x))
	}
}

func (obj *RangeF32) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Min
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Max
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Bias
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ParticleTextureFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ParticleTextureFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TweenF32) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Start, End float32
		}))(obj)).Start
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Start, End float32
		}))(obj)).End
		write32(w, math.Float32bits(x))
	}
}

func (obj *TweenF32) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Start, End float32
		}))(obj)).Start
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Start, End float32
		}))(obj)).End
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *TweenV2F32) serialize(w io.Writer) {
	for local424 := range (*(*(struct {
		Start, End [2]float32
	}))(obj)).Start {
		{
			x := ((*(*(struct {
				Start, End [2]float32
			}))(obj)).Start)[local424]
			write32(w, math.Float32bits(x))
		}
	}
	for local425 := range (*(*(struct {
		Start, End [2]float32
	}))(obj)).End {
		{
			x := ((*(*(struct {
				Start, End [2]float32
			}))(obj)).End)[local425]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TweenV2F32) deserialize(r io.Reader) {
	for local426 := range (*(*(struct {
		Start, End [2]float32
	}))(obj)).Start {
		{
			p := &((*(*(struct {
				Start, End [2]float32
			}))(obj)).Start)[local426]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local427 := range (*(*(struct {
		Start, End [2]float32
	}))(obj)).End {
		{
			p := &((*(*(struct {
				Start, End [2]float32
			}))(obj)).End)[local427]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *HUDType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Box) serialize(w io.Writer) {
	for local428 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local428]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
		}
	}
}

func (obj *Box) deserialize(r io.Reader) {
	for local429 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local429]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
		}
	}
}

func (obj *TileFlags) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *TileFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AlignType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlignType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBoxType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *NodeBoxType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DirBoxes) serialize(w io.Writer) {
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Top)))
		write16(w, uint16(x))
	}
	for local430 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local430]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Bot)))
		write16(w, uint16(x))
	}
	for local431 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local431]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Front)))
		write16(w, uint16(x))
	}
	for local432 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local432]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Left)))
		write16(w, uint16(x))
	}
	for local433 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local433]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Back)))
		write16(w, uint16(x))
	}
	for local434 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local434]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Right)))
		write16(w, uint16(x))
	}
	for local435 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local435]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
}

func (obj *DirBoxes) deserialize(r io.Reader) {
	var local436 uint16
	{
		p := &local436
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top) = make([]Box, local436)
	for local437 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local437]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local438 uint16
	{
		p := &local438
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot) = make([]Box, local438)
	for local439 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local439]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local440 uint16
	{
		p := &local440
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front) = make([]Box, local440)
	for local441 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local441]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local442 uint16
	{
		p := &local442
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left) = make([]Box, local442)
	for local443 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local443]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local444 uint16
	{
		p := &local444
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back) = make([]Box, local444)
	for local445 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local445]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local446 uint16
	{
		p := &local446
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right) = make([]Box, local446)
	for local447 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local447]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
}

func (obj *ToolGroupCap) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := int16((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Uses)
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Times)))
		write32(w, uint32(x))
	}
	for local448 := range (*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name string

				//mt:32to16
				Uses int32

				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local448]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DigTime", err))
		}
	}
}

func (obj *ToolGroupCap) deserialize(r io.Reader) {
	var local449 []uint8
	var local450 uint16
	{
		p := &local450
		*p = read16(r)
	}
	(local449) = make([]uint8, local450)
	{
		_, err := io.ReadFull(r, (local449)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name) = string(local449)
	var local451 int16
	{
		p := &local451
		*p = int16(read16(r))
	}
	(*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Uses = int32(local451)
	{
		p := &(*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		*p = int16(read16(r))
	}
	var local452 uint32
	{
		p := &local452
		*p = read32(r)
	}
	((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times) = make([]DigTime, local452)
	for local453 := range (*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name string

				//mt:32to16
				Uses int32

				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local453]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DigTime", err))
		}
	}
}

func (obj *DigTime) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		write32(w, math.Float32bits(x))
	}
}

func (obj *DigTime) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		*p = int16(read16(r))
	}
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		*p = math.Float32frombits(read32(r))
	}
}

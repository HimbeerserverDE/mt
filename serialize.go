// Code generated by mkserialize.sh; DO NOT EDIT.

package mt

import (
	"bytes"
	"compress/zlib"
	"crypto/sha1"
	"errors"
	"fmt"
	"image/color"
	"io"
	"math"
	"sort"
	"unicode/utf16"

	"github.com/klauspost/compress/zstd"
)

func write8(w io.Writer, x uint8) {
	_, err := w.Write([]byte{x})
	chk(err)
}

func write16(w io.Writer, x uint16) {
	buf := make([]byte, 2)
	be.PutUint16(buf, x)
	_, err := w.Write(buf)
	chk(err)
}

func write32(w io.Writer, x uint32) {
	buf := make([]byte, 4)
	be.PutUint32(buf, x)
	_, err := w.Write(buf)
	chk(err)
}

func write64(w io.Writer, x uint64) {
	buf := make([]byte, 8)
	be.PutUint64(buf, x)
	_, err := w.Write(buf)
	chk(err)
}
func readBuf(r io.Reader, n int) []byte {
	buf := make([]byte, n)
	_, err := io.ReadFull(r, buf)
	chk(err)
	return buf
}

func read8(r io.Reader) uint8   { return readBuf(r, 1)[0] }
func read16(r io.Reader) uint16 { return be.Uint16(readBuf(r, 2)) }
func read32(r io.Reader) uint32 { return be.Uint32(readBuf(r, 4)) }
func read64(r io.Reader) uint64 { return be.Uint64(readBuf(r, 8)) }

func (obj *ToSrvNil) serialize(w io.Writer) {
}

func (obj *ToSrvNil) deserialize(r io.Reader) {
}

func (obj *ToSrvInit) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).PlayerName))[:])
		chk(err)
	}
	if err := pcall(func() {
		{
			x := (*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).SupportedCompression).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MinProtoVer
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			SerializeVer             uint8
			SupportedCompression     CompressionModes
			MinProtoVer, MaxProtoVer uint16
			PlayerName               string

			//mt:opt
			SendFullItemMeta bool
		}))(obj)).MaxProtoVer
		*p = read16(r)
	}
	var local1 []uint8
	var local2 uint16
	{
		p := &local2
		*p = read16(r)
	}
	(local1) = make([]uint8, local2)
	{
		_, err := io.ReadFull(r, (local1)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer             uint8
		SupportedCompression     CompressionModes
		MinProtoVer, MaxProtoVer uint16
		PlayerName               string

		//mt:opt
		SendFullItemMeta bool
	}))(obj)).PlayerName) = string(local1)
	if err := pcall(func() {
		{
			p := &(*(*(struct {
				SerializeVer             uint8
				SupportedCompression     CompressionModes
				MinProtoVer, MaxProtoVer uint16
				PlayerName               string

				//mt:opt
				SendFullItemMeta bool
			}))(obj)).SendFullItemMeta
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}); err != nil && err != io.EOF {
		chk(err)
	}
}

func (obj *ToSrvInit2) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Lang string
	}))(obj)).Lang))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Lang string
		}))(obj)).Lang))[:])
		chk(err)
	}
}

func (obj *ToSrvInit2) deserialize(r io.Reader) {
	var local3 []uint8
	var local4 uint16
	{
		p := &local4
		*p = read16(r)
	}
	(local3) = make([]uint8, local4)
	{
		_, err := io.ReadFull(r, (local3)[:])
		chk(err)
	}
	((*(*(struct {
		Lang string
	}))(obj)).Lang) = string(local3)
}

func (obj *ToSrvJoinModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvJoinModChan) deserialize(r io.Reader) {
	var local5 []uint8
	var local6 uint16
	{
		p := &local6
		*p = read16(r)
	}
	(local5) = make([]uint8, local6)
	{
		_, err := io.ReadFull(r, (local5)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local5)
}

func (obj *ToSrvLeaveModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToSrvLeaveModChan) deserialize(r io.Reader) {
	var local7 []uint8
	var local8 uint16
	{
		p := &local8
		*p = read16(r)
	}
	(local7) = make([]uint8, local8)
	{
		_, err := io.ReadFull(r, (local7)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
	}))(obj)).Channel) = string(local7)
}

func (obj *ToSrvMsgModChan) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToSrvMsgModChan) deserialize(r io.Reader) {
	var local9 []uint8
	var local10 uint16
	{
		p := &local10
		*p = read16(r)
	}
	(local9) = make([]uint8, local10)
	{
		_, err := io.ReadFull(r, (local9)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Channel) = string(local9)
	var local11 []uint8
	var local12 uint16
	{
		p := &local12
		*p = read16(r)
	}
	(local11) = make([]uint8, local12)
	{
		_, err := io.ReadFull(r, (local11)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Msg     string
	}))(obj)).Msg) = string(local11)
}

func (obj *ToSrvPlayerPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvPlayerPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos PlayerPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvGotBlks) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local13 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local14 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local13] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local13])[local14]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvGotBlks) deserialize(r io.Reader) {
	var local15 uint8
	{
		p := &local15
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local15)
	for local16 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local17 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local16] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local16])[local17]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)))
		write8(w, uint8(x))
	}
	for local18 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local19 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local18] {
			{
				x := (((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local18])[local19]
				write16(w, uint16(x))
			}
		}
	}
}

func (obj *ToSrvDeletedBlks) deserialize(r io.Reader) {
	var local20 uint8
	{
		p := &local20
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks) = make([][3]int16, local20)
	for local21 := range (*(*(struct {
		//mt:len8
		Blks [][3]int16
	}))(obj)).Blks {
		for local22 := range ((*(*(struct {
			//mt:len8
			Blks [][3]int16
		}))(obj)).Blks)[local21] {
			{
				p := &(((*(*(struct {
					//mt:len8
					Blks [][3]int16
				}))(obj)).Blks)[local21])[local22]
				*p = int16(read16(r))
			}
		}
	}
}

func (obj *ToSrvInvAction) serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Action string
		}))(obj)).Action))[:])
		chk(err)
	}
}

func (obj *ToSrvInvAction) deserialize(r io.Reader) {
	var local23 []uint8
	{
		var err error
		(local23), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Action string
	}))(obj)).Action) = string(local23)
}

func (obj *ToSrvChatMsg) serialize(w io.Writer) {
	local24 := utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg))
	if len((local24)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local24)))
		write16(w, uint16(x))
	}
	for local25 := range local24 {
		{
			x := (local24)[local25]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToSrvChatMsg) deserialize(r io.Reader) {
	var local26 []uint16
	var local27 uint16
	{
		p := &local27
		*p = read16(r)
	}
	(local26) = make([]uint16, local27)
	for local28 := range local26 {
		{
			p := &(local26)[local28]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Msg string
	}))(obj)).Msg = string(utf16.Decode(local26))
}

func (obj *ToSrvFallDmg) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount uint16
		}))(obj)).Amount
		write16(w, uint16(x))
	}
}

func (obj *ToSrvFallDmg) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount uint16
		}))(obj)).Amount
		*p = read16(r)
	}
}

func (obj *ToSrvSelectItem) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Slot uint16
		}))(obj)).Slot
		write16(w, uint16(x))
	}
}

func (obj *ToSrvSelectItem) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Slot uint16
		}))(obj)).Slot
		*p = read16(r)
	}
}

func (obj *ToSrvRespawn) serialize(w io.Writer) {
}

func (obj *ToSrvRespawn) deserialize(r io.Reader) {
}

func (obj *ToSrvInteract) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Interaction", err))
	}
	{
		x := (*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		write16(w, uint16(x))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			chk(writePointedThing(w, x))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvInteract) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Action).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Interaction", err))
	}
	{
		p := &(*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).ItemSlot
		*p = read16(r)
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				Action   Interaction
				ItemSlot uint16
				//mt:lenhdr 32
				Pointed PointedThing
				//mt:end
				Pos PlayerPos
			}))(obj)).Pointed
			{
				var err error
				*p, err = readPointedThing(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Action   Interaction
			ItemSlot uint16
			//mt:lenhdr 32
			Pointed PointedThing
			//mt:end
			Pos PlayerPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPos", err))
	}
}

func (obj *ToSrvRemovedSounds) serialize(w io.Writer) {
	if len(((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			IDs []SoundID
		}))(obj)).IDs)))
		write16(w, uint16(x))
	}
	for local29 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local29]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvRemovedSounds) deserialize(r io.Reader) {
	var local30 uint16
	{
		p := &local30
		*p = read16(r)
	}
	((*(*(struct {
		IDs []SoundID
	}))(obj)).IDs) = make([]SoundID, local30)
	for local31 := range (*(*(struct {
		IDs []SoundID
	}))(obj)).IDs {
		if err := pcall(func() {
			(((*(*(struct {
				IDs []SoundID
			}))(obj)).IDs)[local31]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) serialize(w io.Writer) {
	for local32 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local32]
			write16(w, uint16(x))
		}
	}
	if len(([]byte((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Pos      [3]int16
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local33 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local33]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvNodeMetaFields) deserialize(r io.Reader) {
	for local34 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Pos)[local34]
			*p = int16(read16(r))
		}
	}
	var local35 []uint8
	var local36 uint16
	{
		p := &local36
		*p = read16(r)
	}
	(local35) = make([]uint8, local36)
	{
		_, err := io.ReadFull(r, (local35)[:])
		chk(err)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local35)
	var local37 uint16
	{
		p := &local37
		*p = read16(r)
	}
	((*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local37)
	for local38 := range (*(*(struct {
		Pos      [3]int16
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Pos      [3]int16
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local38]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Formname))[:])
		chk(err)
	}
	if len(((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Formname string
			Fields   []Field
		}))(obj)).Fields)))
		write16(w, uint16(x))
	}
	for local39 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local39]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvInvFields) deserialize(r io.Reader) {
	var local40 []uint8
	var local41 uint16
	{
		p := &local41
		*p = read16(r)
	}
	(local40) = make([]uint8, local41)
	{
		_, err := io.ReadFull(r, (local40)[:])
		chk(err)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Formname) = string(local40)
	var local42 uint16
	{
		p := &local42
		*p = read16(r)
	}
	((*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields) = make([]Field, local42)
	for local43 := range (*(*(struct {
		Formname string
		Fields   []Field
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				Formname string
				Fields   []Field
			}))(obj)).Fields)[local43]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
		}
	}
}

func (obj *ToSrvReqMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		Filenames []string
	}))(obj)).Filenames)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)))
		write16(w, uint16(x))
	}
	for local44 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		if len(([]byte(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local44]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Filenames []string
			}))(obj)).Filenames)[local44]))[:])
			chk(err)
		}
	}
}

func (obj *ToSrvReqMedia) deserialize(r io.Reader) {
	var local45 uint16
	{
		p := &local45
		*p = read16(r)
	}
	((*(*(struct {
		Filenames []string
	}))(obj)).Filenames) = make([]string, local45)
	for local46 := range (*(*(struct {
		Filenames []string
	}))(obj)).Filenames {
		var local47 []uint8
		var local48 uint16
		{
			p := &local48
			*p = read16(r)
		}
		(local47) = make([]uint8, local48)
		{
			_, err := io.ReadFull(r, (local47)[:])
			chk(err)
		}
		(((*(*(struct {
			Filenames []string
		}))(obj)).Filenames)[local46]) = string(local47)
	}
}

func (obj *ToSrvHaveMedia) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens)) > math.MaxUint8 {
		chk(ErrTooLong)
	}
	{
		x := uint8(len(((*(*(struct {
			//mt:len8
			Tokens []uint32
		}))(obj)).Tokens)))
		write8(w, uint8(x))
	}
	for local49 := range (*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens {
		{
			x := ((*(*(struct {
				//mt:len8
				Tokens []uint32
			}))(obj)).Tokens)[local49]
			write32(w, uint32(x))
		}
	}
}

func (obj *ToSrvHaveMedia) deserialize(r io.Reader) {
	var local50 uint8
	{
		p := &local50
		*p = read8(r)
	}
	((*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens) = make([]uint32, local50)
	for local51 := range (*(*(struct {
		//mt:len8
		Tokens []uint32
	}))(obj)).Tokens {
		{
			p := &((*(*(struct {
				//mt:len8
				Tokens []uint32
			}))(obj)).Tokens)[local51]
			*p = read32(r)
		}
	}
}

func (obj *ToSrvCltReady) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		write8(w, uint8(x))
	}
	if len(([]byte((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Version))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		write16(w, uint16(x))
	}
}

func (obj *ToSrvCltReady) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Major
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Minor
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Patch
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Reserved
		*p = read8(r)
	}
	var local52 []uint8
	var local53 uint16
	{
		p := &local53
		*p = read16(r)
	}
	(local52) = make([]uint8, local53)
	{
		_, err := io.ReadFull(r, (local52)[:])
		chk(err)
	}
	((*(*(struct {
		// Version information.
		Major, Minor, Patch uint8
		Reserved            uint8
		Version             string
		Formspec            uint16
	}))(obj)).Version) = string(local52)
	{
		p := &(*(*(struct {
			// Version information.
			Major, Minor, Patch uint8
			Reserved            uint8
			Version             string
			Formspec            uint16
		}))(obj)).Formspec
		*p = read16(r)
	}
}

func (obj *ToSrvFirstSRP) serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvFirstSRP) deserialize(r io.Reader) {
	var local54 uint16
	{
		p := &local54
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Salt) = make([]byte, local54)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local55 uint16
	{
		p := &local55
		*p = read16(r)
	}
	((*(*(struct {
		Salt        []byte
		Verifier    []byte
		EmptyPasswd bool
	}))(obj)).Verifier) = make([]byte, local55)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).Verifier)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Salt        []byte
			Verifier    []byte
			EmptyPasswd bool
		}))(obj)).EmptyPasswd
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesA) serialize(w io.Writer) {
	if len(((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvSRPBytesA) deserialize(r io.Reader) {
	var local56 uint16
	{
		p := &local56
		*p = read16(r)
	}
	((*(*(struct {
		A      []byte
		NoSHA1 bool
	}))(obj)).A) = make([]byte, local56)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).A)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			A      []byte
			NoSHA1 bool
		}))(obj)).NoSHA1
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToSrvSRPBytesM) serialize(w io.Writer) {
	if len(((*(*(struct {
		M []byte
	}))(obj)).M)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			M []byte
		}))(obj)).M)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToSrvSRPBytesM) deserialize(r io.Reader) {
	var local57 uint16
	{
		p := &local57
		*p = read16(r)
	}
	((*(*(struct {
		M []byte
	}))(obj)).M) = make([]byte, local57)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			M []byte
		}))(obj)).M)[:])
		chk(err)
	}
}

func (obj *ToSrvCltInfo) serialize(w io.Writer) {
	for local58 := range (*(*(struct {
		RenderTargetSize [2]uint32
		GUIScaling       float32
		HUDScaling       float32
		MaxFormspecInfo  [2]float32
		TouchControls    bool
	}))(obj)).RenderTargetSize {
		{
			x := ((*(*(struct {
				RenderTargetSize [2]uint32
				GUIScaling       float32
				HUDScaling       float32
				MaxFormspecInfo  [2]float32
				TouchControls    bool
			}))(obj)).RenderTargetSize)[local58]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
			TouchControls    bool
		}))(obj)).GUIScaling
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
			TouchControls    bool
		}))(obj)).HUDScaling
		write32(w, math.Float32bits(x))
	}
	for local59 := range (*(*(struct {
		RenderTargetSize [2]uint32
		GUIScaling       float32
		HUDScaling       float32
		MaxFormspecInfo  [2]float32
		TouchControls    bool
	}))(obj)).MaxFormspecInfo {
		{
			x := ((*(*(struct {
				RenderTargetSize [2]uint32
				GUIScaling       float32
				HUDScaling       float32
				MaxFormspecInfo  [2]float32
				TouchControls    bool
			}))(obj)).MaxFormspecInfo)[local59]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
			TouchControls    bool
		}))(obj)).TouchControls
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToSrvCltInfo) deserialize(r io.Reader) {
	for local60 := range (*(*(struct {
		RenderTargetSize [2]uint32
		GUIScaling       float32
		HUDScaling       float32
		MaxFormspecInfo  [2]float32
		TouchControls    bool
	}))(obj)).RenderTargetSize {
		{
			p := &((*(*(struct {
				RenderTargetSize [2]uint32
				GUIScaling       float32
				HUDScaling       float32
				MaxFormspecInfo  [2]float32
				TouchControls    bool
			}))(obj)).RenderTargetSize)[local60]
			*p = read32(r)
		}
	}
	{
		p := &(*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
			TouchControls    bool
		}))(obj)).GUIScaling
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
			TouchControls    bool
		}))(obj)).HUDScaling
		*p = math.Float32frombits(read32(r))
	}
	for local61 := range (*(*(struct {
		RenderTargetSize [2]uint32
		GUIScaling       float32
		HUDScaling       float32
		MaxFormspecInfo  [2]float32
		TouchControls    bool
	}))(obj)).MaxFormspecInfo {
		{
			p := &((*(*(struct {
				RenderTargetSize [2]uint32
				GUIScaling       float32
				HUDScaling       float32
				MaxFormspecInfo  [2]float32
				TouchControls    bool
			}))(obj)).MaxFormspecInfo)[local61]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			RenderTargetSize [2]uint32
			GUIScaling       float32
			HUDScaling       float32
			MaxFormspecInfo  [2]float32
			TouchControls    bool
		}))(obj)).TouchControls
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltHello) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		x := (*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	if len(([]byte((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Username))[:])
		chk(err)
	}
}

func (obj *ToCltHello) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).SerializeVer
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).Compression).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CompressionModes", err))
	}
	{
		p := &(*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).ProtoVer
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			SerializeVer uint8
			Compression  CompressionModes
			ProtoVer     uint16
			AuthMethods
			Username string
		}))(obj)).AuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	var local62 []uint8
	var local63 uint16
	{
		p := &local63
		*p = read16(r)
	}
	(local62) = make([]uint8, local63)
	{
		_, err := io.ReadFull(r, (local62)[:])
		chk(err)
	}
	((*(*(struct {
		SerializeVer uint8
		Compression  CompressionModes
		ProtoVer     uint16
		AuthMethods
		Username string
	}))(obj)).Username) = string(local62)
}

func (obj *ToCltAcceptAuth) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		write64(w, uint64(x))
	}
	{
		x := (*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptAuth) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).PlayerPos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).MapSeed
		*p = read64(r)
	}
	{
		p := &(*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SendInterval
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			// The client does the equivalent of
			//	PlayerPos[1] -= 5
			// before using PlayerPos.
			PlayerPos Pos

			MapSeed         uint64
			SendInterval    float32
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
}

func (obj *ToCltAcceptSudoMode) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	{
		local64 := [15]byte{}
		{
			_, err := w.Write((local64)[:])
			chk(err)
		}
	}
}

func (obj *ToCltAcceptSudoMode) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			SudoAuthMethods AuthMethods
		}))(obj)).SudoAuthMethods).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AuthMethods", err))
	}
	{
		var local65 [15]byte
		local66 := [15]byte{}
		{
			_, err := io.ReadFull(r, (local65)[:])
			chk(err)
		}
		if local65 != local66 {
			chk(fmt.Errorf("const %v: %v", "[15]byte{}", local65))
		}
	}
}

func (obj *ToCltDenySudoMode) serialize(w io.Writer) {
}

func (obj *ToCltDenySudoMode) deserialize(r io.Reader) {
}

func (obj *ToCltKick) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Reason KickReason

			Custom    string
			Reconnect bool
		}))(obj)).Reason).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.KickReason", err))
	}
	if !((*(*(struct {
		Reason KickReason

		Custom    string
		Reconnect bool
	}))(obj)).Reason < maxKickReason) {
		chk(errors.New("assertion failed: %s.Reason < maxKickReason"))
	}
	if len(([]byte((*(*(struct {
		Reason KickReason

		Custom    string
		Reconnect bool
	}))(obj)).Custom))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Reason KickReason

			Custom    string
			Reconnect bool
		}))(obj)).Custom))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Reason KickReason

			Custom    string
			Reconnect bool
		}))(obj)).Custom))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Reason KickReason

			Custom    string
			Reconnect bool
		}))(obj)).Reconnect
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltKick) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Reason KickReason

			Custom    string
			Reconnect bool
		}))(obj)).Reason).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.KickReason", err))
	}
	if !((*(*(struct {
		Reason KickReason

		Custom    string
		Reconnect bool
	}))(obj)).Reason < maxKickReason) {
		chk(errors.New("assertion failed: %s.Reason < maxKickReason"))
	}
	var local67 []uint8
	var local68 uint16
	{
		p := &local68
		*p = read16(r)
	}
	(local67) = make([]uint8, local68)
	{
		_, err := io.ReadFull(r, (local67)[:])
		chk(err)
	}
	((*(*(struct {
		Reason KickReason

		Custom    string
		Reconnect bool
	}))(obj)).Custom) = string(local67)
	{
		p := &(*(*(struct {
			Reason KickReason

			Custom    string
			Reconnect bool
		}))(obj)).Reconnect
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltBlkData) serialize(w io.Writer) {
	for local69 := range (*(*(struct {
		Blkpos [3]int16
		//mt:zstd
		Blk MapBlk
	}))(obj)).Blkpos {
		{
			x := ((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blkpos)[local69]
			write16(w, uint16(x))
		}
	}
	{
		w, err := zstd.NewWriter(w)
		chk(err)
		if err := pcall(func() {
			((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blk).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlk", err))
		}
		chk(w.Close())
	}
}

func (obj *ToCltBlkData) deserialize(r io.Reader) {
	for local70 := range (*(*(struct {
		Blkpos [3]int16
		//mt:zstd
		Blk MapBlk
	}))(obj)).Blkpos {
		{
			p := &((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blkpos)[local70]
			*p = int16(read16(r))
		}
	}
	{
		r, err := zstd.NewReader(byteReader{r})
		chk(err)
		if err := pcall(func() {
			((*(*(struct {
				Blkpos [3]int16
				//mt:zstd
				Blk MapBlk
			}))(obj)).Blk).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlk", err))
		}
		r.Close()
	}
}

func (obj *ToCltAddNode) serialize(w io.Writer) {
	for local71 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local71]
			write16(w, uint16(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Node", err))
	}
	{
		x := (*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltAddNode) deserialize(r io.Reader) {
	for local72 := range (*(*(struct {
		Pos [3]int16
		Node
		KeepMeta bool
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
				Node
				KeepMeta bool
			}))(obj)).Pos)[local72]
			*p = int16(read16(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).Node).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Node", err))
	}
	{
		p := &(*(*(struct {
			Pos [3]int16
			Node
			KeepMeta bool
		}))(obj)).KeepMeta
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltRemoveNode) serialize(w io.Writer) {
	for local73 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local73]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltRemoveNode) deserialize(r io.Reader) {
	for local74 := range (*(*(struct {
		Pos [3]int16
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos [3]int16
			}))(obj)).Pos)[local74]
			*p = int16(read16(r))
		}
	}
}

func (obj *ToCltInv) serialize(w io.Writer) {
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltInv) deserialize(r io.Reader) {
	var local75 []uint8
	{
		var err error
		(local75), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local75)
}

func (obj *ToCltTimeOfDay) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltTimeOfDay) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Time
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Time  uint16  // %24000
			Speed float32 // Speed times faster than real time
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltCSMRestrictionFlags) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CSMRestrictionFlags", err))
	}
	{
		x := (*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		write32(w, uint32(x))
	}
}

func (obj *ToCltCSMRestrictionFlags) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.CSMRestrictionFlags", err))
	}
	{
		p := &(*(*(struct {
			Flags CSMRestrictionFlags

			// MapRange is the maximum distance from the player CSMs can read the map
			// if Flags&LimitMapRange != 0.
			MapRange uint32
		}))(obj)).MapRange
		*p = read32(r)
	}
}

func (obj *ToCltAddPlayerVel) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltAddPlayerVel) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Vel Vec
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltMediaPush) serialize(w io.Writer) {
	{
		local76 := uint16(sha1.Size)
		{
			x := local76
			write16(w, uint16(x))
		}
	}
	{
		_, err := w.Write(((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			Ephemeral     bool
			CallbackToken uint32
		}))(obj)).SHA1)[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1          [sha1.Size]byte
		Filename      string
		Ephemeral     bool
		CallbackToken uint32
	}))(obj)).Filename))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			Ephemeral     bool
			CallbackToken uint32
		}))(obj)).Filename))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			Ephemeral     bool
			CallbackToken uint32
		}))(obj)).Filename))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			Ephemeral     bool
			CallbackToken uint32
		}))(obj)).Ephemeral
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			Ephemeral     bool
			CallbackToken uint32
		}))(obj)).CallbackToken
		write32(w, uint32(x))
	}
}

func (obj *ToCltMediaPush) deserialize(r io.Reader) {
	{
		var local77 uint16
		local78 := uint16(sha1.Size)
		{
			p := &local77
			*p = read16(r)
		}
		if local77 != local78 {
			chk(fmt.Errorf("const %v: %v", "uint16(sha1.Size)", local77))
		}
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			Ephemeral     bool
			CallbackToken uint32
		}))(obj)).SHA1)[:])
		chk(err)
	}
	var local79 []uint8
	var local80 uint16
	{
		p := &local80
		*p = read16(r)
	}
	(local79) = make([]uint8, local80)
	{
		_, err := io.ReadFull(r, (local79)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:const uint16(sha1.Size)
		SHA1          [sha1.Size]byte
		Filename      string
		Ephemeral     bool
		CallbackToken uint32
	}))(obj)).Filename) = string(local79)
	{
		p := &(*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			Ephemeral     bool
			CallbackToken uint32
		}))(obj)).Ephemeral
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			//mt:const uint16(sha1.Size)
			SHA1          [sha1.Size]byte
			Filename      string
			Ephemeral     bool
			CallbackToken uint32
		}))(obj)).CallbackToken
		*p = read32(r)
	}
}

func (obj *ToCltChatMsg) serialize(w io.Writer) {
	{
		local81 := uint8(1)
		{
			x := local81
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ChatMsgType", err))
	}
	local82 := utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender))
	if len((local82)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local82)))
		write16(w, uint16(x))
	}
	for local83 := range local82 {
		{
			x := (local82)[local83]
			write16(w, uint16(x))
		}
	}
	local84 := utf16.Encode([]rune((*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text))
	if len((local84)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local84)))
		write16(w, uint16(x))
	}
	for local85 := range local84 {
		{
			x := (local84)[local85]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		write64(w, uint64(x))
	}
}

func (obj *ToCltChatMsg) deserialize(r io.Reader) {
	{
		var local86 uint8
		local87 := uint8(1)
		{
			p := &local86
			*p = read8(r)
		}
		if local86 != local87 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local86))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ChatMsgType", err))
	}
	var local88 []uint16
	var local89 uint16
	{
		p := &local89
		*p = read16(r)
	}
	(local88) = make([]uint16, local89)
	for local90 := range local88 {
		{
			p := &(local88)[local90]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Sender = string(utf16.Decode(local88))
	var local91 []uint16
	var local92 uint16
	{
		p := &local92
		*p = read16(r)
	}
	(local91) = make([]uint16, local92)
	for local93 := range local91 {
		{
			p := &(local91)[local93]
			*p = read16(r)
		}
	}
	(*(*(struct {
		Type ChatMsgType

		//mt:utf16
		Sender, Text string

		Timestamp int64 // Unix time.
	}))(obj)).Text = string(utf16.Decode(local91))
	{
		p := &(*(*(struct {
			Type ChatMsgType

			//mt:utf16
			Sender, Text string

			Timestamp int64 // Unix time.
		}))(obj)).Timestamp
		*p = int64(read64(r))
	}
}

func (obj *ToCltAORmAdd) serialize(w io.Writer) {
	if len(((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []AOAdd
		}))(obj)).Remove)))
		write16(w, uint16(x))
	}
	for local94 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Remove)[local94]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
		}
	}
	if len(((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Remove []AOID
			Add    []AOAdd
		}))(obj)).Add)))
		write16(w, uint16(x))
	}
	for local95 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Add)[local95]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAdd", err))
		}
	}
}

func (obj *ToCltAORmAdd) deserialize(r io.Reader) {
	var local96 uint16
	{
		p := &local96
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove) = make([]AOID, local96)
	for local97 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Remove {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Remove)[local97]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
		}
	}
	var local98 uint16
	{
		p := &local98
		*p = read16(r)
	}
	((*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add) = make([]AOAdd, local98)
	for local99 := range (*(*(struct {
		Remove []AOID
		Add    []AOAdd
	}))(obj)).Add {
		if err := pcall(func() {
			(((*(*(struct {
				Remove []AOID
				Add    []AOAdd
			}))(obj)).Add)[local99]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAdd", err))
		}
	}
}

func (obj *ToCltAOMsgs) serialize(w io.Writer) {
	for local100 := range (*(*(struct {
		//mt:raw
		Msgs []IDAOMsg
	}))(obj)).Msgs {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:raw
				Msgs []IDAOMsg
			}))(obj)).Msgs)[local100]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.IDAOMsg", err))
		}
	}
}

func (obj *ToCltAOMsgs) deserialize(r io.Reader) {
	for {
		var local101 IDAOMsg
		err := pcall(func() {
			if err := pcall(func() {
				(local101).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.IDAOMsg", err))
			}
		})
		if err == io.EOF {
			break
		}
		((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs) = append(((*(*(struct {
			//mt:raw
			Msgs []IDAOMsg
		}))(obj)).Msgs), local101)
		chk(err)
	}
}

func (obj *ToCltHP) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP           uint16
			DamageEffect bool
		}))(obj)).HP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			HP           uint16
			DamageEffect bool
		}))(obj)).DamageEffect
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *ToCltHP) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP           uint16
			DamageEffect bool
		}))(obj)).HP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			HP           uint16
			DamageEffect bool
		}))(obj)).DamageEffect
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *ToCltMovePlayer) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovePlayer) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos
			Pitch, Yaw float32
		}))(obj)).Yaw
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltLegacyKick) serialize(w io.Writer) {
	local102 := utf16.Encode([]rune((*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason))
	if len((local102)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len((local102)))
		write16(w, uint16(x))
	}
	for local103 := range local102 {
		{
			x := (local102)[local103]
			write16(w, uint16(x))
		}
	}
}

func (obj *ToCltLegacyKick) deserialize(r io.Reader) {
	var local104 []uint16
	var local105 uint16
	{
		p := &local105
		*p = read16(r)
	}
	(local104) = make([]uint16, local105)
	for local106 := range local104 {
		{
			p := &(local104)[local106]
			*p = read16(r)
		}
	}
	(*(*(struct {
		//mt:utf16
		Reason string
	}))(obj)).Reason = string(utf16.Decode(local104))
}

func (obj *ToCltFOV) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFOV) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).FOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).Multiplier
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			FOV            float32
			Multiplier     bool
			TransitionTime float32
		}))(obj)).TransitionTime
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltDeathScreen) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
}

func (obj *ToCltDeathScreen) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointCam
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			PointCam bool
			PointAt  Pos
		}))(obj)).PointAt).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
}

func (obj *ToCltMedia) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:lenhdr 32
				//mt:zstd
				//mt:raw
				Data []byte
			}
		}))(obj)).N
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:lenhdr 32
				//mt:zstd
				//mt:raw
				Data []byte
			}
		}))(obj)).I
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:lenhdr 32
			//mt:zstd
			//mt:raw
			Data []byte
		}
	}))(obj)).Files)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:lenhdr 32
				//mt:zstd
				//mt:raw
				Data []byte
			}
		}))(obj)).Files)))
		write32(w, uint32(x))
	}
	for local107 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:lenhdr 32
			//mt:zstd
			//mt:raw
			Data []byte
		}
	}))(obj)).Files {
		if len(([]byte((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:lenhdr 32
				//mt:zstd
				//mt:raw
				Data []byte
			}
		}))(obj)).Files)[local107]).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:lenhdr 32
					//mt:zstd
					//mt:raw
					Data []byte
				}
			}))(obj)).Files)[local107]).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((((*(*(struct {
				// N is the total number of ToCltMedia packets.
				// I is the index of this packet.
				N, I uint16

				//mt:len32
				Files []struct {
					Name string

					//mt:lenhdr 32
					//mt:zstd
					//mt:raw
					Data []byte
				}
			}))(obj)).Files)[local107]).Name))[:])
			chk(err)
		}
		{
			ow := w
			w := new(bytes.Buffer)
			{
				w, err := zstd.NewWriter(w)
				chk(err)
				{
					_, err := w.Write(((((*(*(struct {
						// N is the total number of ToCltMedia packets.
						// I is the index of this packet.
						N, I uint16

						//mt:len32
						Files []struct {
							Name string

							//mt:lenhdr 32
							//mt:zstd
							//mt:raw
							Data []byte
						}
					}))(obj)).Files)[local107]).Data)[:])
					chk(err)
				}
				chk(w.Close())
			}
			{
				buf := w
				w := ow
				if len((buf.Bytes())) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len((buf.Bytes())))
					write32(w, uint32(x))
				}
				{
					_, err := w.Write((buf.Bytes())[:])
					chk(err)
				}
			}
		}
	}
}

func (obj *ToCltMedia) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:lenhdr 32
				//mt:zstd
				//mt:raw
				Data []byte
			}
		}))(obj)).N
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:lenhdr 32
				//mt:zstd
				//mt:raw
				Data []byte
			}
		}))(obj)).I
		*p = read16(r)
	}
	var local108 uint32
	{
		p := &local108
		*p = read32(r)
	}
	((*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:lenhdr 32
			//mt:zstd
			//mt:raw
			Data []byte
		}
	}))(obj)).Files) = make([]struct {
		Name string
		Data []byte
	}, local108)
	for local109 := range (*(*(struct {
		// N is the total number of ToCltMedia packets.
		// I is the index of this packet.
		N, I uint16

		//mt:len32
		Files []struct {
			Name string

			//mt:lenhdr 32
			//mt:zstd
			//mt:raw
			Data []byte
		}
	}))(obj)).Files {
		var local110 []uint8
		var local111 uint16
		{
			p := &local111
			*p = read16(r)
		}
		(local110) = make([]uint8, local111)
		{
			_, err := io.ReadFull(r, (local110)[:])
			chk(err)
		}
		((((*(*(struct {
			// N is the total number of ToCltMedia packets.
			// I is the index of this packet.
			N, I uint16

			//mt:len32
			Files []struct {
				Name string

				//mt:lenhdr 32
				//mt:zstd
				//mt:raw
				Data []byte
			}
		}))(obj)).Files)[local109]).Name) = string(local110)
		{
			var n uint32
			{
				p := &n
				*p = read32(r)
			}
			r := &io.LimitedReader{R: r, N: int64(n)}
			{
				r, err := zstd.NewReader(byteReader{r})
				chk(err)
				{
					var err error
					((((*(*(struct {
						// N is the total number of ToCltMedia packets.
						// I is the index of this packet.
						N, I uint16

						//mt:len32
						Files []struct {
							Name string

							//mt:lenhdr 32
							//mt:zstd
							//mt:raw
							Data []byte
						}
					}))(obj)).Files)[local109]).Data), err = io.ReadAll(r)
					chk(err)
				}
				r.Close()
			}
			if r.N > 0 {
				chk(fmt.Errorf("%d bytes of trailing data", r.N))
			}
		}
	}
}

func (obj *ToCltNodeDefs) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w, err := zstd.NewWriter(w)
			chk(err)
			{
				local112 := uint8(1)
				{
					x := local112
					write8(w, uint8(x))
				}
			}
			{
				x := (*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					var b bytes.Buffer
					for i := range x {
						x[i].serialize(&b)
					}
					if b.Len() > math.MaxUint32 {
						chk(ErrTooLong)
					}
					write32(w, uint32(b.Len()))
					_, err := b.WriteTo(w)
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeDefs) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zstd.NewReader(byteReader{r})
			chk(err)
			{
				var local113 uint8
				local114 := uint8(1)
				{
					p := &local113
					*p = read8(r)
				}
				if local113 != local114 {
					chk(fmt.Errorf("const %v: %v", "uint8(1)", local113))
				}
			}
			{
				p := &(*(*(struct {

					// See (de)serialize.fmt.
					Defs []NodeDef
				}))(obj)).Defs
				{ // For ToCltNodeDefs.Defs.
					*p = make([]NodeDef, read16(r))
					r := &io.LimitedReader{R: r, N: int64(read32(r))}
					for i := range *p {
						(*p)[i].deserialize(r)
					}
					if r.N > 0 {
						chk(fmt.Errorf("%d bytes of trailing data", r.N))
					}
				}
			}
			r.Close()
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltAnnounceMedia) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w, err := zstd.NewWriter(w)
			chk(err)
			{
				x := (*(*(struct {
					//mt:lenhdr 32
					//mt:zstd
					N uint32
					//mt:manlen %s.N
					NameLens []uint16

					//mt:raw
					NameData []byte

					//mt:manlen %s.N
					Digests [][sha1.Size]byte

					URL string
				}))(obj)).N
				write32(w, uint32(x))
			}
			for local115 := range (*(*(struct {
				//mt:lenhdr 32
				//mt:zstd
				N uint32
				//mt:manlen %s.N
				NameLens []uint16

				//mt:raw
				NameData []byte

				//mt:manlen %s.N
				Digests [][sha1.Size]byte

				URL string
			}))(obj)).NameLens {
				{
					x := ((*(*(struct {
						//mt:lenhdr 32
						//mt:zstd
						N uint32
						//mt:manlen %s.N
						NameLens []uint16

						//mt:raw
						NameData []byte

						//mt:manlen %s.N
						Digests [][sha1.Size]byte

						URL string
					}))(obj)).NameLens)[local115]
					write16(w, uint16(x))
				}
			}
			{
				_, err := w.Write(((*(*(struct {
					//mt:lenhdr 32
					//mt:zstd
					N uint32
					//mt:manlen %s.N
					NameLens []uint16

					//mt:raw
					NameData []byte

					//mt:manlen %s.N
					Digests [][sha1.Size]byte

					URL string
				}))(obj)).NameData)[:])
				chk(err)
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
	for local116 := range (*(*(struct {
		//mt:lenhdr 32
		//mt:zstd
		N uint32
		//mt:manlen %s.N
		NameLens []uint16

		//mt:raw
		NameData []byte

		//mt:manlen %s.N
		Digests [][sha1.Size]byte

		URL string
	}))(obj)).Digests {
		{
			_, err := w.Write((((*(*(struct {
				//mt:lenhdr 32
				//mt:zstd
				N uint32
				//mt:manlen %s.N
				NameLens []uint16

				//mt:raw
				NameData []byte

				//mt:manlen %s.N
				Digests [][sha1.Size]byte

				URL string
			}))(obj)).Digests)[local116])[:])
			chk(err)
		}
	}
	if len(([]byte((*(*(struct {
		//mt:lenhdr 32
		//mt:zstd
		N uint32
		//mt:manlen %s.N
		NameLens []uint16

		//mt:raw
		NameData []byte

		//mt:manlen %s.N
		Digests [][sha1.Size]byte

		URL string
	}))(obj)).URL))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:lenhdr 32
			//mt:zstd
			N uint32
			//mt:manlen %s.N
			NameLens []uint16

			//mt:raw
			NameData []byte

			//mt:manlen %s.N
			Digests [][sha1.Size]byte

			URL string
		}))(obj)).URL))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:lenhdr 32
			//mt:zstd
			N uint32
			//mt:manlen %s.N
			NameLens []uint16

			//mt:raw
			NameData []byte

			//mt:manlen %s.N
			Digests [][sha1.Size]byte

			URL string
		}))(obj)).URL))[:])
		chk(err)
	}
}

func (obj *ToCltAnnounceMedia) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zstd.NewReader(byteReader{r})
			chk(err)
			{
				p := &(*(*(struct {
					//mt:lenhdr 32
					//mt:zstd
					N uint32
					//mt:manlen %s.N
					NameLens []uint16

					//mt:raw
					NameData []byte

					//mt:manlen %s.N
					Digests [][sha1.Size]byte

					URL string
				}))(obj)).N
				*p = read32(r)
			}
			((*(*(struct {
				//mt:lenhdr 32
				//mt:zstd
				N uint32
				//mt:manlen %s.N
				NameLens []uint16

				//mt:raw
				NameData []byte

				//mt:manlen %s.N
				Digests [][sha1.Size]byte

				URL string
			}))(obj)).NameLens) = make([]uint16, (*(*(struct {
				//mt:lenhdr 32
				//mt:zstd
				N uint32
				//mt:manlen %s.N
				NameLens []uint16

				//mt:raw
				NameData []byte

				//mt:manlen %s.N
				Digests [][sha1.Size]byte

				URL string
			}))(obj)).N)
			for local117 := range (*(*(struct {
				//mt:lenhdr 32
				//mt:zstd
				N uint32
				//mt:manlen %s.N
				NameLens []uint16

				//mt:raw
				NameData []byte

				//mt:manlen %s.N
				Digests [][sha1.Size]byte

				URL string
			}))(obj)).NameLens {
				{
					p := &((*(*(struct {
						//mt:lenhdr 32
						//mt:zstd
						N uint32
						//mt:manlen %s.N
						NameLens []uint16

						//mt:raw
						NameData []byte

						//mt:manlen %s.N
						Digests [][sha1.Size]byte

						URL string
					}))(obj)).NameLens)[local117]
					*p = read16(r)
				}
			}
			{
				var err error
				((*(*(struct {
					//mt:lenhdr 32
					//mt:zstd
					N uint32
					//mt:manlen %s.N
					NameLens []uint16

					//mt:raw
					NameData []byte

					//mt:manlen %s.N
					Digests [][sha1.Size]byte

					URL string
				}))(obj)).NameData), err = io.ReadAll(r)
				chk(err)
			}
			r.Close()
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
	((*(*(struct {
		//mt:lenhdr 32
		//mt:zstd
		N uint32
		//mt:manlen %s.N
		NameLens []uint16

		//mt:raw
		NameData []byte

		//mt:manlen %s.N
		Digests [][sha1.Size]byte

		URL string
	}))(obj)).Digests) = make([][20]byte, (*(*(struct {
		//mt:lenhdr 32
		//mt:zstd
		N uint32
		//mt:manlen %s.N
		NameLens []uint16

		//mt:raw
		NameData []byte

		//mt:manlen %s.N
		Digests [][sha1.Size]byte

		URL string
	}))(obj)).N)
	for local118 := range (*(*(struct {
		//mt:lenhdr 32
		//mt:zstd
		N uint32
		//mt:manlen %s.N
		NameLens []uint16

		//mt:raw
		NameData []byte

		//mt:manlen %s.N
		Digests [][sha1.Size]byte

		URL string
	}))(obj)).Digests {
		{
			_, err := io.ReadFull(r, (((*(*(struct {
				//mt:lenhdr 32
				//mt:zstd
				N uint32
				//mt:manlen %s.N
				NameLens []uint16

				//mt:raw
				NameData []byte

				//mt:manlen %s.N
				Digests [][sha1.Size]byte

				URL string
			}))(obj)).Digests)[local118])[:])
			chk(err)
		}
	}
	var local119 []uint8
	var local120 uint16
	{
		p := &local120
		*p = read16(r)
	}
	(local119) = make([]uint8, local120)
	{
		_, err := io.ReadFull(r, (local119)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:lenhdr 32
		//mt:zstd
		N uint32
		//mt:manlen %s.N
		NameLens []uint16

		//mt:raw
		NameData []byte

		//mt:manlen %s.N
		Digests [][sha1.Size]byte

		URL string
	}))(obj)).URL) = string(local119)
}

func (obj *ToCltItemDefs) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			w, err := zstd.NewWriter(w)
			chk(err)
			{
				local121 := uint8(0)
				{
					x := local121
					write8(w, uint8(x))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Defs)))
				write16(w, uint16(x))
			}
			for local122 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local122]).serialize(w)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemDef", err))
				}
			}
			if len(((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases)) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len(((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)))
				write16(w, uint16(x))
			}
			for local123 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local123]).Alias))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local123]).Alias))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local123]).Alias))[:])
					chk(err)
				}
				if len(([]byte((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local123]).Orig))) > math.MaxUint16 {
					chk(ErrTooLong)
				}
				{
					x := uint16(len(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local123]).Orig))))
					write16(w, uint16(x))
				}
				{
					_, err := w.Write(([]byte((((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Aliases)[local123]).Orig))[:])
					chk(err)
				}
			}
			chk(w.Close())
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltItemDefs) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			r, err := zstd.NewReader(byteReader{r})
			chk(err)
			{
				var local124 uint8
				local125 := uint8(0)
				{
					p := &local124
					*p = read8(r)
				}
				if local124 != local125 {
					chk(fmt.Errorf("const %v: %v", "uint8(0)", local124))
				}
			}
			var local126 uint16
			{
				p := &local126
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs) = make([]ItemDef, local126)
			for local127 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Defs {
				if err := pcall(func() {
					(((*(*(struct {
						Defs    []ItemDef
						Aliases []struct{ Alias, Orig string }
					}))(obj)).Defs)[local127]).deserialize(r)
				}); err != nil {
					if err == io.EOF {
						chk(io.EOF)
					}
					chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemDef", err))
				}
			}
			var local128 uint16
			{
				p := &local128
				*p = read16(r)
			}
			((*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases) = make([]struct {
				Alias string
				Orig  string
			}, local128)
			for local129 := range (*(*(struct {
				Defs    []ItemDef
				Aliases []struct{ Alias, Orig string }
			}))(obj)).Aliases {
				var local130 []uint8
				var local131 uint16
				{
					p := &local131
					*p = read16(r)
				}
				(local130) = make([]uint8, local131)
				{
					_, err := io.ReadFull(r, (local130)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local129]).Alias) = string(local130)
				var local132 []uint8
				var local133 uint16
				{
					p := &local133
					*p = read16(r)
				}
				(local132) = make([]uint8, local133)
				{
					_, err := io.ReadFull(r, (local132)[:])
					chk(err)
				}
				((((*(*(struct {
					Defs    []ItemDef
					Aliases []struct{ Alias, Orig string }
				}))(obj)).Aliases)[local129]).Orig) = string(local132)
			}
			r.Close()
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltPlaySound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	if len(([]byte((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
		StartTime float32
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).SrcType).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).SrcAOID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Loop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Ephemeral
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).StartTime
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltPlaySound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	var local134 []uint8
	var local135 uint16
	{
		p := &local135
		*p = read16(r)
	}
	(local134) = make([]uint8, local135)
	{
		_, err := io.ReadFull(r, (local134)[:])
		chk(err)
	}
	((*(*(struct {
		ID      SoundID
		Name    string
		Gain    float32
		SrcType SoundSrcType
		Pos
		SrcAOID   AOID
		Loop      bool
		Fade      float32
		Pitch     float32
		Ephemeral bool
		StartTime float32
	}))(obj)).Name) = string(local134)
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).SrcType).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundSrcType", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).SrcAOID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Loop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).Ephemeral
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			ID      SoundID
			Name    string
			Gain    float32
			SrcType SoundSrcType
			Pos
			SrcAOID   AOID
			Loop      bool
			Fade      float32
			Pitch     float32
			Ephemeral bool
			StartTime float32
		}))(obj)).StartTime
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltStopSound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
}

func (obj *ToCltStopSound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID SoundID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
}

func (obj *ToCltPrivs) serialize(w io.Writer) {
	if len(((*(*(struct {
		Privs []string
	}))(obj)).Privs)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Privs []string
		}))(obj)).Privs)))
		write16(w, uint16(x))
	}
	for local136 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		if len(([]byte(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local136]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local136]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Privs []string
			}))(obj)).Privs)[local136]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltPrivs) deserialize(r io.Reader) {
	var local137 uint16
	{
		p := &local137
		*p = read16(r)
	}
	((*(*(struct {
		Privs []string
	}))(obj)).Privs) = make([]string, local137)
	for local138 := range (*(*(struct {
		Privs []string
	}))(obj)).Privs {
		var local139 []uint8
		var local140 uint16
		{
			p := &local140
			*p = read16(r)
		}
		(local139) = make([]uint8, local140)
		{
			_, err := io.ReadFull(r, (local139)[:])
			chk(err)
		}
		(((*(*(struct {
			Privs []string
		}))(obj)).Privs)[local138]) = string(local139)
	}
}

func (obj *ToCltInvFormspec) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string
		}))(obj)).Formspec))[:])
		chk(err)
	}
}

func (obj *ToCltInvFormspec) deserialize(r io.Reader) {
	var local141 []uint8
	var local142 uint32
	{
		p := &local142
		*p = read32(r)
	}
	(local141) = make([]uint8, local142)
	{
		_, err := io.ReadFull(r, (local141)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string
	}))(obj)).Formspec) = string(local141)
}

func (obj *ToCltDetachedInv) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Inv))[:])
		chk(err)
	}
}

func (obj *ToCltDetachedInv) deserialize(r io.Reader) {
	var local143 []uint8
	var local144 uint16
	{
		p := &local144
		*p = read16(r)
	}
	(local143) = make([]uint8, local144)
	{
		_, err := io.ReadFull(r, (local143)[:])
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Name) = string(local143)
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Keep
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Name string
			Keep bool
			Len  uint16 // deprecated

			//mt:raw
			Inv string
		}))(obj)).Len
		*p = read16(r)
	}
	var local145 []uint8
	{
		var err error
		(local145), err = io.ReadAll(r)
		chk(err)
	}
	((*(*(struct {
		Name string
		Keep bool
		Len  uint16 // deprecated

		//mt:raw
		Inv string
	}))(obj)).Inv) = string(local145)
}

func (obj *ToCltShowFormspec) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formspec))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			//mt:len32
			Formspec string

			Formname string
		}))(obj)).Formname))[:])
		chk(err)
	}
}

func (obj *ToCltShowFormspec) deserialize(r io.Reader) {
	var local146 []uint8
	var local147 uint32
	{
		p := &local147
		*p = read32(r)
	}
	(local146) = make([]uint8, local147)
	{
		_, err := io.ReadFull(r, (local146)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formspec) = string(local146)
	var local148 []uint8
	var local149 uint16
	{
		p := &local149
		*p = read16(r)
	}
	(local148) = make([]uint8, local149)
	{
		_, err := io.ReadFull(r, (local148)[:])
		chk(err)
	}
	((*(*(struct {
		//mt:len32
		Formspec string

		Formname string
	}))(obj)).Formname) = string(local148)
}

func (obj *ToCltMovement) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMovement) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).DefaultAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).AirAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastAccel
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).WalkSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).CrouchSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).FastSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).ClimbSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).JumpSpeed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Fluidity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Smoothing
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Sink
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			DefaultAccel, AirAccel, FastAccel,
			WalkSpeed, CrouchSpeed, FastSpeed, ClimbSpeed, JumpSpeed,
			Fluidity, Smoothing, Sink,
			Gravity float32
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltSpawnParticle) serialize(w io.Writer) {
	for local150 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				TextureName Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
				Drag        [3]float32
				Jitter      RangeV3F32
				Bounce      RangeF32
				Texture     ParticleTexture
			}))(obj)).Pos)[local150]
			write32(w, math.Float32bits(x))
		}
	}
	for local151 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).Vel {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				TextureName Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
				Drag        [3]float32
				Jitter      RangeV3F32
				Bounce      RangeF32
				Texture     ParticleTexture
			}))(obj)).Vel)[local151]
			write32(w, math.Float32bits(x))
		}
	}
	for local152 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).Acc {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				TextureName Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
				Drag        [3]float32
				Jitter      RangeV3F32
				Bounce      RangeF32
				Texture     ParticleTexture
			}))(obj)).Acc)[local152]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).ExpirationTime
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).TextureName))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).TextureName))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).TextureName))))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).AnimParams).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
	for local153 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).Drag {
		{
			x := ((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				TextureName Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
				Drag        [3]float32
				Jitter      RangeV3F32
				Bounce      RangeF32
				Texture     ParticleTexture
			}))(obj)).Drag)[local153]
			write32(w, math.Float32bits(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Jitter).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Bounce).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTexture", err))
	}
}

func (obj *ToCltSpawnParticle) deserialize(r io.Reader) {
	for local154 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				TextureName Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
				Drag        [3]float32
				Jitter      RangeV3F32
				Bounce      RangeF32
				Texture     ParticleTexture
			}))(obj)).Pos)[local154]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local155 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).Vel {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				TextureName Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
				Drag        [3]float32
				Jitter      RangeV3F32
				Bounce      RangeF32
				Texture     ParticleTexture
			}))(obj)).Vel)[local155]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local156 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).Acc {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				TextureName Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
				Drag        [3]float32
				Jitter      RangeV3F32
				Bounce      RangeF32
				Texture     ParticleTexture
			}))(obj)).Acc)[local156]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).ExpirationTime
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local157 []uint8
	var local158 uint32
	{
		p := &local158
		*p = read32(r)
	}
	(local157) = make([]uint8, local158)
	{
		_, err := io.ReadFull(r, (local157)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).TextureName))) = string(local157)
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).AnimParams).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).NodeTile
		*p = read8(r)
	}
	for local159 := range (*(*(struct {
		Pos, Vel, Acc  [3]float32
		ExpirationTime float32 // in seconds.
		Size           float32
		Collide        bool

		//mt:len32
		TextureName Texture

		Vertical    bool
		CollisionRm bool
		AnimParams  TileAnim
		Glow        uint8
		AOCollision bool
		NodeParam0  Content
		NodeParam2  uint8
		NodeTile    uint8
		Drag        [3]float32
		Jitter      RangeV3F32
		Bounce      RangeF32
		Texture     ParticleTexture
	}))(obj)).Drag {
		{
			p := &((*(*(struct {
				Pos, Vel, Acc  [3]float32
				ExpirationTime float32 // in seconds.
				Size           float32
				Collide        bool

				//mt:len32
				TextureName Texture

				Vertical    bool
				CollisionRm bool
				AnimParams  TileAnim
				Glow        uint8
				AOCollision bool
				NodeParam0  Content
				NodeParam2  uint8
				NodeTile    uint8
				Drag        [3]float32
				Jitter      RangeV3F32
				Bounce      RangeF32
				Texture     ParticleTexture
			}))(obj)).Drag)[local159]
			*p = math.Float32frombits(read32(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Jitter).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Bounce).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos, Vel, Acc  [3]float32
			ExpirationTime float32 // in seconds.
			Size           float32
			Collide        bool

			//mt:len32
			TextureName Texture

			Vertical    bool
			CollisionRm bool
			AnimParams  TileAnim
			Glow        uint8
			AOCollision bool
			NodeParam0  Content
			NodeParam2  uint8
			NodeTile    uint8
			Drag        [3]float32
			Jitter      RangeV3F32
			Bounce      RangeF32
			Texture     ParticleTexture
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTexture", err))
	}
}

func (obj *ToCltAddParticleSpawner) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Amount
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Duration
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Acc).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).ExpirationTime).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Size).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Collide
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  TweenRangeV3F32
		ExpirationTime TweenRangeF32 // in seconds.
		Size           TweenRangeF32
		Collide        bool

		//mt:len32
		TextureName Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8

		Texture ParticleTexture

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction != NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO AOID
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction != PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO AOID

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture
	}))(obj)).TextureName))))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).TextureName))))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte(*(*string)(&((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).TextureName))))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Vertical
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).CollisionRm
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).AttachedAOID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).AnimParams).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).AOCollision
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).NodeTile
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTexture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Drag).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Jitter).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Bounce).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Attraction).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AttractionKind", err))
	}
	if (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  TweenRangeV3F32
		ExpirationTime TweenRangeF32 // in seconds.
		Size           TweenRangeF32
		Collide        bool

		//mt:len32
		TextureName Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8

		Texture ParticleTexture

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction != NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO AOID
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction != PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO AOID

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture
	}))(obj)).Attraction != NoAttraction {
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).AttractStrength).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).AttractorOrigin).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV3F32", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).AttractorOriginAttachedAO).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).Flags).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerFlags", err))
		}
		if (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Attraction != PointAttraction {
			if err := pcall(func() {
				((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  TweenRangeV3F32
					ExpirationTime TweenRangeF32 // in seconds.
					Size           TweenRangeF32
					Collide        bool

					//mt:len32
					TextureName Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8

					Texture ParticleTexture

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction != NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO AOID
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction != PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO AOID

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture
				}))(obj)).AttractorAngle).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV3F32", err))
			}
			if err := pcall(func() {
				((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  TweenRangeV3F32
					ExpirationTime TweenRangeF32 // in seconds.
					Size           TweenRangeF32
					Collide        bool

					//mt:len32
					TextureName Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8

					Texture ParticleTexture

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction != NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO AOID
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction != PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO AOID

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture
				}))(obj)).AttractorAngleAttachedAO).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Radius).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if len(((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  TweenRangeV3F32
		ExpirationTime TweenRangeF32 // in seconds.
		Size           TweenRangeF32
		Collide        bool

		//mt:len32
		TextureName Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8

		Texture ParticleTexture

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction != NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO AOID
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction != PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO AOID

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture
	}))(obj)).Textures)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Textures)))
		write16(w, uint16(x))
	}
	for local160 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  TweenRangeV3F32
		ExpirationTime TweenRangeF32 // in seconds.
		Size           TweenRangeF32
		Collide        bool

		//mt:len32
		TextureName Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8

		Texture ParticleTexture

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction != NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO AOID
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction != PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO AOID

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).Textures)[local160]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTexture", err))
		}
	}
}

func (obj *ToCltAddParticleSpawner) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Amount
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Duration
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Acc).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).ExpirationTime).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Size).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Collide
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local161 []uint8
	var local162 uint32
	{
		p := &local162
		*p = read32(r)
	}
	(local161) = make([]uint8, local162)
	{
		_, err := io.ReadFull(r, (local161)[:])
		chk(err)
	}
	(*(*string)(&((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  TweenRangeV3F32
		ExpirationTime TweenRangeF32 // in seconds.
		Size           TweenRangeF32
		Collide        bool

		//mt:len32
		TextureName Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8

		Texture ParticleTexture

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction != NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO AOID
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction != PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO AOID

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture
	}))(obj)).TextureName))) = string(local161)
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Vertical
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).CollisionRm
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).AttachedAOID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).AnimParams).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Glow
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).AOCollision
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).NodeParam2
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).NodeTile
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTexture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Drag).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Jitter).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Bounce).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Attraction).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AttractionKind", err))
	}
	if (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  TweenRangeV3F32
		ExpirationTime TweenRangeF32 // in seconds.
		Size           TweenRangeF32
		Collide        bool

		//mt:len32
		TextureName Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8

		Texture ParticleTexture

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction != NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO AOID
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction != PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO AOID

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture
	}))(obj)).Attraction != NoAttraction {
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).AttractStrength).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeF32", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).AttractorOrigin).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV3F32", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).AttractorOriginAttachedAO).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).Flags).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerFlags", err))
		}
		if (*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Attraction != PointAttraction {
			if err := pcall(func() {
				((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  TweenRangeV3F32
					ExpirationTime TweenRangeF32 // in seconds.
					Size           TweenRangeF32
					Collide        bool

					//mt:len32
					TextureName Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8

					Texture ParticleTexture

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction != NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO AOID
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction != PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO AOID

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture
				}))(obj)).AttractorAngle).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV3F32", err))
			}
			if err := pcall(func() {
				((*(*(struct {
					Amount         uint16
					Duration       float32
					Pos, Vel, Acc  TweenRangeV3F32
					ExpirationTime TweenRangeF32 // in seconds.
					Size           TweenRangeF32
					Collide        bool

					//mt:len32
					TextureName Texture

					ID           ParticleSpawnerID
					Vertical     bool
					CollisionRm  bool
					AttachedAOID AOID
					AnimParams   TileAnim
					Glow         uint8
					AOCollision  bool

					NodeParam0 Content
					NodeParam2 uint8
					NodeTile   uint8

					Texture ParticleTexture

					Drag   TweenRangeV3F32
					Jitter TweenRangeV3F32
					Bounce TweenRangeF32

					Attraction AttractionKind

					//mt:if %s.Attraction != NoAttraction
					AttractStrength           TweenRangeF32
					AttractorOrigin           TweenV3F32
					AttractorOriginAttachedAO AOID
					Flags                     ParticleSpawnerFlags

					//mt:if %s.Attraction != PointAttraction
					AttractorAngle           TweenV3F32
					AttractorAngleAttachedAO AOID

					Radius TweenRangeV3F32

					//mt:len16
					Textures []ParticleTexture
				}))(obj)).AttractorAngleAttachedAO).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
			}
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Amount         uint16
			Duration       float32
			Pos, Vel, Acc  TweenRangeV3F32
			ExpirationTime TweenRangeF32 // in seconds.
			Size           TweenRangeF32
			Collide        bool

			//mt:len32
			TextureName Texture

			ID           ParticleSpawnerID
			Vertical     bool
			CollisionRm  bool
			AttachedAOID AOID
			AnimParams   TileAnim
			Glow         uint8
			AOCollision  bool

			NodeParam0 Content
			NodeParam2 uint8
			NodeTile   uint8

			Texture ParticleTexture

			Drag   TweenRangeV3F32
			Jitter TweenRangeV3F32
			Bounce TweenRangeF32

			Attraction AttractionKind

			//mt:if %s.Attraction != NoAttraction
			AttractStrength           TweenRangeF32
			AttractorOrigin           TweenV3F32
			AttractorOriginAttachedAO AOID
			Flags                     ParticleSpawnerFlags

			//mt:if %s.Attraction != PointAttraction
			AttractorAngle           TweenV3F32
			AttractorAngleAttachedAO AOID

			Radius TweenRangeV3F32

			//mt:len16
			Textures []ParticleTexture
		}))(obj)).Radius).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenRangeV3F32", err))
	}
	var local163 uint16
	{
		p := &local163
		*p = read16(r)
	}
	((*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  TweenRangeV3F32
		ExpirationTime TweenRangeF32 // in seconds.
		Size           TweenRangeF32
		Collide        bool

		//mt:len32
		TextureName Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8

		Texture ParticleTexture

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction != NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO AOID
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction != PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO AOID

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture
	}))(obj)).Textures) = make([]ParticleTexture, local163)
	for local164 := range (*(*(struct {
		Amount         uint16
		Duration       float32
		Pos, Vel, Acc  TweenRangeV3F32
		ExpirationTime TweenRangeF32 // in seconds.
		Size           TweenRangeF32
		Collide        bool

		//mt:len32
		TextureName Texture

		ID           ParticleSpawnerID
		Vertical     bool
		CollisionRm  bool
		AttachedAOID AOID
		AnimParams   TileAnim
		Glow         uint8
		AOCollision  bool

		NodeParam0 Content
		NodeParam2 uint8
		NodeTile   uint8

		Texture ParticleTexture

		Drag   TweenRangeV3F32
		Jitter TweenRangeV3F32
		Bounce TweenRangeF32

		Attraction AttractionKind

		//mt:if %s.Attraction != NoAttraction
		AttractStrength           TweenRangeF32
		AttractorOrigin           TweenV3F32
		AttractorOriginAttachedAO AOID
		Flags                     ParticleSpawnerFlags

		//mt:if %s.Attraction != PointAttraction
		AttractorAngle           TweenV3F32
		AttractorAngleAttachedAO AOID

		Radius TweenRangeV3F32

		//mt:len16
		Textures []ParticleTexture
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				Amount         uint16
				Duration       float32
				Pos, Vel, Acc  TweenRangeV3F32
				ExpirationTime TweenRangeF32 // in seconds.
				Size           TweenRangeF32
				Collide        bool

				//mt:len32
				TextureName Texture

				ID           ParticleSpawnerID
				Vertical     bool
				CollisionRm  bool
				AttachedAOID AOID
				AnimParams   TileAnim
				Glow         uint8
				AOCollision  bool

				NodeParam0 Content
				NodeParam2 uint8
				NodeTile   uint8

				Texture ParticleTexture

				Drag   TweenRangeV3F32
				Jitter TweenRangeV3F32
				Bounce TweenRangeF32

				Attraction AttractionKind

				//mt:if %s.Attraction != NoAttraction
				AttractStrength           TweenRangeF32
				AttractorOrigin           TweenV3F32
				AttractorOriginAttachedAO AOID
				Flags                     ParticleSpawnerFlags

				//mt:if %s.Attraction != PointAttraction
				AttractorAngle           TweenV3F32
				AttractorAngleAttachedAO AOID

				Radius TweenRangeV3F32

				//mt:len16
				Textures []ParticleTexture
			}))(obj)).Textures)[local164]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTexture", err))
		}
	}
}

func (obj *ToCltAddHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).HUD).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUD", err))
	}
}

func (obj *ToCltAddHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
			HUD
		}))(obj)).HUD).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUD", err))
	}
}

func (obj *ToCltRmHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
}

func (obj *ToCltRmHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
}

func (obj *ToCltChangeHUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Field).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDPos {
		for local165 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Pos {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Pos)[local165]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDName {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Name))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDScale {
		for local166 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Scale {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Scale)[local166]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDNumber {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Number
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDItem {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Item
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDDir {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Dir
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDAlign {
		for local167 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Align {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Align)[local167]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDOffset {
		for local168 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Offset {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Offset)[local168]
				write32(w, math.Float32bits(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).WorldPos).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDSize {
		for local169 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Size {
			{
				x := ((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Size)[local169]
				write32(w, uint32(x))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDZIndex {
		{
			x := (*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).ZIndex
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText2 {
		if len(([]byte((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text2))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text2))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Text2))[:])
			chk(err)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDStyle {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Style).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
		}
	}
}

func (obj *ToCltChangeHUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDID", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Field).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDField", err))
	}
	if !((*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field < hudMax) {
		chk(errors.New("assertion failed: %s.Field < hudMax"))
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDPos {
		for local170 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Pos {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Pos)[local170]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDName {
		var local171 []uint8
		var local172 uint16
		{
			p := &local172
			*p = read16(r)
		}
		(local171) = make([]uint8, local172)
		{
			_, err := io.ReadFull(r, (local171)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Name) = string(local171)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDScale {
		for local173 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Scale {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Scale)[local173]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText {
		var local174 []uint8
		var local175 uint16
		{
			p := &local175
			*p = read16(r)
		}
		(local174) = make([]uint8, local175)
		{
			_, err := io.ReadFull(r, (local174)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text) = string(local174)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDNumber {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Number
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDItem {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Item
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDDir {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Dir
			*p = read32(r)
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDAlign {
		for local176 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Align {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Align)[local176]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDOffset {
		for local177 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Offset {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Offset)[local177]
				*p = math.Float32frombits(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDWorldPos {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).WorldPos).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDSize {
		for local178 := range (*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Size {
			{
				p := &((*(*(struct {
					ID HUDID

					Field HUDField

					//mt:if %s.Field == HUDPos
					Pos [2]float32

					//mt:if %s.Field == HUDName
					Name string

					//mt:if %s.Field == HUDScale
					Scale [2]float32

					//mt:if %s.Field == HUDText
					Text string

					//mt:if %s.Field == HUDNumber
					Number uint32

					//mt:if %s.Field == HUDItem
					Item uint32

					//mt:if %s.Field == HUDDir
					Dir uint32

					//mt:if %s.Field == HUDAlign
					Align [2]float32

					//mt:if %s.Field == HUDOffset
					Offset [2]float32

					//mt:if %s.Field == HUDWorldPos
					WorldPos Pos

					//mt:if %s.Field == HUDSize
					Size [2]int32

					//mt:if %s.Field == HUDZIndex
					ZIndex int32

					//mt:if %s.Field == HUDText2
					Text2 string

					//mt:if %s.Field == HUDStyle
					Style HUDStyleFlags
				}))(obj)).Size)[local178]
				*p = int32(read32(r))
			}
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDZIndex {
		{
			p := &(*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).ZIndex
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDText2 {
		var local179 []uint8
		var local180 uint16
		{
			p := &local180
			*p = read16(r)
		}
		(local179) = make([]uint8, local180)
		{
			_, err := io.ReadFull(r, (local179)[:])
			chk(err)
		}
		((*(*(struct {
			ID HUDID

			Field HUDField

			//mt:if %s.Field == HUDPos
			Pos [2]float32

			//mt:if %s.Field == HUDName
			Name string

			//mt:if %s.Field == HUDScale
			Scale [2]float32

			//mt:if %s.Field == HUDText
			Text string

			//mt:if %s.Field == HUDNumber
			Number uint32

			//mt:if %s.Field == HUDItem
			Item uint32

			//mt:if %s.Field == HUDDir
			Dir uint32

			//mt:if %s.Field == HUDAlign
			Align [2]float32

			//mt:if %s.Field == HUDOffset
			Offset [2]float32

			//mt:if %s.Field == HUDWorldPos
			WorldPos Pos

			//mt:if %s.Field == HUDSize
			Size [2]int32

			//mt:if %s.Field == HUDZIndex
			ZIndex int32

			//mt:if %s.Field == HUDText2
			Text2 string

			//mt:if %s.Field == HUDStyle
			Style HUDStyleFlags
		}))(obj)).Text2) = string(local179)
	}
	if (*(*(struct {
		ID HUDID

		Field HUDField

		//mt:if %s.Field == HUDPos
		Pos [2]float32

		//mt:if %s.Field == HUDName
		Name string

		//mt:if %s.Field == HUDScale
		Scale [2]float32

		//mt:if %s.Field == HUDText
		Text string

		//mt:if %s.Field == HUDNumber
		Number uint32

		//mt:if %s.Field == HUDItem
		Item uint32

		//mt:if %s.Field == HUDDir
		Dir uint32

		//mt:if %s.Field == HUDAlign
		Align [2]float32

		//mt:if %s.Field == HUDOffset
		Offset [2]float32

		//mt:if %s.Field == HUDWorldPos
		WorldPos Pos

		//mt:if %s.Field == HUDSize
		Size [2]int32

		//mt:if %s.Field == HUDZIndex
		ZIndex int32

		//mt:if %s.Field == HUDText2
		Text2 string

		//mt:if %s.Field == HUDStyle
		Style HUDStyleFlags
	}))(obj)).Field == HUDStyle {
		if err := pcall(func() {
			((*(*(struct {
				ID HUDID

				Field HUDField

				//mt:if %s.Field == HUDPos
				Pos [2]float32

				//mt:if %s.Field == HUDName
				Name string

				//mt:if %s.Field == HUDScale
				Scale [2]float32

				//mt:if %s.Field == HUDText
				Text string

				//mt:if %s.Field == HUDNumber
				Number uint32

				//mt:if %s.Field == HUDItem
				Item uint32

				//mt:if %s.Field == HUDDir
				Dir uint32

				//mt:if %s.Field == HUDAlign
				Align [2]float32

				//mt:if %s.Field == HUDOffset
				Offset [2]float32

				//mt:if %s.Field == HUDWorldPos
				WorldPos Pos

				//mt:if %s.Field == HUDSize
				Size [2]int32

				//mt:if %s.Field == HUDZIndex
				ZIndex int32

				//mt:if %s.Field == HUDText2
				Text2 string

				//mt:if %s.Field == HUDStyle
				Style HUDStyleFlags
			}))(obj)).Style).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
		}
	}
}

func (obj *ToCltHUDFlags) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
}

func (obj *ToCltHUDFlags) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			// &^= Mask
			// |= Flags
			Flags, Mask HUDFlags
		}))(obj)).Mask).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDFlags", err))
	}
}

func (obj *ToCltSetHotbarParam) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			local181 := uint16(4) // Size of Size field.
			{
				x := local181
				write16(w, uint16(x))
			}
		}
		{
			x := (*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			write32(w, uint32(x))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
}

func (obj *ToCltSetHotbarParam) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param HotbarParam

			//mt:if %s.Param == HotbarSize
			//mt:const uint16(4) // Size of Size field.
			Size int32

			//mt:if %s.Param != HotbarSize
			Img Texture
		}))(obj)).Param).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HotbarParam", err))
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param == HotbarSize {
		{
			var local182 uint16
			local183 := uint16(4) // Size of Size field.
			{
				p := &local182
				*p = read16(r)
			}
			if local182 != local183 {
				chk(fmt.Errorf("const %v: %v", "uint16(4) // Size of Size field.", local182))
			}
		}
		{
			p := &(*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Size
			*p = int32(read32(r))
		}
	}
	if (*(*(struct {
		Param HotbarParam

		//mt:if %s.Param == HotbarSize
		//mt:const uint16(4) // Size of Size field.
		Size int32

		//mt:if %s.Param != HotbarSize
		Img Texture
	}))(obj)).Param != HotbarSize {
		if err := pcall(func() {
			((*(*(struct {
				Param HotbarParam

				//mt:if %s.Param == HotbarSize
				//mt:const uint16(4) // Size of Size field.
				Size int32

				//mt:if %s.Param != HotbarSize
				Img Texture
			}))(obj)).Img).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
}

func (obj *ToCltBreath) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Breath uint16
		}))(obj)).Breath
		write16(w, uint16(x))
	}
}

func (obj *ToCltBreath) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Breath uint16
		}))(obj)).Breath
		*p = read16(r)
	}
}

func (obj *ToCltSkyParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).BgColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32

		FogDistance int16
		FogStart    float32
		FogColor    color.NRGBA
	}))(obj)).Type))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).Type))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).Type))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).Clouds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).SunFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).MoonFogTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	if len(([]byte((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32

		FogDistance int16
		FogStart    float32
		FogColor    color.NRGBA
	}))(obj)).FogTintType))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).FogTintType))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).FogTintType))[:])
		chk(err)
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32

		FogDistance int16
		FogStart    float32
		FogColor    color.NRGBA
	}))(obj)).Type == "skybox" {
		if len(((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).Textures)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).Textures)))
			write16(w, uint16(x))
		}
		for local184 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA

					BodyOrbitTilt float32

					FogDistance int16
					FogStart    float32
					FogColor    color.NRGBA
				}))(obj)).Textures)[local184]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32

		FogDistance int16
		FogStart    float32
		FogColor    color.NRGBA
	}))(obj)).Type == "regular" {
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).DaySky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).DayHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).DawnSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).DawnHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).NightSky
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).NightHorizon
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).Indoor
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).BodyOrbitTilt
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).FogDistance
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).FogStart
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).FogColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
}

func (obj *ToCltSkyParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).BgColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local185 []uint8
	var local186 uint16
	{
		p := &local186
		*p = read16(r)
	}
	(local185) = make([]uint8, local186)
	{
		_, err := io.ReadFull(r, (local185)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32

		FogDistance int16
		FogStart    float32
		FogColor    color.NRGBA
	}))(obj)).Type) = string(local185)
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).Clouds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).SunFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).MoonFogTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	var local187 []uint8
	var local188 uint16
	{
		p := &local188
		*p = read16(r)
	}
	(local187) = make([]uint8, local188)
	{
		_, err := io.ReadFull(r, (local187)[:])
		chk(err)
	}
	((*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32

		FogDistance int16
		FogStart    float32
		FogColor    color.NRGBA
	}))(obj)).FogTintType) = string(local187)
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32

		FogDistance int16
		FogStart    float32
		FogColor    color.NRGBA
	}))(obj)).Type == "skybox" {
		var local189 uint16
		{
			p := &local189
			*p = read16(r)
		}
		((*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).Textures) = make([]Texture, local189)
		for local190 := range (*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).Textures {
			if err := pcall(func() {
				(((*(*(struct {
					BgColor     color.NRGBA
					Type        string
					Clouds      bool
					SunFogTint  color.NRGBA
					MoonFogTint color.NRGBA
					FogTintType string

					//mt:if %s.Type == "skybox"
					Textures []Texture

					//mt:if %s.Type == "regular"
					DaySky, DayHorizon,
					DawnSky, DawnHorizon,
					NightSky, NightHorizon,
					Indoor color.NRGBA

					BodyOrbitTilt float32

					FogDistance int16
					FogStart    float32
					FogColor    color.NRGBA
				}))(obj)).Textures)[local190]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
			}
		}
	}
	if (*(*(struct {
		BgColor     color.NRGBA
		Type        string
		Clouds      bool
		SunFogTint  color.NRGBA
		MoonFogTint color.NRGBA
		FogTintType string

		//mt:if %s.Type == "skybox"
		Textures []Texture

		//mt:if %s.Type == "regular"
		DaySky, DayHorizon,
		DawnSky, DawnHorizon,
		NightSky, NightHorizon,
		Indoor color.NRGBA

		BodyOrbitTilt float32

		FogDistance int16
		FogStart    float32
		FogColor    color.NRGBA
	}))(obj)).Type == "regular" {
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).DaySky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).DayHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).DawnSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).DawnHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).NightSky
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).NightHorizon
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				BgColor     color.NRGBA
				Type        string
				Clouds      bool
				SunFogTint  color.NRGBA
				MoonFogTint color.NRGBA
				FogTintType string

				//mt:if %s.Type == "skybox"
				Textures []Texture

				//mt:if %s.Type == "regular"
				DaySky, DayHorizon,
				DawnSky, DawnHorizon,
				NightSky, NightHorizon,
				Indoor color.NRGBA

				BodyOrbitTilt float32

				FogDistance int16
				FogStart    float32
				FogColor    color.NRGBA
			}))(obj)).Indoor
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).BodyOrbitTilt
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).FogDistance
		*p = int16(read16(r))
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).FogStart
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			BgColor     color.NRGBA
			Type        string
			Clouds      bool
			SunFogTint  color.NRGBA
			MoonFogTint color.NRGBA
			FogTintType string

			//mt:if %s.Type == "skybox"
			Textures []Texture

			//mt:if %s.Type == "regular"
			DaySky, DayHorizon,
			DawnSky, DawnHorizon,
			NightSky, NightHorizon,
			Indoor color.NRGBA

			BodyOrbitTilt float32

			FogDistance int16
			FogStart    float32
			FogColor    color.NRGBA
		}))(obj)).FogColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
}

func (obj *ToCltOverrideDayNightRatio) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		write16(w, uint16(x))
	}
}

func (obj *ToCltOverrideDayNightRatio) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Override
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Override bool
			Ratio    uint16
		}))(obj)).Ratio
		*p = read16(r)
	}
}

func (obj *ToCltLocalPlayerAnim) serialize(w io.Writer) {
	for local191 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local191]
			write32(w, uint32(x))
		}
	}
	for local192 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local192]
			write32(w, uint32(x))
		}
	}
	for local193 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local193]
			write32(w, uint32(x))
		}
	}
	for local194 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			x := ((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local194]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltLocalPlayerAnim) deserialize(r io.Reader) {
	for local195 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Idle {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Idle)[local195]
			*p = int32(read32(r))
		}
	}
	for local196 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Walk {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Walk)[local196]
			*p = int32(read32(r))
		}
	}
	for local197 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).Dig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).Dig)[local197]
			*p = int32(read32(r))
		}
	}
	for local198 := range (*(*(struct {
		Idle, Walk, Dig, WalkDig [2]int32
		Speed                    float32
	}))(obj)).WalkDig {
		{
			p := &((*(*(struct {
				Idle, Walk, Dig, WalkDig [2]int32
				Speed                    float32
			}))(obj)).WalkDig)[local198]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Idle, Walk, Dig, WalkDig [2]int32
			Speed                    float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltEyeOffset) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third, ThirdFront Vec
		}))(obj)).First).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third, ThirdFront Vec
		}))(obj)).Third).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third, ThirdFront Vec
		}))(obj)).ThirdFront).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltEyeOffset) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			First, Third, ThirdFront Vec
		}))(obj)).First).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third, ThirdFront Vec
		}))(obj)).Third).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			First, Third, ThirdFront Vec
		}))(obj)).ThirdFront).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *ToCltDelParticleSpawner) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltDelParticleSpawner) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID ParticleSpawnerID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleSpawnerID", err))
	}
}

func (obj *ToCltCloudParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).ShadowColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		write32(w, math.Float32bits(x))
	}
	for local199 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		ShadowColor  color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			x := ((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				ShadowColor  color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local199]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *ToCltCloudParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Density
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).DiffuseColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).AmbientColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).ShadowColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Height
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Density      float32
			DiffuseColor color.NRGBA
			AmbientColor color.NRGBA
			ShadowColor  color.NRGBA
			Height       float32
			Thickness    float32
			Speed        [2]float32
		}))(obj)).Thickness
		*p = math.Float32frombits(read32(r))
	}
	for local200 := range (*(*(struct {
		Density      float32
		DiffuseColor color.NRGBA
		AmbientColor color.NRGBA
		ShadowColor  color.NRGBA
		Height       float32
		Thickness    float32
		Speed        [2]float32
	}))(obj)).Speed {
		{
			p := &((*(*(struct {
				Density      float32
				DiffuseColor color.NRGBA
				AmbientColor color.NRGBA
				ShadowColor  color.NRGBA
				Height       float32
				Thickness    float32
				Speed        [2]float32
			}))(obj)).Speed)[local200]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ToCltFadeSound) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltFadeSound) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundID", err))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Step
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ID   SoundID
			Step float32
			Gain float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltUpdatePlayerList) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerListUpdateType", err))
	}
	if len(((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)))
		write16(w, uint16(x))
	}
	for local201 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		if len(([]byte(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local201]))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local201]))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte(((*(*(struct {
				Type    PlayerListUpdateType
				Players []string
			}))(obj)).Players)[local201]))[:])
			chk(err)
		}
	}
}

func (obj *ToCltUpdatePlayerList) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerListUpdateType", err))
	}
	var local202 uint16
	{
		p := &local202
		*p = read16(r)
	}
	((*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players) = make([]string, local202)
	for local203 := range (*(*(struct {
		Type    PlayerListUpdateType
		Players []string
	}))(obj)).Players {
		var local204 []uint8
		var local205 uint16
		{
			p := &local205
			*p = read16(r)
		}
		(local204) = make([]uint8, local205)
		{
			_, err := io.ReadFull(r, (local204)[:])
			chk(err)
		}
		(((*(*(struct {
			Type    PlayerListUpdateType
			Players []string
		}))(obj)).Players)[local203]) = string(local204)
	}
}

func (obj *ToCltModChanMsg) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Channel))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Sender))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Channel string
			Sender  string
			Msg     string
		}))(obj)).Msg))[:])
		chk(err)
	}
}

func (obj *ToCltModChanMsg) deserialize(r io.Reader) {
	var local206 []uint8
	var local207 uint16
	{
		p := &local207
		*p = read16(r)
	}
	(local206) = make([]uint8, local207)
	{
		_, err := io.ReadFull(r, (local206)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Channel) = string(local206)
	var local208 []uint8
	var local209 uint16
	{
		p := &local209
		*p = read16(r)
	}
	(local208) = make([]uint8, local209)
	{
		_, err := io.ReadFull(r, (local208)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Sender) = string(local208)
	var local210 []uint8
	var local211 uint16
	{
		p := &local211
		*p = read16(r)
	}
	(local210) = make([]uint8, local211)
	{
		_, err := io.ReadFull(r, (local210)[:])
		chk(err)
	}
	((*(*(struct {
		Channel string
		Sender  string
		Msg     string
	}))(obj)).Msg) = string(local210)
}

func (obj *ToCltModChanSig) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ModChanSig", err))
	}
	if len(([]byte((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Channel))[:])
		chk(err)
	}
}

func (obj *ToCltModChanSig) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Signal  ModChanSig
			Channel string
		}))(obj)).Signal).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ModChanSig", err))
	}
	var local212 []uint8
	var local213 uint16
	{
		p := &local213
		*p = read16(r)
	}
	(local212) = make([]uint8, local213)
	{
		_, err := io.ReadFull(r, (local212)[:])
		chk(err)
	}
	((*(*(struct {
		Signal  ModChanSig
		Channel string
	}))(obj)).Channel) = string(local212)
}

func (obj *ToCltNodeMetasChanged) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				w := zlib.NewWriter(w)
				if x == nil {
					write8(w, 0)
				} else {
					write8(w, 2)
					if len(x) > math.MaxUint16 {
						chk(ErrTooLong)
					}
					write16(w, uint16(len(x)))
					keys := make([][3]int16, 0, len(x))
					for key := range x {
						keys = append(keys, key)
					}
					sort.Slice(keys, func(i, j int) bool {
						p, q := keys[i], keys[j]
						for i := range p {
							switch {
							case p[i] < q[i]:
								return true
							case p[i] > q[i]:
								return false
							}
						}
						return false
					})
					for _, key := range keys {
						for _, n := range key {
							write16(w, uint16(n))
						}
						chk(serialize(w, x[key]))
					}
				}
				chk(w.Close())
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToCltNodeMetasChanged) deserialize(r io.Reader) {
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				//mt:lenhdr 32
				Changed map[[3]int16]*NodeMeta
			}))(obj)).Changed
			{
				r, err := zlib.NewReader(byteReader{r})
				chk(err)
				switch ver := read8(r); ver {
				case 0:
					*p = nil
				case 2:
					n := read16(r)
					*p = make(map[[3]int16]*NodeMeta, n)
					for ; n > 0; n-- {
						var pos [3]int16
						for i := range pos {
							pos[i] = int16(read16(r))
						}
						nm := new(NodeMeta)
						chk(deserialize(r, nm))
						(*p)[pos] = nm
					}
				default:
					chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
				}
				chk(r.Close())
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ToCltSunParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltSunParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).ToneMap).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rise).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Rising
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Rise    Texture
			Rising  bool
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltMoonParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltMoonParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).ToneMap).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Visible bool
			Texture
			ToneMap Texture
			Size    float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltStarParams) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Count
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Color
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Size
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).DayOpacity
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltStarParams) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Count
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Color
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).Size
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Visible    bool
			Count      uint32
			Color      color.NRGBA
			Size       float32
			DayOpacity float32
		}))(obj)).DayOpacity
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ToCltMovePlayerRel) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
}

func (obj *ToCltMovePlayerRel) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
}

func (obj *ToCltSRPBytesSaltB) serialize(w io.Writer) {
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	if len(((*(*(struct {
		Salt, B []byte
	}))(obj)).B)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltSRPBytesSaltB) deserialize(r io.Reader) {
	var local214 uint16
	{
		p := &local214
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).Salt) = make([]byte, local214)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).Salt)[:])
		chk(err)
	}
	var local215 uint16
	{
		p := &local215
		*p = read16(r)
	}
	((*(*(struct {
		Salt, B []byte
	}))(obj)).B) = make([]byte, local215)
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Salt, B []byte
		}))(obj)).B)[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Prepend string
	}))(obj)).Prepend))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Prepend string
		}))(obj)).Prepend))[:])
		chk(err)
	}
}

func (obj *ToCltFormspecPrepend) deserialize(r io.Reader) {
	var local216 []uint8
	var local217 uint16
	{
		p := &local217
		*p = read16(r)
	}
	(local216) = make([]uint8, local217)
	{
		_, err := io.ReadFull(r, (local216)[:])
		chk(err)
	}
	((*(*(struct {
		Prepend string
	}))(obj)).Prepend) = string(local216)
}

func (obj *ToCltLighting) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).ShadowIntensity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).Saturation
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).LuminanceMin
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).LuminanceMax
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).ExposureCorrection
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).SpeedDarkBright
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).SpeedBrightDark
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).CenterWeightPower
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).VolumetricStrength
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).ShadowTint
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).BloomIntensity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).BloomStrength
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).BloomRadius
		write32(w, math.Float32bits(x))
	}
}

func (obj *ToCltLighting) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).ShadowIntensity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).Saturation
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).LuminanceMin
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).LuminanceMax
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).ExposureCorrection
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).SpeedDarkBright
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).SpeedBrightDark
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).CenterWeightPower
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).VolumetricStrength
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).ShadowTint
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).BloomIntensity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).BloomStrength
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			ShadowIntensity    float32
			Saturation         float32
			LuminanceMin       float32
			LuminanceMax       float32
			ExposureCorrection float32
			SpeedDarkBright    float32
			SpeedBrightDark    float32
			CenterWeightPower  float32
			VolumetricStrength float32
			ShadowTint         color.NRGBA
			BloomIntensity     float32
			BloomStrength      float32
			BloomRadius        float32
		}))(obj)).BloomRadius
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AOCmdProps) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOProps", err))
	}
}

func (obj *AOCmdProps) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Props AOProps
		}))(obj)).Props).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOProps", err))
	}
}

func (obj *AOCmdPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPos", err))
	}
}

func (obj *AOCmdPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos AOPos
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPos", err))
	}
}

func (obj *AOCmdTextureMod) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
}

func (obj *AOCmdTextureMod) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Mod Texture // suffix
		}))(obj)).Mod).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
}

func (obj *AOCmdSprite) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOSprite", err))
	}
}

func (obj *AOCmdSprite) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Sprite AOSprite
		}))(obj)).Sprite).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOSprite", err))
	}
}

func (obj *AOCmdHP) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			HP uint16
		}))(obj)).HP
		write16(w, uint16(x))
	}
}

func (obj *AOCmdHP) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			HP uint16
		}))(obj)).HP
		*p = read16(r)
	}
}

func (obj *AOCmdArmorGroups) serialize(w io.Writer) {
	if len(((*(*(struct {
		Armor []Group
	}))(obj)).Armor)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Armor []Group
		}))(obj)).Armor)))
		write16(w, uint16(x))
	}
	for local218 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local218]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
		}
	}
}

func (obj *AOCmdArmorGroups) deserialize(r io.Reader) {
	var local219 uint16
	{
		p := &local219
		*p = read16(r)
	}
	((*(*(struct {
		Armor []Group
	}))(obj)).Armor) = make([]Group, local219)
	for local220 := range (*(*(struct {
		Armor []Group
	}))(obj)).Armor {
		if err := pcall(func() {
			(((*(*(struct {
				Armor []Group
			}))(obj)).Armor)[local220]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
		}
	}
}

func (obj *AOCmdAnim) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAnim", err))
	}
}

func (obj *AOCmdAnim) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Anim AOAnim
		}))(obj)).Anim).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAnim", err))
	}
}

func (obj *AOCmdBonePos) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Bone     string
		Override AOBoneOverride
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Bone     string
			Override AOBoneOverride
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Bone     string
			Override AOBoneOverride
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Bone     string
			Override AOBoneOverride
		}))(obj)).Override).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOBoneOverride", err))
	}
}

func (obj *AOCmdBonePos) deserialize(r io.Reader) {
	var local221 []uint8
	var local222 uint16
	{
		p := &local222
		*p = read16(r)
	}
	(local221) = make([]uint8, local222)
	{
		_, err := io.ReadFull(r, (local221)[:])
		chk(err)
	}
	((*(*(struct {
		Bone     string
		Override AOBoneOverride
	}))(obj)).Bone) = string(local221)
	if err := pcall(func() {
		((*(*(struct {
			Bone     string
			Override AOBoneOverride
		}))(obj)).Override).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOBoneOverride", err))
	}
}

func (obj *AOCmdAttach) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAttach", err))
	}
}

func (obj *AOCmdAttach) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Attach AOAttach
		}))(obj)).Attach).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOAttach", err))
	}
}

func (obj *AOCmdPhysOverride) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdPhysOverride) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Phys AOPhysOverride
		}))(obj)).Phys).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOPhysOverride", err))
	}
}

func (obj *AOCmdSpawnInfant) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		local223 := genericCAO
		if err := pcall(func() {
			(local223).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
	}
}

func (obj *AOCmdSpawnInfant) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var local224 aoType
		local225 := genericCAO
		if err := pcall(func() {
			(local224).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
		if local224 != local225 {
			chk(fmt.Errorf("const %v: %v", "genericCAO", local224))
		}
	}
}

func (obj *AOCmdAnimSpeed) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Speed float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOCmdAnimSpeed) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Speed float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *NodeMeta) serialize(w io.Writer) {
	if len(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			//mt:len32
			Fields []NodeMetaField

			Inv Inv
		}))(obj)).Fields)))
		write32(w, uint32(x))
	}
	for local226 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local226]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Serialize(w))
}

func (obj *NodeMeta) deserialize(r io.Reader) {
	var local227 uint32
	{
		p := &local227
		*p = read32(r)
	}
	((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields) = make([]NodeMetaField, local227)
	for local228 := range (*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Fields {
		if err := pcall(func() {
			(((*(*(struct {
				//mt:len32
				Fields []NodeMetaField

				Inv Inv
			}))(obj)).Fields)[local228]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeMetaField", err))
		}
	}
	chk(((*(*(struct {
		//mt:len32
		Fields []NodeMetaField

		Inv Inv
	}))(obj)).Inv).Deserialize(r))
}

func (obj *MinimapMode) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MinimapType", err))
	}
	if len(([]byte((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Label))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		write16(w, uint16(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		write16(w, uint16(x))
	}
}

func (obj *MinimapMode) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MinimapType", err))
	}
	var local229 []uint8
	var local230 uint16
	{
		p := &local230
		*p = read16(r)
	}
	(local229) = make([]uint8, local230)
	{
		_, err := io.ReadFull(r, (local229)[:])
		chk(err)
	}
	((*(*(struct {
		Type  MinimapType
		Label string
		Size  uint16
		Texture
		Scale uint16
	}))(obj)).Label) = string(local229)
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Size
		*p = read16(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			Type  MinimapType
			Label string
			Size  uint16
			Texture
			Scale uint16
		}))(obj)).Scale
		*p = read16(r)
	}
}

func (obj *NodeDef) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Param0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local231 := uint8(13)
			{
				x := local231
				write8(w, uint8(x))
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local232 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).Groups)[local232]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).P1Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).P2Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DrawType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DrawType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Mesh))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Mesh))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Mesh))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Scale
			write32(w, math.Float32bits(x))
		}
		{
			local233 := uint8(6)
			{
				x := local233
				write8(w, uint8(x))
			}
		}
		for local234 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).Tiles)[local234]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		for local235 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).OverlayTiles)[local235]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			local236 := uint8(6)
			{
				x := local236
				write8(w, uint8(x))
			}
		}
		for local237 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).SpecialTiles)[local237]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Palette).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Waving).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.WaveType", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).ConnectSides
			write8(w, uint8(x))
		}
		if len(((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).ConnectTo)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).ConnectTo)))
			write16(w, uint16(x))
		}
		for local238 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).ConnectTo)[local238]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).InsideTint
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Level
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Translucent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Transparent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LightSrc
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).GndContent
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Collides
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).PointType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PointabilityType", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Diggable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Climbable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Replaceable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).OnRightClick
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DmgPerSec
			write32(w, uint32(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LiquidType).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LiquidType", err))
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).FlowingAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).FlowingAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).FlowingAlt))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).SrcAlt))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).SrcAlt))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).SrcAlt))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Viscosity
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LiqRenewable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).FlowRange
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DrownDmg
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Floodable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DrawBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).ColBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).SelBox).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).FootstepSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DiggingSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DugSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LegacyFaceDir
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LegacyMounted
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if len(([]byte((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).DigPredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DigPredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DigPredict))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).MaxLvl
			write8(w, uint8(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).AlphaUse).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlphaUse", err))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).MoveResistance
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LiquidMovePhysics
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).InsideTintShaded
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *NodeDef) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Param0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			var local239 uint8
			local240 := uint8(13)
			{
				p := &local239
				*p = read8(r)
			}
			if local239 != local240 {
				chk(fmt.Errorf("const %v: %v", "uint8(13)", local239))
			}
		}
		var local241 []uint8
		var local242 uint16
		{
			p := &local242
			*p = read16(r)
		}
		(local241) = make([]uint8, local242)
		{
			_, err := io.ReadFull(r, (local241)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Name) = string(local241)
		var local243 uint16
		{
			p := &local243
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Groups) = make([]Group, local243)
		for local244 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).Groups)[local244]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).P1Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param1Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).P2Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Param2Type", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DrawType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DrawType", err))
		}
		var local245 []uint8
		var local246 uint16
		{
			p := &local246
			*p = read16(r)
		}
		(local245) = make([]uint8, local246)
		{
			_, err := io.ReadFull(r, (local245)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Mesh) = string(local245)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Scale
			*p = math.Float32frombits(read32(r))
		}
		{
			var local247 uint8
			local248 := uint8(6)
			{
				p := &local247
				*p = read8(r)
			}
			if local247 != local248 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local247))
			}
		}
		for local249 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).Tiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).Tiles)[local249]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		for local250 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).OverlayTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).OverlayTiles)[local250]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			var local251 uint8
			local252 := uint8(6)
			{
				p := &local251
				*p = read8(r)
			}
			if local251 != local252 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local251))
			}
		}
		for local253 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).SpecialTiles {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).SpecialTiles)[local253]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileDef", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Palette).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Waving).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.WaveType", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).ConnectSides
			*p = read8(r)
		}
		var local254 uint16
		{
			p := &local254
			*p = read16(r)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).ConnectTo) = make([]Content, local254)
		for local255 := range (*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).ConnectTo {
			if err := pcall(func() {
				(((*(*(struct {
					Param0 Content

					Name   string
					Groups []Group

					P1Type   Param1Type
					P2Type   Param2Type
					DrawType DrawType

					Mesh  string
					Scale float32
					//mt:const uint8(6)
					Tiles        [6]TileDef
					OverlayTiles [6]TileDef
					//mt:const uint8(6)
					SpecialTiles [6]TileDef

					Color   color.NRGBA
					Palette Texture

					Waving       WaveType
					ConnectSides uint8
					ConnectTo    []Content
					InsideTint   color.NRGBA
					Level        uint8 // Must be < 128.

					Translucent bool // Sunlight is scattered and becomes normal light.
					Transparent bool // Sunlight isn't scattered.
					LightSrc    uint8

					GndContent   bool
					Collides     bool
					PointType    PointabilityType
					Diggable     bool
					Climbable    bool
					Replaceable  bool
					OnRightClick bool

					DmgPerSec int32

					LiquidType   LiquidType
					FlowingAlt   string
					SrcAlt       string
					Viscosity    uint8 // 0-7
					LiqRenewable bool
					FlowRange    uint8
					DrownDmg     uint8
					Floodable    bool

					DrawBox, ColBox, SelBox NodeBox

					FootstepSnd, DiggingSnd, DugSnd SoundDef

					LegacyFaceDir bool
					LegacyMounted bool

					DigPredict string

					MaxLvl uint8

					AlphaUse

					MoveResistance    uint8
					LiquidMovePhysics bool
					InsideTintShaded  bool
				}))(obj)).ConnectTo)[local255]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).InsideTint
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Level
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Translucent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Transparent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LightSrc
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).GndContent
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Collides
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).PointType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PointabilityType", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Diggable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Climbable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Replaceable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).OnRightClick
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DmgPerSec
			*p = int32(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LiquidType).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LiquidType", err))
		}
		var local256 []uint8
		var local257 uint16
		{
			p := &local257
			*p = read16(r)
		}
		(local256) = make([]uint8, local257)
		{
			_, err := io.ReadFull(r, (local256)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).FlowingAlt) = string(local256)
		var local258 []uint8
		var local259 uint16
		{
			p := &local259
			*p = read16(r)
		}
		(local258) = make([]uint8, local259)
		{
			_, err := io.ReadFull(r, (local258)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).SrcAlt) = string(local258)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Viscosity
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LiqRenewable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).FlowRange
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DrownDmg
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).Floodable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DrawBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).ColBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).SelBox).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBox", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).FootstepSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DiggingSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).DugSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LegacyFaceDir
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LegacyMounted
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		var local260 []uint8
		var local261 uint16
		{
			p := &local261
			*p = read16(r)
		}
		(local260) = make([]uint8, local261)
		{
			_, err := io.ReadFull(r, (local260)[:])
			chk(err)
		}
		((*(*(struct {
			Param0 Content

			Name   string
			Groups []Group

			P1Type   Param1Type
			P2Type   Param2Type
			DrawType DrawType

			Mesh  string
			Scale float32
			//mt:const uint8(6)
			Tiles        [6]TileDef
			OverlayTiles [6]TileDef
			//mt:const uint8(6)
			SpecialTiles [6]TileDef

			Color   color.NRGBA
			Palette Texture

			Waving       WaveType
			ConnectSides uint8
			ConnectTo    []Content
			InsideTint   color.NRGBA
			Level        uint8 // Must be < 128.

			Translucent bool // Sunlight is scattered and becomes normal light.
			Transparent bool // Sunlight isn't scattered.
			LightSrc    uint8

			GndContent   bool
			Collides     bool
			PointType    PointabilityType
			Diggable     bool
			Climbable    bool
			Replaceable  bool
			OnRightClick bool

			DmgPerSec int32

			LiquidType   LiquidType
			FlowingAlt   string
			SrcAlt       string
			Viscosity    uint8 // 0-7
			LiqRenewable bool
			FlowRange    uint8
			DrownDmg     uint8
			Floodable    bool

			DrawBox, ColBox, SelBox NodeBox

			FootstepSnd, DiggingSnd, DugSnd SoundDef

			LegacyFaceDir bool
			LegacyMounted bool

			DigPredict string

			MaxLvl uint8

			AlphaUse

			MoveResistance    uint8
			LiquidMovePhysics bool
			InsideTintShaded  bool
		}))(obj)).DigPredict) = string(local260)
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).MaxLvl
			*p = read8(r)
		}
		if err := pcall(func() {
			((*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).AlphaUse).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlphaUse", err))
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).MoveResistance
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).LiquidMovePhysics
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Param0 Content

				Name   string
				Groups []Group

				P1Type   Param1Type
				P2Type   Param2Type
				DrawType DrawType

				Mesh  string
				Scale float32
				//mt:const uint8(6)
				Tiles        [6]TileDef
				OverlayTiles [6]TileDef
				//mt:const uint8(6)
				SpecialTiles [6]TileDef

				Color   color.NRGBA
				Palette Texture

				Waving       WaveType
				ConnectSides uint8
				ConnectTo    []Content
				InsideTint   color.NRGBA
				Level        uint8 // Must be < 128.

				Translucent bool // Sunlight is scattered and becomes normal light.
				Transparent bool // Sunlight isn't scattered.
				LightSrc    uint8

				GndContent   bool
				Collides     bool
				PointType    PointabilityType
				Diggable     bool
				Climbable    bool
				Replaceable  bool
				OnRightClick bool

				DmgPerSec int32

				LiquidType   LiquidType
				FlowingAlt   string
				SrcAlt       string
				Viscosity    uint8 // 0-7
				LiqRenewable bool
				FlowRange    uint8
				DrownDmg     uint8
				Floodable    bool

				DrawBox, ColBox, SelBox NodeBox

				FootstepSnd, DiggingSnd, DugSnd SoundDef

				LegacyFaceDir bool
				LegacyMounted bool

				DigPredict string

				MaxLvl uint8

				AlphaUse

				MoveResistance    uint8
				LiquidMovePhysics bool
				InsideTintShaded  bool
			}))(obj)).InsideTintShaded
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *PointedNode) serialize(w io.Writer) {
	for local262 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local262]
			write16(w, uint16(x))
		}
	}
	for local263 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			x := ((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local263]
			write16(w, uint16(x))
		}
	}
}

func (obj *PointedNode) deserialize(r io.Reader) {
	for local264 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Under {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Under)[local264]
			*p = int16(read16(r))
		}
	}
	for local265 := range (*(*(struct {
		Under, Above [3]int16
	}))(obj)).Above {
		{
			p := &((*(*(struct {
				Under, Above [3]int16
			}))(obj)).Above)[local265]
			*p = int16(read16(r))
		}
	}
}

func (obj *PointedAO) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
}

func (obj *PointedAO) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
}

func (obj *CompressionModes) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *CompressionModes) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *PlayerPos) serialize(w io.Writer) {
	for local266 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
		Flags            PlayerPosFlags
		Speed            float32
		Dir              float32
	}))(obj)).Pos100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
				Flags            PlayerPosFlags
				Speed            float32
				Dir              float32
			}))(obj)).Pos100)[local266]
			write32(w, uint32(x))
		}
	}
	for local267 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
		Flags            PlayerPosFlags
		Speed            float32
		Dir              float32
	}))(obj)).Vel100 {
		{
			x := ((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
				Flags            PlayerPosFlags
				Speed            float32
				Dir              float32
			}))(obj)).Vel100)[local267]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Pitch100
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Yaw100
		write32(w, uint32(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Keys).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Keys", err))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).FOV80
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).WantedRange
		write8(w, uint8(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPosFlags", err))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Dir
		write32(w, math.Float32bits(x))
	}
}

func (obj *PlayerPos) deserialize(r io.Reader) {
	for local268 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
		Flags            PlayerPosFlags
		Speed            float32
		Dir              float32
	}))(obj)).Pos100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
				Flags            PlayerPosFlags
				Speed            float32
				Dir              float32
			}))(obj)).Pos100)[local268]
			*p = int32(read32(r))
		}
	}
	for local269 := range (*(*(struct {
		Pos100, Vel100   [3]int32
		Pitch100, Yaw100 int32
		Keys             Keys
		FOV80            uint8
		WantedRange      uint8 // in MapBlks.
		Flags            PlayerPosFlags
		Speed            float32
		Dir              float32
	}))(obj)).Vel100 {
		{
			p := &((*(*(struct {
				Pos100, Vel100   [3]int32
				Pitch100, Yaw100 int32
				Keys             Keys
				FOV80            uint8
				WantedRange      uint8 // in MapBlks.
				Flags            PlayerPosFlags
				Speed            float32
				Dir              float32
			}))(obj)).Vel100)[local269]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Pitch100
		*p = int32(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Yaw100
		*p = int32(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Keys).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Keys", err))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).FOV80
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).WantedRange
		*p = read8(r)
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PlayerPosFlags", err))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos100, Vel100   [3]int32
			Pitch100, Yaw100 int32
			Keys             Keys
			FOV80            uint8
			WantedRange      uint8 // in MapBlks.
			Flags            PlayerPosFlags
			Speed            float32
			Dir              float32
		}))(obj)).Dir
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *Interaction) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Interaction) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *SoundID) serialize(w io.Writer) {
	{
		x := *(*(int32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *SoundID) deserialize(r io.Reader) {
	{
		p := &*(*(int32))(obj)
		*p = int32(read32(r))
	}
}

func (obj *Field) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Name))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value))) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))))
		write32(w, uint32(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:len32
			Value string
		}))(obj)).Value))[:])
		chk(err)
	}
}

func (obj *Field) deserialize(r io.Reader) {
	var local270 []uint8
	var local271 uint16
	{
		p := &local271
		*p = read16(r)
	}
	(local270) = make([]uint8, local271)
	{
		_, err := io.ReadFull(r, (local270)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Name) = string(local270)
	var local272 []uint8
	var local273 uint32
	{
		p := &local273
		*p = read32(r)
	}
	(local272) = make([]uint8, local273)
	{
		_, err := io.ReadFull(r, (local272)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:len32
		Value string
	}))(obj)).Value) = string(local272)
}

func (obj *AuthMethods) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *AuthMethods) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *Pos) serialize(w io.Writer) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *Pos) deserialize(r io.Reader) {
	if err := pcall(func() {
		(*(*(Vec))(obj)).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
}

func (obj *KickReason) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *KickReason) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *MapBlk) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LitFromBlks", err))
	}
	{
		local274 := uint8(2) // Size of param0 in bytes.
		{
			x := local274
			write8(w, uint8(x))
		}
	}
	{
		local275 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			x := local275
			write8(w, uint8(x))
		}
	}
	for local276 := range (*(*(struct {
		Flags   MapBlkFlags
		LitFrom LitFromBlks

		Param0 [4096]Content
		Param1 [4096]uint8
		Param2 [4096]uint8

		NodeMetas map[uint16]*NodeMeta
	}))(obj)).Param0 {
		if err := pcall(func() {
			(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param0)[local276]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
		}
	}
	{
		_, err := w.Write(((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param1)[:])
		chk(err)
	}
	{
		_, err := w.Write(((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param2)[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			if x == nil {
				write8(w, 0)
			} else {
				write8(w, 2)
				// len(map[uint16]...) always < math.MaxUint16
				write16(w, uint16(len(x)))
				keys := make([]uint16, 0, len(x))
				for key := range x {
					keys = append(keys, key)
				}
				sort.Slice(keys, func(i, j int) bool {
					i2pos := func(i int) [3]int16 {
						return Blkpos2Pos([3]int16{}, keys[i])
					}
					p, q := i2pos(i), i2pos(j)
					for i := range p {
						switch {
						case p[i] < q[i]:
							return true
						case p[i] > q[i]:
							return false
						}
					}
					return false
				})
				for _, key := range keys {
					write16(w, key)
					chk(serialize(w, x[key]))
				}
			}
		}
	}
}

func (obj *MapBlk) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.MapBlkFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).LitFrom).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.LitFromBlks", err))
	}
	{
		var local277 uint8
		local278 := uint8(2) // Size of param0 in bytes.
		{
			p := &local277
			*p = read8(r)
		}
		if local277 != local278 {
			chk(fmt.Errorf("const %v: %v", "uint8(2)     // Size of param0 in bytes.", local277))
		}
	}
	{
		var local279 uint8
		local280 := uint8(1 + 1) // Size of param1 and param2 combined, in bytes.
		{
			p := &local279
			*p = read8(r)
		}
		if local279 != local280 {
			chk(fmt.Errorf("const %v: %v", "uint8(1 + 1) // Size of param1 and param2 combined, in bytes.", local279))
		}
	}
	for local281 := range (*(*(struct {
		Flags   MapBlkFlags
		LitFrom LitFromBlks

		Param0 [4096]Content
		Param1 [4096]uint8
		Param2 [4096]uint8

		NodeMetas map[uint16]*NodeMeta
	}))(obj)).Param0 {
		if err := pcall(func() {
			(((*(*(struct {
				Flags   MapBlkFlags
				LitFrom LitFromBlks

				Param0 [4096]Content
				Param1 [4096]uint8
				Param2 [4096]uint8

				NodeMetas map[uint16]*NodeMeta
			}))(obj)).Param0)[local281]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
		}
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param1)[:])
		chk(err)
	}
	{
		_, err := io.ReadFull(r, ((*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).Param2)[:])
		chk(err)
	}
	{
		p := &(*(*(struct {
			Flags   MapBlkFlags
			LitFrom LitFromBlks

			Param0 [4096]Content
			Param1 [4096]uint8
			Param2 [4096]uint8

			NodeMetas map[uint16]*NodeMeta
		}))(obj)).NodeMetas
		{
			switch ver := read8(r); ver {
			case 0:
				*p = nil
			case 2:
				n := read16(r)
				*p = make(map[uint16]*NodeMeta, n)
				for ; n > 0; n-- {
					pos := read16(r)
					nm := new(NodeMeta)
					chk(deserialize(r, nm))
					(*p)[pos] = nm
				}
			default:
				chk(fmt.Errorf("unsupported nodemetas version: %d", ver))
			}
		}
	}
}

func (obj *Node) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		write8(w, uint8(x))
	}
}

func (obj *Node) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param1
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			Param0         Content
			Param1, Param2 uint8
		}))(obj)).Param2
		*p = read8(r)
	}
}

func (obj *CSMRestrictionFlags) serialize(w io.Writer) {
	{
		x := *(*(uint64))(obj)
		write64(w, uint64(x))
	}
}

func (obj *CSMRestrictionFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint64))(obj)
		*p = read64(r)
	}
}

func (obj *Vec) serialize(w io.Writer) {
	for local282 := range *(*([3]float32))(obj) {
		{
			x := (*(*([3]float32))(obj))[local282]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *Vec) deserialize(r io.Reader) {
	for local283 := range *(*([3]float32))(obj) {
		{
			p := &(*(*([3]float32))(obj))[local283]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ChatMsgType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ChatMsgType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOID) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *AOID) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AOAdd) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		local284 := genericCAO
		if err := pcall(func() {
			(local284).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		if err := pcall(func() {
			((*(*(struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}))(obj)).InitData).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOInitData", err))
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint32 {
				chk(ErrTooLong)
			}
			{
				x := uint32(len((buf.Bytes())))
				write32(w, uint32(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *AOAdd) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:const genericCAO
			//mt:lenhdr 32
			InitData AOInitData
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var local285 aoType
		local286 := genericCAO
		if err := pcall(func() {
			(local285).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.aoType", err))
		}
		if local285 != local286 {
			chk(fmt.Errorf("const %v: %v", "genericCAO", local285))
		}
	}
	{
		var n uint32
		{
			p := &n
			*p = read32(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		if err := pcall(func() {
			((*(*(struct {
				ID AOID
				//mt:const genericCAO
				//mt:lenhdr 32
				InitData AOInitData
			}))(obj)).InitData).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOInitData", err))
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *IDAOMsg) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		ow := w
		w := new(bytes.Buffer)
		{
			x := (*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			writeAOMsg(w, x)
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *IDAOMsg) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ID AOID
			//mt:lenhdr 16
			Msg AOMsg
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			p := &(*(*(struct {
				ID AOID
				//mt:lenhdr 16
				Msg AOMsg
			}))(obj)).Msg
			{
				var err error
				*p, err = readAOMsg(r)
				chk(err)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *ItemDef) serialize(w io.Writer) {
	{
		ow := w
		w := new(bytes.Buffer)
		{
			local287 := uint8(6)
			{
				x := local287
				write8(w, uint8(x))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Type).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemType", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Name))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Name))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Name))[:])
			chk(err)
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Desc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Desc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Desc))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).InvImg).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).WieldImg).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		for local288 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).WieldScale {
			{
				x := ((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					SoundUse    SoundDef
					SoundUseAir SoundDef

					HasPlaceParam2 bool

					//mt:if %s.HasPlaceParam2
					PlaceParam2 uint8

					WallmountedRotateVertical bool
					TouchInteraction          TouchInteraction

					Pointabilities string

					HasWearBarParams bool

					//mt:if %s.HasWearBarParams
					WearBarParams WearBarParams
				}))(obj)).WieldScale)[local288]
				write32(w, math.Float32bits(x))
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).StackMax
			write16(w, uint16(x))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Usable
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).CanPointLiquids
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).ToolCaps).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolCaps", err))
		}
		if len(((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Groups)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Groups)))
			write16(w, uint16(x))
		}
		for local289 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					SoundUse    SoundDef
					SoundUseAir SoundDef

					HasPlaceParam2 bool

					//mt:if %s.HasPlaceParam2
					PlaceParam2 uint8

					WallmountedRotateVertical bool
					TouchInteraction          TouchInteraction

					Pointabilities string

					HasWearBarParams bool

					//mt:if %s.HasWearBarParams
					WearBarParams WearBarParams
				}))(obj)).Groups)[local289]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).PlacePredict))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).PlacePredict))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).PlacePredict))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).PlaceSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).PlaceFailSnd).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).PointRange
			write32(w, math.Float32bits(x))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Palette).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Color
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).InvOverlay).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).WieldOverlay).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).ShortDesc))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).ShortDesc))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).ShortDesc))[:])
			chk(err)
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).SoundUse).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).SoundUseAir).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).HasPlaceParam2
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).HasPlaceParam2 {
			{
				x := (*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					SoundUse    SoundDef
					SoundUseAir SoundDef

					HasPlaceParam2 bool

					//mt:if %s.HasPlaceParam2
					PlaceParam2 uint8

					WallmountedRotateVertical bool
					TouchInteraction          TouchInteraction

					Pointabilities string

					HasWearBarParams bool

					//mt:if %s.HasWearBarParams
					WearBarParams WearBarParams
				}))(obj)).PlaceParam2
				write8(w, uint8(x))
			}
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).WallmountedRotateVertical
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).TouchInteraction).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TouchInteraction", err))
		}
		if len(([]byte((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Pointabilities))) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Pointabilities))))
			write16(w, uint16(x))
		}
		{
			_, err := w.Write(([]byte((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Pointabilities))[:])
			chk(err)
		}
		{
			x := (*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).HasWearBarParams
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
		if (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).HasWearBarParams {
			if err := pcall(func() {
				((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					SoundUse    SoundDef
					SoundUseAir SoundDef

					HasPlaceParam2 bool

					//mt:if %s.HasPlaceParam2
					PlaceParam2 uint8

					WallmountedRotateVertical bool
					TouchInteraction          TouchInteraction

					Pointabilities string

					HasWearBarParams bool

					//mt:if %s.HasWearBarParams
					WearBarParams WearBarParams
				}))(obj)).WearBarParams).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.WearBarParams", err))
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ItemDef) deserialize(r io.Reader) {
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		{
			var local290 uint8
			local291 := uint8(6)
			{
				p := &local290
				*p = read8(r)
			}
			if local290 != local291 {
				chk(fmt.Errorf("const %v: %v", "uint8(6)", local290))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Type).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ItemType", err))
		}
		var local292 []uint8
		var local293 uint16
		{
			p := &local293
			*p = read16(r)
		}
		(local292) = make([]uint8, local293)
		{
			_, err := io.ReadFull(r, (local292)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Name) = string(local292)
		var local294 []uint8
		var local295 uint16
		{
			p := &local295
			*p = read16(r)
		}
		(local294) = make([]uint8, local295)
		{
			_, err := io.ReadFull(r, (local294)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Desc) = string(local294)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).InvImg).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).WieldImg).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		for local296 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).WieldScale {
			{
				p := &((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					SoundUse    SoundDef
					SoundUseAir SoundDef

					HasPlaceParam2 bool

					//mt:if %s.HasPlaceParam2
					PlaceParam2 uint8

					WallmountedRotateVertical bool
					TouchInteraction          TouchInteraction

					Pointabilities string

					HasWearBarParams bool

					//mt:if %s.HasWearBarParams
					WearBarParams WearBarParams
				}))(obj)).WieldScale)[local296]
				*p = math.Float32frombits(read32(r))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).StackMax
			*p = read16(r)
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Usable
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).CanPointLiquids
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).ToolCaps).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolCaps", err))
		}
		var local297 uint16
		{
			p := &local297
			*p = read16(r)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Groups) = make([]Group, local297)
		for local298 := range (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Groups {
			if err := pcall(func() {
				(((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					SoundUse    SoundDef
					SoundUseAir SoundDef

					HasPlaceParam2 bool

					//mt:if %s.HasPlaceParam2
					PlaceParam2 uint8

					WallmountedRotateVertical bool
					TouchInteraction          TouchInteraction

					Pointabilities string

					HasWearBarParams bool

					//mt:if %s.HasWearBarParams
					WearBarParams WearBarParams
				}))(obj)).Groups)[local298]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
			}
		}
		var local299 []uint8
		var local300 uint16
		{
			p := &local300
			*p = read16(r)
		}
		(local299) = make([]uint8, local300)
		{
			_, err := io.ReadFull(r, (local299)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).PlacePredict) = string(local299)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).PlaceSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).PlaceFailSnd).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).PointRange
			*p = math.Float32frombits(read32(r))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Palette).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).Color
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).InvOverlay).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).WieldOverlay).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
		var local301 []uint8
		var local302 uint16
		{
			p := &local302
			*p = read16(r)
		}
		(local301) = make([]uint8, local302)
		{
			_, err := io.ReadFull(r, (local301)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).ShortDesc) = string(local301)
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).SoundUse).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).SoundUseAir).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.SoundDef", err))
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).HasPlaceParam2
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).HasPlaceParam2 {
			{
				p := &(*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					SoundUse    SoundDef
					SoundUseAir SoundDef

					HasPlaceParam2 bool

					//mt:if %s.HasPlaceParam2
					PlaceParam2 uint8

					WallmountedRotateVertical bool
					TouchInteraction          TouchInteraction

					Pointabilities string

					HasWearBarParams bool

					//mt:if %s.HasWearBarParams
					WearBarParams WearBarParams
				}))(obj)).PlaceParam2
				*p = read8(r)
			}
		}
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).WallmountedRotateVertical
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if err := pcall(func() {
			((*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).TouchInteraction).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TouchInteraction", err))
		}
		var local303 []uint8
		var local304 uint16
		{
			p := &local304
			*p = read16(r)
		}
		(local303) = make([]uint8, local304)
		{
			_, err := io.ReadFull(r, (local303)[:])
			chk(err)
		}
		((*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).Pointabilities) = string(local303)
		{
			p := &(*(*(struct {
				Type ItemType

				Name, Desc string

				InvImg, WieldImg Texture
				WieldScale       [3]float32

				StackMax uint16

				Usable          bool
				CanPointLiquids bool

				ToolCaps ToolCaps

				Groups []Group

				PlacePredict string

				PlaceSnd, PlaceFailSnd SoundDef

				PointRange float32

				// Set index in Palette with "palette_index" item meta field,
				// this overrides Color.
				Palette Texture
				Color   color.NRGBA

				// Texture overlays.
				InvOverlay, WieldOverlay Texture

				ShortDesc string

				SoundUse    SoundDef
				SoundUseAir SoundDef

				HasPlaceParam2 bool

				//mt:if %s.HasPlaceParam2
				PlaceParam2 uint8

				WallmountedRotateVertical bool
				TouchInteraction          TouchInteraction

				Pointabilities string

				HasWearBarParams bool

				//mt:if %s.HasWearBarParams
				WearBarParams WearBarParams
			}))(obj)).HasWearBarParams
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
		if (*(*(struct {
			Type ItemType

			Name, Desc string

			InvImg, WieldImg Texture
			WieldScale       [3]float32

			StackMax uint16

			Usable          bool
			CanPointLiquids bool

			ToolCaps ToolCaps

			Groups []Group

			PlacePredict string

			PlaceSnd, PlaceFailSnd SoundDef

			PointRange float32

			// Set index in Palette with "palette_index" item meta field,
			// this overrides Color.
			Palette Texture
			Color   color.NRGBA

			// Texture overlays.
			InvOverlay, WieldOverlay Texture

			ShortDesc string

			SoundUse    SoundDef
			SoundUseAir SoundDef

			HasPlaceParam2 bool

			//mt:if %s.HasPlaceParam2
			PlaceParam2 uint8

			WallmountedRotateVertical bool
			TouchInteraction          TouchInteraction

			Pointabilities string

			HasWearBarParams bool

			//mt:if %s.HasWearBarParams
			WearBarParams WearBarParams
		}))(obj)).HasWearBarParams {
			if err := pcall(func() {
				((*(*(struct {
					Type ItemType

					Name, Desc string

					InvImg, WieldImg Texture
					WieldScale       [3]float32

					StackMax uint16

					Usable          bool
					CanPointLiquids bool

					ToolCaps ToolCaps

					Groups []Group

					PlacePredict string

					PlaceSnd, PlaceFailSnd SoundDef

					PointRange float32

					// Set index in Palette with "palette_index" item meta field,
					// this overrides Color.
					Palette Texture
					Color   color.NRGBA

					// Texture overlays.
					InvOverlay, WieldOverlay Texture

					ShortDesc string

					SoundUse    SoundDef
					SoundUseAir SoundDef

					HasPlaceParam2 bool

					//mt:if %s.HasPlaceParam2
					PlaceParam2 uint8

					WallmountedRotateVertical bool
					TouchInteraction          TouchInteraction

					Pointabilities string

					HasWearBarParams bool

					//mt:if %s.HasWearBarParams
					WearBarParams WearBarParams
				}))(obj)).WearBarParams).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.WearBarParams", err))
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *SoundSrcType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *SoundSrcType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileAnim) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := w.Write(((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local305 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				x := ((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local305]
				write16(w, uint16(x))
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			x := (*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TileAnim) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AnimType", err))
	}
	if !((*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type < maxAnim) {
		chk(errors.New("assertion failed: %s.Type < maxAnim"))
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == SpriteSheetAnim {
		{
			_, err := io.ReadFull(r, ((*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).AspectRatio)[:])
			chk(err)
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type == VerticalFrameAnim {
		for local306 := range (*(*(struct {
			Type AnimType

			//mt:if %s.Type == SpriteSheetAnim
			AspectRatio [2]uint8

			//mt:if %s.Type == VerticalFrameAnim
			NFrames [2]uint16

			//mt:if %s.Type != NoAnim
			Duration float32 // in seconds

		}))(obj)).NFrames {
			{
				p := &((*(*(struct {
					Type AnimType

					//mt:if %s.Type == SpriteSheetAnim
					AspectRatio [2]uint8

					//mt:if %s.Type == VerticalFrameAnim
					NFrames [2]uint16

					//mt:if %s.Type != NoAnim
					Duration float32 // in seconds

				}))(obj)).NFrames)[local306]
				*p = read16(r)
			}
		}
	}
	if (*(*(struct {
		Type AnimType

		//mt:if %s.Type == SpriteSheetAnim
		AspectRatio [2]uint8

		//mt:if %s.Type == VerticalFrameAnim
		NFrames [2]uint16

		//mt:if %s.Type != NoAnim
		Duration float32 // in seconds

	}))(obj)).Type != NoAnim {
		{
			p := &(*(*(struct {
				Type AnimType

				//mt:if %s.Type == SpriteSheetAnim
				AspectRatio [2]uint8

				//mt:if %s.Type == VerticalFrameAnim
				NFrames [2]uint16

				//mt:if %s.Type != NoAnim
				Duration float32 // in seconds

			}))(obj)).Duration
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *Content) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *Content) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *RangeV3F32) serialize(w io.Writer) {
	for local307 := range (*(*(struct {
		Min, Max [3]float32
		Bias     float32
	}))(obj)).Min {
		{
			x := ((*(*(struct {
				Min, Max [3]float32
				Bias     float32
			}))(obj)).Min)[local307]
			write32(w, math.Float32bits(x))
		}
	}
	for local308 := range (*(*(struct {
		Min, Max [3]float32
		Bias     float32
	}))(obj)).Max {
		{
			x := ((*(*(struct {
				Min, Max [3]float32
				Bias     float32
			}))(obj)).Max)[local308]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Min, Max [3]float32
			Bias     float32
		}))(obj)).Bias
		write32(w, math.Float32bits(x))
	}
}

func (obj *RangeV3F32) deserialize(r io.Reader) {
	for local309 := range (*(*(struct {
		Min, Max [3]float32
		Bias     float32
	}))(obj)).Min {
		{
			p := &((*(*(struct {
				Min, Max [3]float32
				Bias     float32
			}))(obj)).Min)[local309]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local310 := range (*(*(struct {
		Min, Max [3]float32
		Bias     float32
	}))(obj)).Max {
		{
			p := &((*(*(struct {
				Min, Max [3]float32
				Bias     float32
			}))(obj)).Max)[local310]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Min, Max [3]float32
			Bias     float32
		}))(obj)).Bias
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *RangeF32) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Min
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Max
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Bias
		write32(w, math.Float32bits(x))
	}
}

func (obj *RangeF32) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Min
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Max
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Min, Max float32
			Bias     float32
		}))(obj)).Bias
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *ParticleTexture) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTextureFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Alpha).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Scale).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV2F32", err))
	}
	if (*(*(struct {
		Flags ParticleTextureFlags
		Alpha TweenF32
		Scale TweenV2F32

		//mt:if %s.Flags & Animated == Animated
		Animation TileAnim
	}))(obj)).Flags&Animated == Animated {
		if err := pcall(func() {
			((*(*(struct {
				Flags ParticleTextureFlags
				Alpha TweenF32
				Scale TweenV2F32

				//mt:if %s.Flags & Animated == Animated
				Animation TileAnim
			}))(obj)).Animation).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
		}
	}
}

func (obj *ParticleTexture) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ParticleTextureFlags", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Alpha).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Flags ParticleTextureFlags
			Alpha TweenF32
			Scale TweenV2F32

			//mt:if %s.Flags & Animated == Animated
			Animation TileAnim
		}))(obj)).Scale).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenV2F32", err))
	}
	if (*(*(struct {
		Flags ParticleTextureFlags
		Alpha TweenF32
		Scale TweenV2F32

		//mt:if %s.Flags & Animated == Animated
		Animation TileAnim
	}))(obj)).Flags&Animated == Animated {
		if err := pcall(func() {
			((*(*(struct {
				Flags ParticleTextureFlags
				Alpha TweenF32
				Scale TweenV2F32

				//mt:if %s.Flags & Animated == Animated
				Animation TileAnim
			}))(obj)).Animation).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
		}
	}
}

func (obj *TweenRangeV3F32) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).Style).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).Reps
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).Beginning
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).Start).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).End).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
}

func (obj *TweenRangeV3F32) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).Style).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).Reps
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).Beginning
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).Start).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeV3F32
		}))(obj)).End).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeV3F32", err))
	}
}

func (obj *TweenRangeF32) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).Style).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).Reps
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).Beginning
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).Start).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).End).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
}

func (obj *TweenRangeF32) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).Style).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).Reps
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).Beginning
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).Start).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End RangeF32
		}))(obj)).End).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.RangeF32", err))
	}
}

func (obj *ParticleSpawnerID) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *ParticleSpawnerID) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *AttractionKind) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AttractionKind) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TweenV3F32) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [3]float32
		}))(obj)).Style).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [3]float32
		}))(obj)).Reps
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [3]float32
		}))(obj)).Beginning
		write32(w, math.Float32bits(x))
	}
	for local311 := range (*(*(struct {
		Style      TweenStyle
		Reps       uint16
		Beginning  float32
		Start, End [3]float32
	}))(obj)).Start {
		{
			x := ((*(*(struct {
				Style      TweenStyle
				Reps       uint16
				Beginning  float32
				Start, End [3]float32
			}))(obj)).Start)[local311]
			write32(w, math.Float32bits(x))
		}
	}
	for local312 := range (*(*(struct {
		Style      TweenStyle
		Reps       uint16
		Beginning  float32
		Start, End [3]float32
	}))(obj)).End {
		{
			x := ((*(*(struct {
				Style      TweenStyle
				Reps       uint16
				Beginning  float32
				Start, End [3]float32
			}))(obj)).End)[local312]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TweenV3F32) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [3]float32
		}))(obj)).Style).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [3]float32
		}))(obj)).Reps
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [3]float32
		}))(obj)).Beginning
		*p = math.Float32frombits(read32(r))
	}
	for local313 := range (*(*(struct {
		Style      TweenStyle
		Reps       uint16
		Beginning  float32
		Start, End [3]float32
	}))(obj)).Start {
		{
			p := &((*(*(struct {
				Style      TweenStyle
				Reps       uint16
				Beginning  float32
				Start, End [3]float32
			}))(obj)).Start)[local313]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local314 := range (*(*(struct {
		Style      TweenStyle
		Reps       uint16
		Beginning  float32
		Start, End [3]float32
	}))(obj)).End {
		{
			p := &((*(*(struct {
				Style      TweenStyle
				Reps       uint16
				Beginning  float32
				Start, End [3]float32
			}))(obj)).End)[local314]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *ParticleSpawnerFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ParticleSpawnerFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDID) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDID) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUD) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDType", err))
	}
	for local315 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Pos {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Pos)[local315]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Name))[:])
		chk(err)
	}
	for local316 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Scale {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Scale)[local316]
			write32(w, math.Float32bits(x))
		}
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Number
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Item
		write32(w, uint32(x))
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Dir
		write32(w, uint32(x))
	}
	for local317 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Align {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Align)[local317]
			write32(w, math.Float32bits(x))
		}
	}
	for local318 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Offset {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Offset)[local318]
			write32(w, math.Float32bits(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).WorldPos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local319 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Size {
		{
			x := ((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Size)[local319]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).ZIndex
		write16(w, uint16(x))
	}
	if len(([]byte((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text2))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text2))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Text2))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Style).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
	}
}

func (obj *HUD) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDType", err))
	}
	for local320 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Pos {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Pos)[local320]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local321 []uint8
	var local322 uint16
	{
		p := &local322
		*p = read16(r)
	}
	(local321) = make([]uint8, local322)
	{
		_, err := io.ReadFull(r, (local321)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Name) = string(local321)
	for local323 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Scale {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Scale)[local323]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local324 []uint8
	var local325 uint16
	{
		p := &local325
		*p = read16(r)
	}
	(local324) = make([]uint8, local325)
	{
		_, err := io.ReadFull(r, (local324)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text) = string(local324)
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Number
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Item
		*p = read32(r)
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Dir
		*p = read32(r)
	}
	for local326 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Align {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Align)[local326]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local327 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Offset {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Offset)[local327]
			*p = math.Float32frombits(read32(r))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).WorldPos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local328 := range (*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Size {
		{
			p := &((*(*(struct {
				Type HUDType

				Pos      [2]float32
				Name     string
				Scale    [2]float32
				Text     string
				Number   uint32
				Item     uint32
				Dir      uint32
				Align    [2]float32
				Offset   [2]float32
				WorldPos Pos
				Size     [2]int32
				ZIndex   int16
				Text2    string
				Style    HUDStyleFlags
			}))(obj)).Size)[local328]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).ZIndex
		*p = int16(read16(r))
	}
	var local329 []uint8
	var local330 uint16
	{
		p := &local330
		*p = read16(r)
	}
	(local329) = make([]uint8, local330)
	{
		_, err := io.ReadFull(r, (local329)[:])
		chk(err)
	}
	((*(*(struct {
		Type HUDType

		Pos      [2]float32
		Name     string
		Scale    [2]float32
		Text     string
		Number   uint32
		Item     uint32
		Dir      uint32
		Align    [2]float32
		Offset   [2]float32
		WorldPos Pos
		Size     [2]int32
		ZIndex   int16
		Text2    string
		Style    HUDStyleFlags
	}))(obj)).Text2) = string(local329)
	if err := pcall(func() {
		((*(*(struct {
			Type HUDType

			Pos      [2]float32
			Name     string
			Scale    [2]float32
			Text     string
			Number   uint32
			Item     uint32
			Dir      uint32
			Align    [2]float32
			Offset   [2]float32
			WorldPos Pos
			Size     [2]int32
			ZIndex   int16
			Text2    string
			Style    HUDStyleFlags
		}))(obj)).Style).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.HUDStyleFlags", err))
	}
}

func (obj *HUDField) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDField) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDStyleFlags) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDStyleFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HUDFlags) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *HUDFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *HotbarParam) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *HotbarParam) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Texture) serialize(w io.Writer) {
	if len(([]byte(*(*(string))(obj)))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte(*(*(string))(obj)))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte(*(*(string))(obj)))[:])
		chk(err)
	}
}

func (obj *Texture) deserialize(r io.Reader) {
	var local331 []uint8
	var local332 uint16
	{
		p := &local332
		*p = read16(r)
	}
	(local331) = make([]uint8, local332)
	{
		_, err := io.ReadFull(r, (local331)[:])
		chk(err)
	}
	(*(*(string))(obj)) = string(local331)
}

func (obj *PlayerListUpdateType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *PlayerListUpdateType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ModChanSig) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ModChanSig) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *AOProps) serialize(w io.Writer) {
	{
		local333 := uint8(4)
		{
			x := local333
			write8(w, uint8(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).MaxHP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).CollideWithNodes
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Weight
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).ColBox).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).SelBox).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Pointable).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PointabilityType", err))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Visual))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Visual))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Visual))[:])
		chk(err)
	}
	for local334 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).VisualSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).VisualSize)[local334]
			write32(w, math.Float32bits(x))
		}
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Textures)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Textures)))
		write16(w, uint16(x))
	}
	for local335 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).Textures)[local335]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
	for local336 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).SpriteSheetSize {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).SpriteSheetSize)[local336]
			write16(w, uint16(x))
		}
	}
	for local337 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).SpritePos {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).SpritePos)[local337]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Visible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).MakeFootstepSnds
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).RotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Mesh))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Mesh))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Mesh))[:])
		chk(err)
	}
	if len(((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Colors)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Colors)))
		write16(w, uint16(x))
	}
	for local338 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Colors {
		{
			x := ((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).Colors)[local338]
			w.Write([]byte{x.A, x.R, x.G, x.B})
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).CollideWithAOs
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).StepHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).FaceRotateDir
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).FaceRotateDirOff
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).BackfaceCull
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Nametag))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Nametag))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Nametag))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NametagColor
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).FaceRotateSpeed
		write32(w, math.Float32bits(x))
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Infotext))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Infotext))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Infotext))[:])
		chk(err)
	}
	if len(([]byte((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Itemstring))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Itemstring))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Itemstring))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Glow
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).MaxBreath
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).EyeHeight
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).ZoomFOV
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).UseTextureAlpha
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).DmgTextureMod).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Shaded
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).ShowOnMinimap
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NametagBG
		w.Write([]byte{x.A, x.R, x.G, x.B})
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).RotateSelBox
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NodeParam0).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NodeParam1
		write8(w, uint8(x))
	}
	{
		x := (*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NodeParam2
		write8(w, uint8(x))
	}
}

func (obj *AOProps) deserialize(r io.Reader) {
	{
		var local339 uint8
		local340 := uint8(4)
		{
			p := &local339
			*p = read8(r)
		}
		if local339 != local340 {
			chk(fmt.Errorf("const %v: %v", "uint8(4)", local339))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).MaxHP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).CollideWithNodes
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Weight
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).ColBox).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).SelBox).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Pointable).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.PointabilityType", err))
	}
	var local341 []uint8
	var local342 uint16
	{
		p := &local342
		*p = read16(r)
	}
	(local341) = make([]uint8, local342)
	{
		_, err := io.ReadFull(r, (local341)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Visual) = string(local341)
	for local343 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).VisualSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).VisualSize)[local343]
			*p = math.Float32frombits(read32(r))
		}
	}
	var local344 uint16
	{
		p := &local344
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Textures) = make([]Texture, local344)
	for local345 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Textures {
		if err := pcall(func() {
			(((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).Textures)[local345]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
		}
	}
	for local346 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).SpriteSheetSize {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).SpriteSheetSize)[local346]
			*p = int16(read16(r))
		}
	}
	for local347 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).SpritePos {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).SpritePos)[local347]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Visible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).MakeFootstepSnds
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).RotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local348 []uint8
	var local349 uint16
	{
		p := &local349
		*p = read16(r)
	}
	(local348) = make([]uint8, local349)
	{
		_, err := io.ReadFull(r, (local348)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Mesh) = string(local348)
	var local350 uint16
	{
		p := &local350
		*p = read16(r)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Colors) = make([]color.NRGBA, local350)
	for local351 := range (*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Colors {
		{
			p := &((*(*(struct {
				MaxHP            uint16 // Player only.
				CollideWithNodes bool
				Weight           float32 // deprecated
				ColBox, SelBox   Box
				Pointable        PointabilityType
				Visual           string
				VisualSize       [3]float32
				Textures         []Texture
				SpriteSheetSize  [2]int16 // in sprites.
				SpritePos        [2]int16 // in sprite sheet.
				Visible          bool
				MakeFootstepSnds bool
				RotateSpeed      float32 // in radians per second.
				Mesh             string
				Colors           []color.NRGBA
				CollideWithAOs   bool
				StepHeight       float32
				FaceRotateDir    bool
				FaceRotateDirOff float32 // in degrees.
				BackfaceCull     bool
				Nametag          string
				NametagColor     color.NRGBA
				FaceRotateSpeed  float32 // in degrees per second.
				Infotext         string
				Itemstring       string
				Glow             int8
				MaxBreath        uint16  // Player only.
				EyeHeight        float32 // Player only.
				ZoomFOV          float32 // in degrees. Player only.
				UseTextureAlpha  bool
				DmgTextureMod    Texture // suffix
				Shaded           bool
				ShowOnMinimap    bool
				NametagBG        color.NRGBA
				RotateSelBox     bool
				NodeParam0       Content
				NodeParam1       uint8
				NodeParam2       uint8
			}))(obj)).Colors)[local351]
			*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).CollideWithAOs
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).StepHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).FaceRotateDir
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).FaceRotateDirOff
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).BackfaceCull
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	var local352 []uint8
	var local353 uint16
	{
		p := &local353
		*p = read16(r)
	}
	(local352) = make([]uint8, local353)
	{
		_, err := io.ReadFull(r, (local352)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Nametag) = string(local352)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NametagColor
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).FaceRotateSpeed
		*p = math.Float32frombits(read32(r))
	}
	var local354 []uint8
	var local355 uint16
	{
		p := &local355
		*p = read16(r)
	}
	(local354) = make([]uint8, local355)
	{
		_, err := io.ReadFull(r, (local354)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Infotext) = string(local354)
	var local356 []uint8
	var local357 uint16
	{
		p := &local357
		*p = read16(r)
	}
	(local356) = make([]uint8, local357)
	{
		_, err := io.ReadFull(r, (local356)[:])
		chk(err)
	}
	((*(*(struct {
		MaxHP            uint16 // Player only.
		CollideWithNodes bool
		Weight           float32 // deprecated
		ColBox, SelBox   Box
		Pointable        PointabilityType
		Visual           string
		VisualSize       [3]float32
		Textures         []Texture
		SpriteSheetSize  [2]int16 // in sprites.
		SpritePos        [2]int16 // in sprite sheet.
		Visible          bool
		MakeFootstepSnds bool
		RotateSpeed      float32 // in radians per second.
		Mesh             string
		Colors           []color.NRGBA
		CollideWithAOs   bool
		StepHeight       float32
		FaceRotateDir    bool
		FaceRotateDirOff float32 // in degrees.
		BackfaceCull     bool
		Nametag          string
		NametagColor     color.NRGBA
		FaceRotateSpeed  float32 // in degrees per second.
		Infotext         string
		Itemstring       string
		Glow             int8
		MaxBreath        uint16  // Player only.
		EyeHeight        float32 // Player only.
		ZoomFOV          float32 // in degrees. Player only.
		UseTextureAlpha  bool
		DmgTextureMod    Texture // suffix
		Shaded           bool
		ShowOnMinimap    bool
		NametagBG        color.NRGBA
		RotateSelBox     bool
		NodeParam0       Content
		NodeParam1       uint8
		NodeParam2       uint8
	}))(obj)).Itemstring) = string(local356)
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Glow
		*p = int8(read8(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).MaxBreath
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).EyeHeight
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).ZoomFOV
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).UseTextureAlpha
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).DmgTextureMod).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).Shaded
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).ShowOnMinimap
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NametagBG
		*p = color.NRGBA{A: read8(r), R: read8(r), G: read8(r), B: read8(r)}
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).RotateSelBox
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NodeParam0).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Content", err))
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NodeParam1
		*p = read8(r)
	}
	{
		p := &(*(*(struct {
			MaxHP            uint16 // Player only.
			CollideWithNodes bool
			Weight           float32 // deprecated
			ColBox, SelBox   Box
			Pointable        PointabilityType
			Visual           string
			VisualSize       [3]float32
			Textures         []Texture
			SpriteSheetSize  [2]int16 // in sprites.
			SpritePos        [2]int16 // in sprite sheet.
			Visible          bool
			MakeFootstepSnds bool
			RotateSpeed      float32 // in radians per second.
			Mesh             string
			Colors           []color.NRGBA
			CollideWithAOs   bool
			StepHeight       float32
			FaceRotateDir    bool
			FaceRotateDirOff float32 // in degrees.
			BackfaceCull     bool
			Nametag          string
			NametagColor     color.NRGBA
			FaceRotateSpeed  float32 // in degrees per second.
			Infotext         string
			Itemstring       string
			Glow             int8
			MaxBreath        uint16  // Player only.
			EyeHeight        float32 // Player only.
			ZoomFOV          float32 // in degrees. Player only.
			UseTextureAlpha  bool
			DmgTextureMod    Texture // suffix
			Shaded           bool
			ShowOnMinimap    bool
			NametagBG        color.NRGBA
			RotateSelBox     bool
			NodeParam0       Content
			NodeParam1       uint8
			NodeParam2       uint8
		}))(obj)).NodeParam2
		*p = read8(r)
	}
}

func (obj *AOPos) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local358 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local358]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOPos) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Vel).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Acc).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local359 := range (*(*(struct {
		Pos
		Vel, Acc Vec
		Rot      [3]float32

		Interpolate    bool
		End            bool
		UpdateInterval float32
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos
				Vel, Acc Vec
				Rot      [3]float32

				Interpolate    bool
				End            bool
				UpdateInterval float32
			}))(obj)).Rot)[local359]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).Interpolate
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).End
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Pos
			Vel, Acc Vec
			Rot      [3]float32

			Interpolate    bool
			End            bool
			UpdateInterval float32
		}))(obj)).UpdateInterval
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AOSprite) serialize(w io.Writer) {
	for local360 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			x := ((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local360]
			write16(w, uint16(x))
		}
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOSprite) deserialize(r io.Reader) {
	for local361 := range (*(*(struct {
		Frame0          [2]int16
		Frames          uint16
		FrameDuration   float32
		ViewAngleFrames bool
	}))(obj)).Frame0 {
		{
			p := &((*(*(struct {
				Frame0          [2]int16
				Frames          uint16
				FrameDuration   float32
				ViewAngleFrames bool
			}))(obj)).Frame0)[local361]
			*p = int16(read16(r))
		}
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).Frames
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).FrameDuration
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frame0          [2]int16
			Frames          uint16
			FrameDuration   float32
			ViewAngleFrames bool
		}))(obj)).ViewAngleFrames
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *Group) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		write16(w, uint16(x))
	}
}

func (obj *Group) deserialize(r io.Reader) {
	var local362 []uint8
	var local363 uint16
	{
		p := &local363
		*p = read16(r)
	}
	(local362) = make([]uint8, local363)
	{
		_, err := io.ReadFull(r, (local362)[:])
		chk(err)
	}
	((*(*(struct {
		Name   string
		Rating int16
	}))(obj)).Name) = string(local362)
	{
		p := &(*(*(struct {
			Name   string
			Rating int16
		}))(obj)).Rating
		*p = int16(read16(r))
	}
}

func (obj *AOAnim) serialize(w io.Writer) {
	for local364 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			x := ((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local364]
			write32(w, uint32(x))
		}
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAnim) deserialize(r io.Reader) {
	for local365 := range (*(*(struct {
		Frames [2]int32
		Speed  float32
		Blend  float32
		NoLoop bool
	}))(obj)).Frames {
		{
			p := &((*(*(struct {
				Frames [2]int32
				Speed  float32
				Blend  float32
				NoLoop bool
			}))(obj)).Frames)[local365]
			*p = int32(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).Blend
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Frames [2]int32
			Speed  float32
			Blend  float32
			NoLoop bool
		}))(obj)).NoLoop
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOBoneOverride) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local366 := range (*(*(struct {
		Pos              Vec
		Rot              [3]float32
		Scale            [3]float32
		PosInterpTimer   float32
		RotInterpTimer   float32
		ScaleInterpTimer float32
		Absolute         AbsoluteFlag
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				Pos              Vec
				Rot              [3]float32
				Scale            [3]float32
				PosInterpTimer   float32
				RotInterpTimer   float32
				ScaleInterpTimer float32
				Absolute         AbsoluteFlag
			}))(obj)).Rot)[local366]
			write32(w, math.Float32bits(x))
		}
	}
	for local367 := range (*(*(struct {
		Pos              Vec
		Rot              [3]float32
		Scale            [3]float32
		PosInterpTimer   float32
		RotInterpTimer   float32
		ScaleInterpTimer float32
		Absolute         AbsoluteFlag
	}))(obj)).Scale {
		{
			x := ((*(*(struct {
				Pos              Vec
				Rot              [3]float32
				Scale            [3]float32
				PosInterpTimer   float32
				RotInterpTimer   float32
				ScaleInterpTimer float32
				Absolute         AbsoluteFlag
			}))(obj)).Scale)[local367]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).PosInterpTimer
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).RotInterpTimer
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).ScaleInterpTimer
		write32(w, math.Float32bits(x))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).Absolute).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AbsoluteFlag", err))
	}
}

func (obj *AOBoneOverride) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local368 := range (*(*(struct {
		Pos              Vec
		Rot              [3]float32
		Scale            [3]float32
		PosInterpTimer   float32
		RotInterpTimer   float32
		ScaleInterpTimer float32
		Absolute         AbsoluteFlag
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				Pos              Vec
				Rot              [3]float32
				Scale            [3]float32
				PosInterpTimer   float32
				RotInterpTimer   float32
				ScaleInterpTimer float32
				Absolute         AbsoluteFlag
			}))(obj)).Rot)[local368]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local369 := range (*(*(struct {
		Pos              Vec
		Rot              [3]float32
		Scale            [3]float32
		PosInterpTimer   float32
		RotInterpTimer   float32
		ScaleInterpTimer float32
		Absolute         AbsoluteFlag
	}))(obj)).Scale {
		{
			p := &((*(*(struct {
				Pos              Vec
				Rot              [3]float32
				Scale            [3]float32
				PosInterpTimer   float32
				RotInterpTimer   float32
				ScaleInterpTimer float32
				Absolute         AbsoluteFlag
			}))(obj)).Scale)[local369]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).PosInterpTimer
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).RotInterpTimer
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).ScaleInterpTimer
		*p = math.Float32frombits(read32(r))
	}
	if err := pcall(func() {
		((*(*(struct {
			Pos              Vec
			Rot              [3]float32
			Scale            [3]float32
			PosInterpTimer   float32
			RotInterpTimer   float32
			ScaleInterpTimer float32
			Absolute         AbsoluteFlag
		}))(obj)).Absolute).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AbsoluteFlag", err))
	}
}

func (obj *AOAttach) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if len(([]byte((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Bone))[:])
		chk(err)
	}
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local370 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			x := ((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local370]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *AOAttach) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ParentID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	var local371 []uint8
	var local372 uint16
	{
		p := &local372
		*p = read16(r)
	}
	(local371) = make([]uint8, local372)
	{
		_, err := io.ReadFull(r, (local371)[:])
		chk(err)
	}
	((*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Bone) = string(local371)
	if err := pcall(func() {
		((*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
	}
	for local373 := range (*(*(struct {
		ParentID     AOID
		Bone         string
		Pos          Vec
		Rot          [3]float32
		ForceVisible bool
	}))(obj)).Rot {
		{
			p := &((*(*(struct {
				ParentID     AOID
				Bone         string
				Pos          Vec
				Rot          [3]float32
				ForceVisible bool
			}))(obj)).Rot)[local373]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {
			ParentID     AOID
			Bone         string
			Pos          Vec
			Rot          [3]float32
			ForceVisible bool
		}))(obj)).ForceVisible
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *AOPhysOverride) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Speed
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Jump
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Gravity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).NoSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).NoSneakGlitch
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).OldSneak
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Climb
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Crouch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Fluidity
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).FluiditySmooth
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Sink
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Acceleration
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).AccelerationAir
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Fast
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).AccelerationFast
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Walk
		write32(w, math.Float32bits(x))
	}
}

func (obj *AOPhysOverride) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Speed
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Jump
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Gravity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).NoSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).NoSneakGlitch
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).OldSneak
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Climb
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Crouch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Fluidity
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).FluiditySmooth
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Sink
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Acceleration
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).AccelerationAir
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Fast
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).AccelerationFast
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Speed, Jump, Gravity float32

			// Player only.
			NoSneak, NoSneakGlitch, OldSneak bool
			Climb, Crouch                    float32
			Fluidity, FluiditySmooth, Sink   float32
			Acceleration, AccelerationAir    float32
			Fast, AccelerationFast, Walk     float32
		}))(obj)).Walk
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *aoType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *aoType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeMetaField) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
	}
	{
		x := (*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
}

func (obj *NodeMetaField) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Field
			Private bool
		}))(obj)).Field).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Field", err))
	}
	{
		p := &(*(*(struct {
			Field
			Private bool
		}))(obj)).Private
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
}

func (obj *MinimapType) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *MinimapType) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *Param1Type) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param1Type) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Param2Type) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *Param2Type) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DrawType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *DrawType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileDef) serialize(w io.Writer) {
	{
		local374 := uint8(6)
		{
			x := local374
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			write8(w, uint8(x))
		}
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			x := (*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			write8(w, uint8(x))
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlignType", err))
		}
	}
}

func (obj *TileDef) deserialize(r io.Reader) {
	{
		var local375 uint8
		local376 := uint8(6)
		{
			p := &local375
			*p = read8(r)
		}
		if local375 != local376 {
			chk(fmt.Errorf("const %v: %v", "uint8(6)", local375))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Texture).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Texture", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Anim).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileAnim", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Texture
			Anim  TileAnim
			Flags TileFlags

			//mt:if %s.Flags&TileColor != 0
			R, G, B uint8

			//mt:if %s.Flags&TileScale != 0
			Scale uint8

			//mt:if %s.Flags&TileAlign != 0
			Align AlignType
		}))(obj)).Flags).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TileFlags", err))
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileColor != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).R
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).G
			*p = read8(r)
		}
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).B
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileScale != 0 {
		{
			p := &(*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Scale
			*p = read8(r)
		}
	}
	if (*(*(struct {
		Texture
		Anim  TileAnim
		Flags TileFlags

		//mt:if %s.Flags&TileColor != 0
		R, G, B uint8

		//mt:if %s.Flags&TileScale != 0
		Scale uint8

		//mt:if %s.Flags&TileAlign != 0
		Align AlignType
	}))(obj)).Flags&TileAlign != 0 {
		if err := pcall(func() {
			((*(*(struct {
				Texture
				Anim  TileAnim
				Flags TileFlags

				//mt:if %s.Flags&TileColor != 0
				R, G, B uint8

				//mt:if %s.Flags&TileScale != 0
				Scale uint8

				//mt:if %s.Flags&TileAlign != 0
				Align AlignType
			}))(obj)).Align).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AlignType", err))
		}
	}
}

func (obj *WaveType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *WaveType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *PointabilityType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *PointabilityType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LiquidType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *LiquidType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBox) serialize(w io.Writer) {
	{
		local377 := uint8(6)
		{
			x := local377
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).Fixed)))
			write16(w, uint16(x))
		}
		for local378 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local378]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoAll)))
			write16(w, uint16(x))
		}
		for local379 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local379]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
		if len(((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides)) > math.MaxUint16 {
			chk(ErrTooLong)
		}
		{
			x := uint16(len(((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoSides)))
			write16(w, uint16(x))
		}
		for local380 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local380]).serialize(w)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
}

func (obj *NodeBox) deserialize(r io.Reader) {
	{
		var local381 uint8
		local382 := uint8(6)
		{
			p := &local381
			*p = read8(r)
		}
		if local381 != local382 {
			chk(fmt.Errorf("const %v: %v", "uint8(6)", local381))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Type).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.NodeBoxType", err))
	}
	if !((*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type < maxBox) {
		chk(errors.New("assertion failed: %s.Type < maxBox"))
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == MountedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallTop).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallBot).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).WallSides).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if t := (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type; t == FixedBox || t == LeveledBox || t == ConnectedBox {
		var local383 uint16
		{
			p := &local383
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed) = make([]Box, local383)
		for local384 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).Fixed {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).Fixed)[local384]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
	if (*(*(struct {
		Type NodeBoxType

		//mt:if %s.Type == MountedBox
		WallTop, WallBot, WallSides Box

		//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
		Fixed []Box

		//mt:if %s.Type == ConnectedBox
		ConnDirs, DiscoDirs  DirBoxes
		DiscoAll, DiscoSides []Box
	}))(obj)).Type == ConnectedBox {
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).ConnDirs).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		if err := pcall(func() {
			((*(*(struct {
				Type NodeBoxType

				//mt:if %s.Type == MountedBox
				WallTop, WallBot, WallSides Box

				//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
				Fixed []Box

				//mt:if %s.Type == ConnectedBox
				ConnDirs, DiscoDirs  DirBoxes
				DiscoAll, DiscoSides []Box
			}))(obj)).DiscoDirs).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DirBoxes", err))
		}
		var local385 uint16
		{
			p := &local385
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll) = make([]Box, local385)
		for local386 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoAll {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoAll)[local386]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
		var local387 uint16
		{
			p := &local387
			*p = read16(r)
		}
		((*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides) = make([]Box, local387)
		for local388 := range (*(*(struct {
			Type NodeBoxType

			//mt:if %s.Type == MountedBox
			WallTop, WallBot, WallSides Box

			//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
			Fixed []Box

			//mt:if %s.Type == ConnectedBox
			ConnDirs, DiscoDirs  DirBoxes
			DiscoAll, DiscoSides []Box
		}))(obj)).DiscoSides {
			if err := pcall(func() {
				(((*(*(struct {
					Type NodeBoxType

					//mt:if %s.Type == MountedBox
					WallTop, WallBot, WallSides Box

					//mt:if t := %s.Type; t == FixedBox || t == LeveledBox || t == ConnectedBox
					Fixed []Box

					//mt:if %s.Type == ConnectedBox
					ConnDirs, DiscoDirs  DirBoxes
					DiscoAll, DiscoSides []Box
				}))(obj)).DiscoSides)[local388]).deserialize(r)
			}); err != nil {
				if err == io.EOF {
					chk(io.EOF)
				}
				chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
			}
		}
	}
}

func (obj *SoundDef) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		write32(w, math.Float32bits(x))
	}
}

func (obj *SoundDef) deserialize(r io.Reader) {
	var local389 []uint8
	var local390 uint16
	{
		p := &local390
		*p = read16(r)
	}
	(local389) = make([]uint8, local390)
	{
		_, err := io.ReadFull(r, (local389)[:])
		chk(err)
	}
	((*(*(struct {
		Name              string
		Gain, Pitch, Fade float32
	}))(obj)).Name) = string(local389)
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Gain
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Pitch
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Name              string
			Gain, Pitch, Fade float32
		}))(obj)).Fade
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *AlphaUse) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlphaUse) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Keys) serialize(w io.Writer) {
	{
		x := *(*(uint32))(obj)
		write32(w, uint32(x))
	}
}

func (obj *Keys) deserialize(r io.Reader) {
	{
		p := &*(*(uint32))(obj)
		*p = read32(r)
	}
}

func (obj *PlayerPosFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *PlayerPosFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *MapBlkFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *MapBlkFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *LitFromBlks) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *LitFromBlks) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AOInitData) serialize(w io.Writer) {
	{
		local391 := uint8(1)
		{
			x := local391
			write8(w, uint8(x))
		}
	}
	if len(([]byte((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		if x {
			write8(w, 1)
		} else {
			write8(w, 0)
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local392 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			x := ((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local392]
			write32(w, math.Float32bits(x))
		}
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			if len(x) > math.MaxUint8 {
				chk(ErrTooLong)
			}
			write8(w, uint8(len(x)))
			for _, msg := range x {
				var b bytes.Buffer
				chk(writeAOMsg(&b, msg))
				if b.Len() > math.MaxUint32 {
					chk(ErrTooLong)
				}
				write32(w, uint32(b.Len()))
				_, err := b.WriteTo(w)
				chk(err)
			}
		}
	}
}

func (obj *AOInitData) deserialize(r io.Reader) {
	{
		var local393 uint8
		local394 := uint8(1)
		{
			p := &local393
			*p = read8(r)
		}
		if local393 != local394 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local393))
		}
	}
	var local395 []uint8
	var local396 uint16
	{
		p := &local396
		*p = read16(r)
	}
	(local395) = make([]uint8, local396)
	{
		_, err := io.ReadFull(r, (local395)[:])
		chk(err)
	}
	((*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Name) = string(local395)
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).IsPlayer
		switch n := read8(r); n {
		case 0:
			*p = false
		case 1:
			*p = true
		default:
			chk(fmt.Errorf("invalid bool: %d", n))
		}
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).ID).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.AOID", err))
	}
	if err := pcall(func() {
		((*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Pos).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Pos", err))
	}
	for local397 := range (*(*(struct {

		// For players.
		Name     string
		IsPlayer bool

		ID AOID

		Pos
		Rot [3]float32

		HP uint16

		// See (de)serialize.fmt.
		Msgs []AOMsg
	}))(obj)).Rot {
		{
			p := &((*(*(struct {

				// For players.
				Name     string
				IsPlayer bool

				ID AOID

				Pos
				Rot [3]float32

				HP uint16

				// See (de)serialize.fmt.
				Msgs []AOMsg
			}))(obj)).Rot)[local397]
			*p = math.Float32frombits(read32(r))
		}
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).HP
		*p = read16(r)
	}
	{
		p := &(*(*(struct {

			// For players.
			Name     string
			IsPlayer bool

			ID AOID

			Pos
			Rot [3]float32

			HP uint16

			// See (de)serialize.fmt.
			Msgs []AOMsg
		}))(obj)).Msgs
		{ // For AOInitData.Msgs.
			*p = make([]AOMsg, read8(r))
			for i := range *p {
				r := &io.LimitedReader{R: r, N: int64(read32(r))}
				msg, err := readAOMsg(r)
				chk(err)
				(*p)[i] = msg
				if r.N > 0 {
					chk(fmt.Errorf("%d bytes of trailing data", r.N))
				}
			}
		}
	}
}

func (obj *ItemType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ItemType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ToolCaps) serialize(w io.Writer) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCap

		//mt:len32
		DmgGroups []Group

		//mt:32tou16
		PunchUses int32
	}))(obj)); false {
		{
			x := (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil
			if x {
				write8(w, 1)
			} else {
				write8(w, 0)
			}
		}
	}
	{
		ow := w
		w := new(bytes.Buffer)
		/*
			if r.N > 0 { (*(*(struct {
				//mt:if _ = %s; false
				NonNil	bool

				AttackCooldown	float32
				MaxDropLvl	int16

				//mt:len32
				GroupCaps	[]ToolGroupCap

				//mt:len32
				DmgGroups	[]Group

				//mt:32tou16
				PunchUses	int32
			}))(obj)).NonNil = true}; /*
		*/{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil {
				{
					local398 := uint8(5)
					{
						x := local398
						write8(w, uint8(x))
					}
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).AttackCooldown
					write32(w, math.Float32bits(x))
				}
				{
					x := (*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).MaxDropLvl
					write16(w, uint16(x))
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).GroupCaps)))
					write32(w, uint32(x))
				}
				for local399 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).GroupCaps)[local399]).serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolGroupCap", err))
					}
				}
				if len(((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups)) > math.MaxUint32 {
					chk(ErrTooLong)
				}
				{
					x := uint32(len(((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).DmgGroups)))
					write32(w, uint32(x))
				}
				for local400 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).DmgGroups)[local400]).serialize(w)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
					}
				}
				{
					x := uint16((*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).PunchUses)
					write16(w, uint16(x))
				}
			}
		}
		{
			buf := w
			w := ow
			if len((buf.Bytes())) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			{
				x := uint16(len((buf.Bytes())))
				write16(w, uint16(x))
			}
			{
				_, err := w.Write((buf.Bytes())[:])
				chk(err)
			}
		}
	}
}

func (obj *ToolCaps) deserialize(r io.Reader) {
	if _ = (*(*(struct {
		//mt:if _ = %s; false
		NonNil bool

		AttackCooldown float32
		MaxDropLvl     int16

		//mt:len32
		GroupCaps []ToolGroupCap

		//mt:len32
		DmgGroups []Group

		//mt:32tou16
		PunchUses int32
	}))(obj)); false {
		{
			p := &(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil
			switch n := read8(r); n {
			case 0:
				*p = false
			case 1:
				*p = true
			default:
				chk(fmt.Errorf("invalid bool: %d", n))
			}
		}
	}
	{
		var n uint16
		{
			p := &n
			*p = read16(r)
		}
		r := &io.LimitedReader{R: r, N: int64(n)}
		if r.N > 0 {
			(*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil = true
		} /**/
		{
			if (*(*(struct {
				//mt:if _ = %s; false
				NonNil bool

				AttackCooldown float32
				MaxDropLvl     int16

				//mt:len32
				GroupCaps []ToolGroupCap

				//mt:len32
				DmgGroups []Group

				//mt:32tou16
				PunchUses int32
			}))(obj)).NonNil {
				{
					var local401 uint8
					local402 := uint8(5)
					{
						p := &local401
						*p = read8(r)
					}
					if local401 != local402 {
						chk(fmt.Errorf("const %v: %v", "uint8(5)", local401))
					}
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).AttackCooldown
					*p = math.Float32frombits(read32(r))
				}
				{
					p := &(*(*(struct {
						//mt:if _ = %s; false
						NonNil bool

						AttackCooldown float32
						MaxDropLvl     int16

						//mt:len32
						GroupCaps []ToolGroupCap

						//mt:len32
						DmgGroups []Group

						//mt:32tou16
						PunchUses int32
					}))(obj)).MaxDropLvl
					*p = int16(read16(r))
				}
				var local403 uint32
				{
					p := &local403
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps) = make([]ToolGroupCap, local403)
				for local404 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).GroupCaps {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).GroupCaps)[local404]).deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.ToolGroupCap", err))
					}
				}
				var local405 uint32
				{
					p := &local405
					*p = read32(r)
				}
				((*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups) = make([]Group, local405)
				for local406 := range (*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).DmgGroups {
					if err := pcall(func() {
						(((*(*(struct {
							//mt:if _ = %s; false
							NonNil bool

							AttackCooldown float32
							MaxDropLvl     int16

							//mt:len32
							GroupCaps []ToolGroupCap

							//mt:len32
							DmgGroups []Group

							//mt:32tou16
							PunchUses int32
						}))(obj)).DmgGroups)[local406]).deserialize(r)
					}); err != nil {
						if err == io.EOF {
							chk(io.EOF)
						}
						chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Group", err))
					}
				}
				var local407 uint16
				{
					p := &local407
					*p = read16(r)
				}
				(*(*(struct {
					//mt:if _ = %s; false
					NonNil bool

					AttackCooldown float32
					MaxDropLvl     int16

					//mt:len32
					GroupCaps []ToolGroupCap

					//mt:len32
					DmgGroups []Group

					//mt:32tou16
					PunchUses int32
				}))(obj)).PunchUses = int32(local407)
			}
		}
		if r.N > 0 {
			chk(fmt.Errorf("%d bytes of trailing data", r.N))
		}
	}
}

func (obj *TouchInteraction) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Nothing, Node, Object TouchInteractionMode
		}))(obj)).Nothing).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TouchInteractionMode", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Nothing, Node, Object TouchInteractionMode
		}))(obj)).Node).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TouchInteractionMode", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Nothing, Node, Object TouchInteractionMode
		}))(obj)).Object).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TouchInteractionMode", err))
	}
}

func (obj *TouchInteraction) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Nothing, Node, Object TouchInteractionMode
		}))(obj)).Nothing).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TouchInteractionMode", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Nothing, Node, Object TouchInteractionMode
		}))(obj)).Node).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TouchInteractionMode", err))
	}
	if err := pcall(func() {
		((*(*(struct {
			Nothing, Node, Object TouchInteractionMode
		}))(obj)).Object).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TouchInteractionMode", err))
	}
}

func (obj *WearBarParams) serialize(w io.Writer) {
	{
		local408 := uint8(1)
		{
			x := local408
			write8(w, uint8(x))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Blend BlendMode

			ColorStops map[float32]color.NRGBA
		}))(obj)).Blend).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.BlendMode", err))
	}
	{
		x := (*(*(struct {
			Blend BlendMode

			ColorStops map[float32]color.NRGBA
		}))(obj)).ColorStops
		{ // For WearBarParams.ColorStops.
			if len(x) > math.MaxUint16 {
				chk(ErrTooLong)
			}
			write16(w, uint16(len(x)))
			for wear, c := range x {
				write32(w, uint32(wear))
				// Same as image/color.NRGBA, but it doesn't implement
				// serializer.
				_, err := w.Write([]byte{c.A, c.R, c.G, c.B})
				chk(err)
			}
		}
	}
}

func (obj *WearBarParams) deserialize(r io.Reader) {
	{
		var local409 uint8
		local410 := uint8(1)
		{
			p := &local409
			*p = read8(r)
		}
		if local409 != local410 {
			chk(fmt.Errorf("const %v: %v", "uint8(1)", local409))
		}
	}
	if err := pcall(func() {
		((*(*(struct {
			Blend BlendMode

			ColorStops map[float32]color.NRGBA
		}))(obj)).Blend).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.BlendMode", err))
	}
	{
		p := &(*(*(struct {
			Blend BlendMode

			ColorStops map[float32]color.NRGBA
		}))(obj)).ColorStops
		{ // For WearBarParams.ColorStops.
			n := read16(r)
			*p = make(map[float32]color.NRGBA, n)
			for ; n > 0; n-- {
				wear := float32(read32(r))
				// Same as image/color.NRGBA, but it doesn't implement
				// deserializer.
				(*p)[wear] = color.NRGBA{
					A: read8(r),
					R: read8(r),
					G: read8(r),
					B: read8(r),
				}
			}
		}
	}
}

func (obj *AnimType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AnimType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *ParticleTextureFlags) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *ParticleTextureFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TweenF32) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).Style).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).Reps
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).Beginning
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).Start
		write32(w, math.Float32bits(x))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).End
		write32(w, math.Float32bits(x))
	}
}

func (obj *TweenF32) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).Style).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).Reps
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).Beginning
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).Start
		*p = math.Float32frombits(read32(r))
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End float32
		}))(obj)).End
		*p = math.Float32frombits(read32(r))
	}
}

func (obj *TweenV2F32) serialize(w io.Writer) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [2]float32
		}))(obj)).Style).serialize(w)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [2]float32
		}))(obj)).Reps
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [2]float32
		}))(obj)).Beginning
		write32(w, math.Float32bits(x))
	}
	for local411 := range (*(*(struct {
		Style      TweenStyle
		Reps       uint16
		Beginning  float32
		Start, End [2]float32
	}))(obj)).Start {
		{
			x := ((*(*(struct {
				Style      TweenStyle
				Reps       uint16
				Beginning  float32
				Start, End [2]float32
			}))(obj)).Start)[local411]
			write32(w, math.Float32bits(x))
		}
	}
	for local412 := range (*(*(struct {
		Style      TweenStyle
		Reps       uint16
		Beginning  float32
		Start, End [2]float32
	}))(obj)).End {
		{
			x := ((*(*(struct {
				Style      TweenStyle
				Reps       uint16
				Beginning  float32
				Start, End [2]float32
			}))(obj)).End)[local412]
			write32(w, math.Float32bits(x))
		}
	}
}

func (obj *TweenV2F32) deserialize(r io.Reader) {
	if err := pcall(func() {
		((*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [2]float32
		}))(obj)).Style).deserialize(r)
	}); err != nil {
		if err == io.EOF {
			chk(io.EOF)
		}
		chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.TweenStyle", err))
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [2]float32
		}))(obj)).Reps
		*p = read16(r)
	}
	{
		p := &(*(*(struct {
			Style      TweenStyle
			Reps       uint16
			Beginning  float32
			Start, End [2]float32
		}))(obj)).Beginning
		*p = math.Float32frombits(read32(r))
	}
	for local413 := range (*(*(struct {
		Style      TweenStyle
		Reps       uint16
		Beginning  float32
		Start, End [2]float32
	}))(obj)).Start {
		{
			p := &((*(*(struct {
				Style      TweenStyle
				Reps       uint16
				Beginning  float32
				Start, End [2]float32
			}))(obj)).Start)[local413]
			*p = math.Float32frombits(read32(r))
		}
	}
	for local414 := range (*(*(struct {
		Style      TweenStyle
		Reps       uint16
		Beginning  float32
		Start, End [2]float32
	}))(obj)).End {
		{
			p := &((*(*(struct {
				Style      TweenStyle
				Reps       uint16
				Beginning  float32
				Start, End [2]float32
			}))(obj)).End)[local414]
			*p = math.Float32frombits(read32(r))
		}
	}
}

func (obj *TweenStyle) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *TweenStyle) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *HUDType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *HUDType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *Box) serialize(w io.Writer) {
	for local415 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local415]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
		}
	}
}

func (obj *Box) deserialize(r io.Reader) {
	for local416 := range *(*([2]Vec))(obj) {
		if err := pcall(func() {
			((*(*([2]Vec))(obj))[local416]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Vec", err))
		}
	}
}

func (obj *AbsoluteFlag) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AbsoluteFlag) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *TileFlags) serialize(w io.Writer) {
	{
		x := *(*(uint16))(obj)
		write16(w, uint16(x))
	}
}

func (obj *TileFlags) deserialize(r io.Reader) {
	{
		p := &*(*(uint16))(obj)
		*p = read16(r)
	}
}

func (obj *AlignType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *AlignType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *NodeBoxType) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *NodeBoxType) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DirBoxes) serialize(w io.Writer) {
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Top)))
		write16(w, uint16(x))
	}
	for local417 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local417]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Bot)))
		write16(w, uint16(x))
	}
	for local418 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local418]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Front)))
		write16(w, uint16(x))
	}
	for local419 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local419]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Left)))
		write16(w, uint16(x))
	}
	for local420 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local420]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Back)))
		write16(w, uint16(x))
	}
	for local421 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local421]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	if len(((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right)) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(((*(*(struct {
			Top, Bot                 []Box
			Front, Left, Back, Right []Box
		}))(obj)).Right)))
		write16(w, uint16(x))
	}
	for local422 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local422]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
}

func (obj *DirBoxes) deserialize(r io.Reader) {
	var local423 uint16
	{
		p := &local423
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top) = make([]Box, local423)
	for local424 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Top {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Top)[local424]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local425 uint16
	{
		p := &local425
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot) = make([]Box, local425)
	for local426 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Bot {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Bot)[local426]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local427 uint16
	{
		p := &local427
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front) = make([]Box, local427)
	for local428 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Front {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Front)[local428]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local429 uint16
	{
		p := &local429
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left) = make([]Box, local429)
	for local430 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Left {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Left)[local430]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local431 uint16
	{
		p := &local431
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back) = make([]Box, local431)
	for local432 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Back {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Back)[local432]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
	var local433 uint16
	{
		p := &local433
		*p = read16(r)
	}
	((*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right) = make([]Box, local433)
	for local434 := range (*(*(struct {
		Top, Bot                 []Box
		Front, Left, Back, Right []Box
	}))(obj)).Right {
		if err := pcall(func() {
			(((*(*(struct {
				Top, Bot                 []Box
				Front, Left, Back, Right []Box
			}))(obj)).Right)[local434]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.Box", err))
		}
	}
}

func (obj *ToolGroupCap) serialize(w io.Writer) {
	if len(([]byte((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name))) > math.MaxUint16 {
		chk(ErrTooLong)
	}
	{
		x := uint16(len(([]byte((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))))
		write16(w, uint16(x))
	}
	{
		_, err := w.Write(([]byte((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Name))[:])
		chk(err)
	}
	{
		x := int16((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Uses)
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		write16(w, uint16(x))
	}
	if len(((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times)) > math.MaxUint32 {
		chk(ErrTooLong)
	}
	{
		x := uint32(len(((*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).Times)))
		write32(w, uint32(x))
	}
	for local435 := range (*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name string

				//mt:32to16
				Uses int32

				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local435]).serialize(w)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DigTime", err))
		}
	}
}

func (obj *ToolGroupCap) deserialize(r io.Reader) {
	var local436 []uint8
	var local437 uint16
	{
		p := &local437
		*p = read16(r)
	}
	(local436) = make([]uint8, local437)
	{
		_, err := io.ReadFull(r, (local436)[:])
		chk(err)
	}
	((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Name) = string(local436)
	var local438 int16
	{
		p := &local438
		*p = int16(read16(r))
	}
	(*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Uses = int32(local438)
	{
		p := &(*(*(struct {
			Name string

			//mt:32to16
			Uses int32

			MaxLvl int16

			//mt:len32
			Times []DigTime
		}))(obj)).MaxLvl
		*p = int16(read16(r))
	}
	var local439 uint32
	{
		p := &local439
		*p = read32(r)
	}
	((*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times) = make([]DigTime, local439)
	for local440 := range (*(*(struct {
		Name string

		//mt:32to16
		Uses int32

		MaxLvl int16

		//mt:len32
		Times []DigTime
	}))(obj)).Times {
		if err := pcall(func() {
			(((*(*(struct {
				Name string

				//mt:32to16
				Uses int32

				MaxLvl int16

				//mt:len32
				Times []DigTime
			}))(obj)).Times)[local440]).deserialize(r)
		}); err != nil {
			if err == io.EOF {
				chk(io.EOF)
			}
			chk(fmt.Errorf("%s: %w", "github.com/HimbeerserverDE/mt.DigTime", err))
		}
	}
}

func (obj *TouchInteractionMode) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *TouchInteractionMode) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *BlendMode) serialize(w io.Writer) {
	{
		x := *(*(uint8))(obj)
		write8(w, uint8(x))
	}
}

func (obj *BlendMode) deserialize(r io.Reader) {
	{
		p := &*(*(uint8))(obj)
		*p = read8(r)
	}
}

func (obj *DigTime) serialize(w io.Writer) {
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		write16(w, uint16(x))
	}
	{
		x := (*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		write32(w, math.Float32bits(x))
	}
}

func (obj *DigTime) deserialize(r io.Reader) {
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Rating
		*p = int16(read16(r))
	}
	{
		p := &(*(*(struct {
			Rating int16
			Time   float32
		}))(obj)).Time
		*p = math.Float32frombits(read32(r))
	}
}
